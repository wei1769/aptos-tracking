schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""whether this query should be cached (Hasura Cloud only)"""
directive @cached(
  """measured in seconds"""
  ttl: Int! = 60

  """refresh the cache entry"""
  refresh: Boolean! = false
) on QUERY

"""
Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
"""
input Boolean_comparison_exp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _is_null: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String

  """does the column match the given case-insensitive pattern"""
  _ilike: String
  _in: [String!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String
  _is_null: Boolean

  """does the column match the given pattern"""
  _like: String
  _lt: String
  _lte: String
  _neq: String

  """does the column NOT match the given case-insensitive pattern"""
  _nilike: String
  _nin: [String!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String

  """does the column NOT match the given pattern"""
  _nlike: String

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String

  """does the column NOT match the given SQL regular expression"""
  _nsimilar: String

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String

  """does the column match the given SQL regular expression"""
  _similar: String
}

"""
columns and relationships of "account_transactions"
"""
type account_transactions {
  account_address: String!

  """An array relationship"""
  coin_activities(
    """distinct select on columns"""
    distinct_on: [coin_activities_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [coin_activities_order_by!]

    """filter the rows returned"""
    where: coin_activities_bool_exp
  ): [coin_activities!]!

  """An aggregate relationship"""
  coin_activities_aggregate(
    """distinct select on columns"""
    distinct_on: [coin_activities_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [coin_activities_order_by!]

    """filter the rows returned"""
    where: coin_activities_bool_exp
  ): coin_activities_aggregate!

  """An array relationship"""
  delegated_staking_activities(
    """distinct select on columns"""
    distinct_on: [delegated_staking_activities_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delegated_staking_activities_order_by!]

    """filter the rows returned"""
    where: delegated_staking_activities_bool_exp
  ): [delegated_staking_activities!]!

  """An aggregate relationship"""
  delegated_staking_activities_aggregate(
    """distinct select on columns"""
    distinct_on: [delegated_staking_activities_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delegated_staking_activities_order_by!]

    """filter the rows returned"""
    where: delegated_staking_activities_bool_exp
  ): delegated_staking_activities_aggregate!

  """An array relationship"""
  fungible_asset_activities(
    """distinct select on columns"""
    distinct_on: [fungible_asset_activities_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [fungible_asset_activities_order_by!]

    """filter the rows returned"""
    where: fungible_asset_activities_bool_exp
  ): [fungible_asset_activities!]!

  """An aggregate relationship"""
  fungible_asset_activities_aggregate(
    """distinct select on columns"""
    distinct_on: [fungible_asset_activities_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [fungible_asset_activities_order_by!]

    """filter the rows returned"""
    where: fungible_asset_activities_bool_exp
  ): fungible_asset_activities_aggregate!
  inserted_at: timestamp!

  """An array relationship"""
  token_activities(
    """distinct select on columns"""
    distinct_on: [token_activities_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_activities_order_by!]

    """filter the rows returned"""
    where: token_activities_bool_exp
  ): [token_activities!]!

  """An aggregate relationship"""
  token_activities_aggregate(
    """distinct select on columns"""
    distinct_on: [token_activities_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_activities_order_by!]

    """filter the rows returned"""
    where: token_activities_bool_exp
  ): token_activities_aggregate!

  """An array relationship"""
  token_activities_v2(
    """distinct select on columns"""
    distinct_on: [token_activities_v2_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_activities_v2_order_by!]

    """filter the rows returned"""
    where: token_activities_v2_bool_exp
  ): [token_activities_v2!]!

  """An aggregate relationship"""
  token_activities_v2_aggregate(
    """distinct select on columns"""
    distinct_on: [token_activities_v2_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_activities_v2_order_by!]

    """filter the rows returned"""
    where: token_activities_v2_bool_exp
  ): token_activities_v2_aggregate!
  transaction_version: bigint!

  """An object relationship"""
  user_transaction: user_transactions
}

"""
aggregated selection of "account_transactions"
"""
type account_transactions_aggregate {
  aggregate: account_transactions_aggregate_fields
  nodes: [account_transactions!]!
}

"""
aggregate fields of "account_transactions"
"""
type account_transactions_aggregate_fields {
  avg: account_transactions_avg_fields
  count(columns: [account_transactions_select_column!], distinct: Boolean): Int!
  max: account_transactions_max_fields
  min: account_transactions_min_fields
  stddev: account_transactions_stddev_fields
  stddev_pop: account_transactions_stddev_pop_fields
  stddev_samp: account_transactions_stddev_samp_fields
  sum: account_transactions_sum_fields
  var_pop: account_transactions_var_pop_fields
  var_samp: account_transactions_var_samp_fields
  variance: account_transactions_variance_fields
}

"""aggregate avg on columns"""
type account_transactions_avg_fields {
  transaction_version: Float
}

"""
Boolean expression to filter rows from the table "account_transactions". All fields are combined with a logical 'AND'.
"""
input account_transactions_bool_exp {
  _and: [account_transactions_bool_exp!]
  _not: account_transactions_bool_exp
  _or: [account_transactions_bool_exp!]
  account_address: String_comparison_exp
  coin_activities: coin_activities_bool_exp
  coin_activities_aggregate: coin_activities_aggregate_bool_exp
  delegated_staking_activities: delegated_staking_activities_bool_exp
  delegated_staking_activities_aggregate: delegated_staking_activities_aggregate_bool_exp
  fungible_asset_activities: fungible_asset_activities_bool_exp
  fungible_asset_activities_aggregate: fungible_asset_activities_aggregate_bool_exp
  inserted_at: timestamp_comparison_exp
  token_activities: token_activities_bool_exp
  token_activities_aggregate: token_activities_aggregate_bool_exp
  token_activities_v2: token_activities_v2_bool_exp
  token_activities_v2_aggregate: token_activities_v2_aggregate_bool_exp
  transaction_version: bigint_comparison_exp
  user_transaction: user_transactions_bool_exp
}

"""
unique or primary key constraints on table "account_transactions"
"""
enum account_transactions_constraint {
  """
  unique or primary key constraint on columns "transaction_version", "account_address"
  """
  account_transactions_pkey
}

"""
input type for incrementing numeric columns in table "account_transactions"
"""
input account_transactions_inc_input {
  transaction_version: bigint
}

"""
input type for inserting data into table "account_transactions"
"""
input account_transactions_insert_input {
  account_address: String
  coin_activities: coin_activities_arr_rel_insert_input
  delegated_staking_activities: delegated_staking_activities_arr_rel_insert_input
  fungible_asset_activities: fungible_asset_activities_arr_rel_insert_input
  inserted_at: timestamp
  token_activities: token_activities_arr_rel_insert_input
  token_activities_v2: token_activities_v2_arr_rel_insert_input
  transaction_version: bigint
  user_transaction: user_transactions_obj_rel_insert_input
}

"""aggregate max on columns"""
type account_transactions_max_fields {
  account_address: String
  inserted_at: timestamp
  transaction_version: bigint
}

"""aggregate min on columns"""
type account_transactions_min_fields {
  account_address: String
  inserted_at: timestamp
  transaction_version: bigint
}

"""
response of any mutation on the table "account_transactions"
"""
type account_transactions_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [account_transactions!]!
}

"""
on_conflict condition type for table "account_transactions"
"""
input account_transactions_on_conflict {
  constraint: account_transactions_constraint!
  update_columns: [account_transactions_update_column!]! = []
  where: account_transactions_bool_exp
}

"""Ordering options when selecting data from "account_transactions"."""
input account_transactions_order_by {
  account_address: order_by
  coin_activities_aggregate: coin_activities_aggregate_order_by
  delegated_staking_activities_aggregate: delegated_staking_activities_aggregate_order_by
  fungible_asset_activities_aggregate: fungible_asset_activities_aggregate_order_by
  inserted_at: order_by
  token_activities_aggregate: token_activities_aggregate_order_by
  token_activities_v2_aggregate: token_activities_v2_aggregate_order_by
  transaction_version: order_by
  user_transaction: user_transactions_order_by
}

"""primary key columns input for table: account_transactions"""
input account_transactions_pk_columns_input {
  account_address: String!
  transaction_version: bigint!
}

"""
select columns of table "account_transactions"
"""
enum account_transactions_select_column {
  """column name"""
  account_address

  """column name"""
  inserted_at

  """column name"""
  transaction_version
}

"""
input type for updating data in table "account_transactions"
"""
input account_transactions_set_input {
  account_address: String
  inserted_at: timestamp
  transaction_version: bigint
}

"""aggregate stddev on columns"""
type account_transactions_stddev_fields {
  transaction_version: Float
}

"""aggregate stddev_pop on columns"""
type account_transactions_stddev_pop_fields {
  transaction_version: Float
}

"""aggregate stddev_samp on columns"""
type account_transactions_stddev_samp_fields {
  transaction_version: Float
}

"""
Streaming cursor of the table "account_transactions"
"""
input account_transactions_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: account_transactions_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input account_transactions_stream_cursor_value_input {
  account_address: String
  inserted_at: timestamp
  transaction_version: bigint
}

"""aggregate sum on columns"""
type account_transactions_sum_fields {
  transaction_version: bigint
}

"""
update columns of table "account_transactions"
"""
enum account_transactions_update_column {
  """column name"""
  account_address

  """column name"""
  inserted_at

  """column name"""
  transaction_version
}

input account_transactions_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: account_transactions_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: account_transactions_set_input

  """filter the rows which have to be updated"""
  where: account_transactions_bool_exp!
}

"""aggregate var_pop on columns"""
type account_transactions_var_pop_fields {
  transaction_version: Float
}

"""aggregate var_samp on columns"""
type account_transactions_var_samp_fields {
  transaction_version: Float
}

"""aggregate variance on columns"""
type account_transactions_variance_fields {
  transaction_version: Float
}

"""
columns and relationships of "address_events_summary"
"""
type address_events_summary {
  account_address: String

  """An object relationship"""
  block_metadata: block_metadata_transactions
  min_block_height: bigint
  num_distinct_versions: bigint
}

"""
aggregated selection of "address_events_summary"
"""
type address_events_summary_aggregate {
  aggregate: address_events_summary_aggregate_fields
  nodes: [address_events_summary!]!
}

"""
aggregate fields of "address_events_summary"
"""
type address_events_summary_aggregate_fields {
  avg: address_events_summary_avg_fields
  count(columns: [address_events_summary_select_column!], distinct: Boolean): Int!
  max: address_events_summary_max_fields
  min: address_events_summary_min_fields
  stddev: address_events_summary_stddev_fields
  stddev_pop: address_events_summary_stddev_pop_fields
  stddev_samp: address_events_summary_stddev_samp_fields
  sum: address_events_summary_sum_fields
  var_pop: address_events_summary_var_pop_fields
  var_samp: address_events_summary_var_samp_fields
  variance: address_events_summary_variance_fields
}

"""aggregate avg on columns"""
type address_events_summary_avg_fields {
  min_block_height: Float
  num_distinct_versions: Float
}

"""
Boolean expression to filter rows from the table "address_events_summary". All fields are combined with a logical 'AND'.
"""
input address_events_summary_bool_exp {
  _and: [address_events_summary_bool_exp!]
  _not: address_events_summary_bool_exp
  _or: [address_events_summary_bool_exp!]
  account_address: String_comparison_exp
  block_metadata: block_metadata_transactions_bool_exp
  min_block_height: bigint_comparison_exp
  num_distinct_versions: bigint_comparison_exp
}

"""aggregate max on columns"""
type address_events_summary_max_fields {
  account_address: String
  min_block_height: bigint
  num_distinct_versions: bigint
}

"""aggregate min on columns"""
type address_events_summary_min_fields {
  account_address: String
  min_block_height: bigint
  num_distinct_versions: bigint
}

"""Ordering options when selecting data from "address_events_summary"."""
input address_events_summary_order_by {
  account_address: order_by
  block_metadata: block_metadata_transactions_order_by
  min_block_height: order_by
  num_distinct_versions: order_by
}

"""
select columns of table "address_events_summary"
"""
enum address_events_summary_select_column {
  """column name"""
  account_address

  """column name"""
  min_block_height

  """column name"""
  num_distinct_versions
}

"""aggregate stddev on columns"""
type address_events_summary_stddev_fields {
  min_block_height: Float
  num_distinct_versions: Float
}

"""aggregate stddev_pop on columns"""
type address_events_summary_stddev_pop_fields {
  min_block_height: Float
  num_distinct_versions: Float
}

"""aggregate stddev_samp on columns"""
type address_events_summary_stddev_samp_fields {
  min_block_height: Float
  num_distinct_versions: Float
}

"""
Streaming cursor of the table "address_events_summary"
"""
input address_events_summary_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: address_events_summary_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input address_events_summary_stream_cursor_value_input {
  account_address: String
  min_block_height: bigint
  num_distinct_versions: bigint
}

"""aggregate sum on columns"""
type address_events_summary_sum_fields {
  min_block_height: bigint
  num_distinct_versions: bigint
}

"""aggregate var_pop on columns"""
type address_events_summary_var_pop_fields {
  min_block_height: Float
  num_distinct_versions: Float
}

"""aggregate var_samp on columns"""
type address_events_summary_var_samp_fields {
  min_block_height: Float
  num_distinct_versions: Float
}

"""aggregate variance on columns"""
type address_events_summary_variance_fields {
  min_block_height: Float
  num_distinct_versions: Float
}

"""
columns and relationships of "address_version_from_events"
"""
type address_version_from_events {
  account_address: String

  """An array relationship"""
  coin_activities(
    """distinct select on columns"""
    distinct_on: [coin_activities_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [coin_activities_order_by!]

    """filter the rows returned"""
    where: coin_activities_bool_exp
  ): [coin_activities!]!

  """An aggregate relationship"""
  coin_activities_aggregate(
    """distinct select on columns"""
    distinct_on: [coin_activities_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [coin_activities_order_by!]

    """filter the rows returned"""
    where: coin_activities_bool_exp
  ): coin_activities_aggregate!

  """An array relationship"""
  delegated_staking_activities(
    """distinct select on columns"""
    distinct_on: [delegated_staking_activities_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delegated_staking_activities_order_by!]

    """filter the rows returned"""
    where: delegated_staking_activities_bool_exp
  ): [delegated_staking_activities!]!

  """An aggregate relationship"""
  delegated_staking_activities_aggregate(
    """distinct select on columns"""
    distinct_on: [delegated_staking_activities_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delegated_staking_activities_order_by!]

    """filter the rows returned"""
    where: delegated_staking_activities_bool_exp
  ): delegated_staking_activities_aggregate!

  """An array relationship"""
  token_activities(
    """distinct select on columns"""
    distinct_on: [token_activities_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_activities_order_by!]

    """filter the rows returned"""
    where: token_activities_bool_exp
  ): [token_activities!]!

  """An aggregate relationship"""
  token_activities_aggregate(
    """distinct select on columns"""
    distinct_on: [token_activities_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_activities_order_by!]

    """filter the rows returned"""
    where: token_activities_bool_exp
  ): token_activities_aggregate!

  """An array relationship"""
  token_activities_v2(
    """distinct select on columns"""
    distinct_on: [token_activities_v2_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_activities_v2_order_by!]

    """filter the rows returned"""
    where: token_activities_v2_bool_exp
  ): [token_activities_v2!]!

  """An aggregate relationship"""
  token_activities_v2_aggregate(
    """distinct select on columns"""
    distinct_on: [token_activities_v2_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_activities_v2_order_by!]

    """filter the rows returned"""
    where: token_activities_v2_bool_exp
  ): token_activities_v2_aggregate!
  transaction_version: bigint
}

"""
aggregated selection of "address_version_from_events"
"""
type address_version_from_events_aggregate {
  aggregate: address_version_from_events_aggregate_fields
  nodes: [address_version_from_events!]!
}

"""
aggregate fields of "address_version_from_events"
"""
type address_version_from_events_aggregate_fields {
  avg: address_version_from_events_avg_fields
  count(columns: [address_version_from_events_select_column!], distinct: Boolean): Int!
  max: address_version_from_events_max_fields
  min: address_version_from_events_min_fields
  stddev: address_version_from_events_stddev_fields
  stddev_pop: address_version_from_events_stddev_pop_fields
  stddev_samp: address_version_from_events_stddev_samp_fields
  sum: address_version_from_events_sum_fields
  var_pop: address_version_from_events_var_pop_fields
  var_samp: address_version_from_events_var_samp_fields
  variance: address_version_from_events_variance_fields
}

"""aggregate avg on columns"""
type address_version_from_events_avg_fields {
  transaction_version: Float
}

"""
Boolean expression to filter rows from the table "address_version_from_events". All fields are combined with a logical 'AND'.
"""
input address_version_from_events_bool_exp {
  _and: [address_version_from_events_bool_exp!]
  _not: address_version_from_events_bool_exp
  _or: [address_version_from_events_bool_exp!]
  account_address: String_comparison_exp
  coin_activities: coin_activities_bool_exp
  coin_activities_aggregate: coin_activities_aggregate_bool_exp
  delegated_staking_activities: delegated_staking_activities_bool_exp
  delegated_staking_activities_aggregate: delegated_staking_activities_aggregate_bool_exp
  token_activities: token_activities_bool_exp
  token_activities_aggregate: token_activities_aggregate_bool_exp
  token_activities_v2: token_activities_v2_bool_exp
  token_activities_v2_aggregate: token_activities_v2_aggregate_bool_exp
  transaction_version: bigint_comparison_exp
}

"""aggregate max on columns"""
type address_version_from_events_max_fields {
  account_address: String
  transaction_version: bigint
}

"""aggregate min on columns"""
type address_version_from_events_min_fields {
  account_address: String
  transaction_version: bigint
}

"""
Ordering options when selecting data from "address_version_from_events".
"""
input address_version_from_events_order_by {
  account_address: order_by
  coin_activities_aggregate: coin_activities_aggregate_order_by
  delegated_staking_activities_aggregate: delegated_staking_activities_aggregate_order_by
  token_activities_aggregate: token_activities_aggregate_order_by
  token_activities_v2_aggregate: token_activities_v2_aggregate_order_by
  transaction_version: order_by
}

"""
select columns of table "address_version_from_events"
"""
enum address_version_from_events_select_column {
  """column name"""
  account_address

  """column name"""
  transaction_version
}

"""aggregate stddev on columns"""
type address_version_from_events_stddev_fields {
  transaction_version: Float
}

"""aggregate stddev_pop on columns"""
type address_version_from_events_stddev_pop_fields {
  transaction_version: Float
}

"""aggregate stddev_samp on columns"""
type address_version_from_events_stddev_samp_fields {
  transaction_version: Float
}

"""
Streaming cursor of the table "address_version_from_events"
"""
input address_version_from_events_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: address_version_from_events_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input address_version_from_events_stream_cursor_value_input {
  account_address: String
  transaction_version: bigint
}

"""aggregate sum on columns"""
type address_version_from_events_sum_fields {
  transaction_version: bigint
}

"""aggregate var_pop on columns"""
type address_version_from_events_var_pop_fields {
  transaction_version: Float
}

"""aggregate var_samp on columns"""
type address_version_from_events_var_samp_fields {
  transaction_version: Float
}

"""aggregate variance on columns"""
type address_version_from_events_variance_fields {
  transaction_version: Float
}

"""
columns and relationships of "legacy_migration_v1.address_version_from_move_resources"
"""
type address_version_from_move_resources {
  address: String

  """An array relationship"""
  coin_activities(
    """distinct select on columns"""
    distinct_on: [coin_activities_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [coin_activities_order_by!]

    """filter the rows returned"""
    where: coin_activities_bool_exp
  ): [coin_activities!]!

  """An aggregate relationship"""
  coin_activities_aggregate(
    """distinct select on columns"""
    distinct_on: [coin_activities_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [coin_activities_order_by!]

    """filter the rows returned"""
    where: coin_activities_bool_exp
  ): coin_activities_aggregate!

  """An array relationship"""
  delegated_staking_activities(
    """distinct select on columns"""
    distinct_on: [delegated_staking_activities_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delegated_staking_activities_order_by!]

    """filter the rows returned"""
    where: delegated_staking_activities_bool_exp
  ): [delegated_staking_activities!]!

  """An aggregate relationship"""
  delegated_staking_activities_aggregate(
    """distinct select on columns"""
    distinct_on: [delegated_staking_activities_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delegated_staking_activities_order_by!]

    """filter the rows returned"""
    where: delegated_staking_activities_bool_exp
  ): delegated_staking_activities_aggregate!

  """An array relationship"""
  token_activities(
    """distinct select on columns"""
    distinct_on: [token_activities_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_activities_order_by!]

    """filter the rows returned"""
    where: token_activities_bool_exp
  ): [token_activities!]!

  """An aggregate relationship"""
  token_activities_aggregate(
    """distinct select on columns"""
    distinct_on: [token_activities_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_activities_order_by!]

    """filter the rows returned"""
    where: token_activities_bool_exp
  ): token_activities_aggregate!

  """An array relationship"""
  token_activities_v2(
    """distinct select on columns"""
    distinct_on: [token_activities_v2_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_activities_v2_order_by!]

    """filter the rows returned"""
    where: token_activities_v2_bool_exp
  ): [token_activities_v2!]!

  """An aggregate relationship"""
  token_activities_v2_aggregate(
    """distinct select on columns"""
    distinct_on: [token_activities_v2_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_activities_v2_order_by!]

    """filter the rows returned"""
    where: token_activities_v2_bool_exp
  ): token_activities_v2_aggregate!
  transaction_version: bigint
}

"""
aggregated selection of "legacy_migration_v1.address_version_from_move_resources"
"""
type address_version_from_move_resources_aggregate {
  aggregate: address_version_from_move_resources_aggregate_fields
  nodes: [address_version_from_move_resources!]!
}

"""
aggregate fields of "legacy_migration_v1.address_version_from_move_resources"
"""
type address_version_from_move_resources_aggregate_fields {
  avg: address_version_from_move_resources_avg_fields
  count(columns: [address_version_from_move_resources_select_column!], distinct: Boolean): Int!
  max: address_version_from_move_resources_max_fields
  min: address_version_from_move_resources_min_fields
  stddev: address_version_from_move_resources_stddev_fields
  stddev_pop: address_version_from_move_resources_stddev_pop_fields
  stddev_samp: address_version_from_move_resources_stddev_samp_fields
  sum: address_version_from_move_resources_sum_fields
  var_pop: address_version_from_move_resources_var_pop_fields
  var_samp: address_version_from_move_resources_var_samp_fields
  variance: address_version_from_move_resources_variance_fields
}

"""aggregate avg on columns"""
type address_version_from_move_resources_avg_fields {
  transaction_version: Float
}

"""
Boolean expression to filter rows from the table "legacy_migration_v1.address_version_from_move_resources". All fields are combined with a logical 'AND'.
"""
input address_version_from_move_resources_bool_exp {
  _and: [address_version_from_move_resources_bool_exp!]
  _not: address_version_from_move_resources_bool_exp
  _or: [address_version_from_move_resources_bool_exp!]
  address: String_comparison_exp
  coin_activities: coin_activities_bool_exp
  coin_activities_aggregate: coin_activities_aggregate_bool_exp
  delegated_staking_activities: delegated_staking_activities_bool_exp
  delegated_staking_activities_aggregate: delegated_staking_activities_aggregate_bool_exp
  token_activities: token_activities_bool_exp
  token_activities_aggregate: token_activities_aggregate_bool_exp
  token_activities_v2: token_activities_v2_bool_exp
  token_activities_v2_aggregate: token_activities_v2_aggregate_bool_exp
  transaction_version: bigint_comparison_exp
}

"""
input type for incrementing numeric columns in table "legacy_migration_v1.address_version_from_move_resources"
"""
input address_version_from_move_resources_inc_input {
  transaction_version: bigint
}

"""
input type for inserting data into table "legacy_migration_v1.address_version_from_move_resources"
"""
input address_version_from_move_resources_insert_input {
  address: String
  coin_activities: coin_activities_arr_rel_insert_input
  delegated_staking_activities: delegated_staking_activities_arr_rel_insert_input
  token_activities: token_activities_arr_rel_insert_input
  token_activities_v2: token_activities_v2_arr_rel_insert_input
  transaction_version: bigint
}

"""aggregate max on columns"""
type address_version_from_move_resources_max_fields {
  address: String
  transaction_version: bigint
}

"""aggregate min on columns"""
type address_version_from_move_resources_min_fields {
  address: String
  transaction_version: bigint
}

"""
response of any mutation on the table "legacy_migration_v1.address_version_from_move_resources"
"""
type address_version_from_move_resources_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [address_version_from_move_resources!]!
}

"""
Ordering options when selecting data from "legacy_migration_v1.address_version_from_move_resources".
"""
input address_version_from_move_resources_order_by {
  address: order_by
  coin_activities_aggregate: coin_activities_aggregate_order_by
  delegated_staking_activities_aggregate: delegated_staking_activities_aggregate_order_by
  token_activities_aggregate: token_activities_aggregate_order_by
  token_activities_v2_aggregate: token_activities_v2_aggregate_order_by
  transaction_version: order_by
}

"""
select columns of table "legacy_migration_v1.address_version_from_move_resources"
"""
enum address_version_from_move_resources_select_column {
  """column name"""
  address

  """column name"""
  transaction_version
}

"""
input type for updating data in table "legacy_migration_v1.address_version_from_move_resources"
"""
input address_version_from_move_resources_set_input {
  address: String
  transaction_version: bigint
}

"""aggregate stddev on columns"""
type address_version_from_move_resources_stddev_fields {
  transaction_version: Float
}

"""aggregate stddev_pop on columns"""
type address_version_from_move_resources_stddev_pop_fields {
  transaction_version: Float
}

"""aggregate stddev_samp on columns"""
type address_version_from_move_resources_stddev_samp_fields {
  transaction_version: Float
}

"""
Streaming cursor of the table "address_version_from_move_resources"
"""
input address_version_from_move_resources_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: address_version_from_move_resources_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input address_version_from_move_resources_stream_cursor_value_input {
  address: String
  transaction_version: bigint
}

"""aggregate sum on columns"""
type address_version_from_move_resources_sum_fields {
  transaction_version: bigint
}

input address_version_from_move_resources_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: address_version_from_move_resources_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: address_version_from_move_resources_set_input

  """filter the rows which have to be updated"""
  where: address_version_from_move_resources_bool_exp!
}

"""aggregate var_pop on columns"""
type address_version_from_move_resources_var_pop_fields {
  transaction_version: Float
}

"""aggregate var_samp on columns"""
type address_version_from_move_resources_var_samp_fields {
  transaction_version: Float
}

"""aggregate variance on columns"""
type address_version_from_move_resources_variance_fields {
  transaction_version: Float
}

scalar bigint

"""
Boolean expression to compare columns of type "bigint". All fields are combined with logical 'AND'.
"""
input bigint_comparison_exp {
  _eq: bigint
  _gt: bigint
  _gte: bigint
  _in: [bigint!]
  _is_null: Boolean
  _lt: bigint
  _lte: bigint
  _neq: bigint
  _nin: [bigint!]
}

"""
columns and relationships of "block_metadata_transactions"
"""
type block_metadata_transactions {
  block_height: bigint!
  epoch: bigint!
  failed_proposer_indices(
    """JSON select path"""
    path: String
  ): jsonb!
  id: String!
  inserted_at: timestamp!
  previous_block_votes_bitvec(
    """JSON select path"""
    path: String
  ): jsonb!
  proposer: String!
  round: bigint!
  timestamp: timestamp!
  version: bigint!
}

"""
aggregated selection of "block_metadata_transactions"
"""
type block_metadata_transactions_aggregate {
  aggregate: block_metadata_transactions_aggregate_fields
  nodes: [block_metadata_transactions!]!
}

"""
aggregate fields of "block_metadata_transactions"
"""
type block_metadata_transactions_aggregate_fields {
  avg: block_metadata_transactions_avg_fields
  count(columns: [block_metadata_transactions_select_column!], distinct: Boolean): Int!
  max: block_metadata_transactions_max_fields
  min: block_metadata_transactions_min_fields
  stddev: block_metadata_transactions_stddev_fields
  stddev_pop: block_metadata_transactions_stddev_pop_fields
  stddev_samp: block_metadata_transactions_stddev_samp_fields
  sum: block_metadata_transactions_sum_fields
  var_pop: block_metadata_transactions_var_pop_fields
  var_samp: block_metadata_transactions_var_samp_fields
  variance: block_metadata_transactions_variance_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input block_metadata_transactions_append_input {
  failed_proposer_indices: jsonb
  previous_block_votes_bitvec: jsonb
}

"""aggregate avg on columns"""
type block_metadata_transactions_avg_fields {
  block_height: Float
  epoch: Float
  round: Float
  version: Float
}

"""
Boolean expression to filter rows from the table "block_metadata_transactions". All fields are combined with a logical 'AND'.
"""
input block_metadata_transactions_bool_exp {
  _and: [block_metadata_transactions_bool_exp!]
  _not: block_metadata_transactions_bool_exp
  _or: [block_metadata_transactions_bool_exp!]
  block_height: bigint_comparison_exp
  epoch: bigint_comparison_exp
  failed_proposer_indices: jsonb_comparison_exp
  id: String_comparison_exp
  inserted_at: timestamp_comparison_exp
  previous_block_votes_bitvec: jsonb_comparison_exp
  proposer: String_comparison_exp
  round: bigint_comparison_exp
  timestamp: timestamp_comparison_exp
  version: bigint_comparison_exp
}

"""
unique or primary key constraints on table "block_metadata_transactions"
"""
enum block_metadata_transactions_constraint {
  """
  unique or primary key constraint on columns "block_height"
  """
  block_metadata_transactions_block_height_key

  """
  unique or primary key constraint on columns "version"
  """
  block_metadata_transactions_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input block_metadata_transactions_delete_at_path_input {
  failed_proposer_indices: [String!]
  previous_block_votes_bitvec: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input block_metadata_transactions_delete_elem_input {
  failed_proposer_indices: Int
  previous_block_votes_bitvec: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input block_metadata_transactions_delete_key_input {
  failed_proposer_indices: String
  previous_block_votes_bitvec: String
}

"""
input type for incrementing numeric columns in table "block_metadata_transactions"
"""
input block_metadata_transactions_inc_input {
  block_height: bigint
  epoch: bigint
  round: bigint
  version: bigint
}

"""
input type for inserting data into table "block_metadata_transactions"
"""
input block_metadata_transactions_insert_input {
  block_height: bigint
  epoch: bigint
  failed_proposer_indices: jsonb
  id: String
  inserted_at: timestamp
  previous_block_votes_bitvec: jsonb
  proposer: String
  round: bigint
  timestamp: timestamp
  version: bigint
}

"""aggregate max on columns"""
type block_metadata_transactions_max_fields {
  block_height: bigint
  epoch: bigint
  id: String
  inserted_at: timestamp
  proposer: String
  round: bigint
  timestamp: timestamp
  version: bigint
}

"""aggregate min on columns"""
type block_metadata_transactions_min_fields {
  block_height: bigint
  epoch: bigint
  id: String
  inserted_at: timestamp
  proposer: String
  round: bigint
  timestamp: timestamp
  version: bigint
}

"""
response of any mutation on the table "block_metadata_transactions"
"""
type block_metadata_transactions_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [block_metadata_transactions!]!
}

"""
on_conflict condition type for table "block_metadata_transactions"
"""
input block_metadata_transactions_on_conflict {
  constraint: block_metadata_transactions_constraint!
  update_columns: [block_metadata_transactions_update_column!]! = []
  where: block_metadata_transactions_bool_exp
}

"""
Ordering options when selecting data from "block_metadata_transactions".
"""
input block_metadata_transactions_order_by {
  block_height: order_by
  epoch: order_by
  failed_proposer_indices: order_by
  id: order_by
  inserted_at: order_by
  previous_block_votes_bitvec: order_by
  proposer: order_by
  round: order_by
  timestamp: order_by
  version: order_by
}

"""primary key columns input for table: block_metadata_transactions"""
input block_metadata_transactions_pk_columns_input {
  version: bigint!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input block_metadata_transactions_prepend_input {
  failed_proposer_indices: jsonb
  previous_block_votes_bitvec: jsonb
}

"""
select columns of table "block_metadata_transactions"
"""
enum block_metadata_transactions_select_column {
  """column name"""
  block_height

  """column name"""
  epoch

  """column name"""
  failed_proposer_indices

  """column name"""
  id

  """column name"""
  inserted_at

  """column name"""
  previous_block_votes_bitvec

  """column name"""
  proposer

  """column name"""
  round

  """column name"""
  timestamp

  """column name"""
  version
}

"""
input type for updating data in table "block_metadata_transactions"
"""
input block_metadata_transactions_set_input {
  block_height: bigint
  epoch: bigint
  failed_proposer_indices: jsonb
  id: String
  inserted_at: timestamp
  previous_block_votes_bitvec: jsonb
  proposer: String
  round: bigint
  timestamp: timestamp
  version: bigint
}

"""aggregate stddev on columns"""
type block_metadata_transactions_stddev_fields {
  block_height: Float
  epoch: Float
  round: Float
  version: Float
}

"""aggregate stddev_pop on columns"""
type block_metadata_transactions_stddev_pop_fields {
  block_height: Float
  epoch: Float
  round: Float
  version: Float
}

"""aggregate stddev_samp on columns"""
type block_metadata_transactions_stddev_samp_fields {
  block_height: Float
  epoch: Float
  round: Float
  version: Float
}

"""
Streaming cursor of the table "block_metadata_transactions"
"""
input block_metadata_transactions_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: block_metadata_transactions_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input block_metadata_transactions_stream_cursor_value_input {
  block_height: bigint
  epoch: bigint
  failed_proposer_indices: jsonb
  id: String
  inserted_at: timestamp
  previous_block_votes_bitvec: jsonb
  proposer: String
  round: bigint
  timestamp: timestamp
  version: bigint
}

"""aggregate sum on columns"""
type block_metadata_transactions_sum_fields {
  block_height: bigint
  epoch: bigint
  round: bigint
  version: bigint
}

"""
update columns of table "block_metadata_transactions"
"""
enum block_metadata_transactions_update_column {
  """column name"""
  block_height

  """column name"""
  epoch

  """column name"""
  failed_proposer_indices

  """column name"""
  id

  """column name"""
  inserted_at

  """column name"""
  previous_block_votes_bitvec

  """column name"""
  proposer

  """column name"""
  round

  """column name"""
  timestamp

  """column name"""
  version
}

input block_metadata_transactions_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: block_metadata_transactions_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: block_metadata_transactions_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: block_metadata_transactions_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: block_metadata_transactions_delete_key_input

  """increments the numeric columns with given value of the filtered values"""
  _inc: block_metadata_transactions_inc_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: block_metadata_transactions_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: block_metadata_transactions_set_input

  """filter the rows which have to be updated"""
  where: block_metadata_transactions_bool_exp!
}

"""aggregate var_pop on columns"""
type block_metadata_transactions_var_pop_fields {
  block_height: Float
  epoch: Float
  round: Float
  version: Float
}

"""aggregate var_samp on columns"""
type block_metadata_transactions_var_samp_fields {
  block_height: Float
  epoch: Float
  round: Float
  version: Float
}

"""aggregate variance on columns"""
type block_metadata_transactions_variance_fields {
  block_height: Float
  epoch: Float
  round: Float
  version: Float
}

"""
columns and relationships of "legacy_migration_v1.coin_activities"
"""
type coin_activities {
  activity_type: String
  amount: numeric

  """An array relationship"""
  aptos_names(
    """distinct select on columns"""
    distinct_on: [current_aptos_names_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_aptos_names_order_by!]

    """filter the rows returned"""
    where: current_aptos_names_bool_exp
  ): [current_aptos_names!]!

  """An aggregate relationship"""
  aptos_names_aggregate(
    """distinct select on columns"""
    distinct_on: [current_aptos_names_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_aptos_names_order_by!]

    """filter the rows returned"""
    where: current_aptos_names_bool_exp
  ): current_aptos_names_aggregate!
  block_height: bigint

  """An object relationship"""
  coin_info: coin_infos
  coin_type: String
  entry_function_id_str: String
  event_account_address: String
  event_creation_number: Int
  event_index: bigint
  event_sequence_number: Int
  gas_fee_payer_address: String
  inserted_at: timestamp
  is_gas_fee: Boolean
  is_transaction_success: Boolean
  owner_address: String
  storage_refund_amount: numeric
  transaction_timestamp: timestamp
  transaction_version: bigint
}

"""
aggregated selection of "legacy_migration_v1.coin_activities"
"""
type coin_activities_aggregate {
  aggregate: coin_activities_aggregate_fields
  nodes: [coin_activities!]!
}

input coin_activities_aggregate_bool_exp {
  bool_and: coin_activities_aggregate_bool_exp_bool_and
  bool_or: coin_activities_aggregate_bool_exp_bool_or
  count: coin_activities_aggregate_bool_exp_count
}

input coin_activities_aggregate_bool_exp_bool_and {
  arguments: coin_activities_select_column_coin_activities_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: coin_activities_bool_exp
  predicate: Boolean_comparison_exp!
}

input coin_activities_aggregate_bool_exp_bool_or {
  arguments: coin_activities_select_column_coin_activities_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: coin_activities_bool_exp
  predicate: Boolean_comparison_exp!
}

input coin_activities_aggregate_bool_exp_count {
  arguments: [coin_activities_select_column!]
  distinct: Boolean
  filter: coin_activities_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "legacy_migration_v1.coin_activities"
"""
type coin_activities_aggregate_fields {
  avg: coin_activities_avg_fields
  count(columns: [coin_activities_select_column!], distinct: Boolean): Int!
  max: coin_activities_max_fields
  min: coin_activities_min_fields
  stddev: coin_activities_stddev_fields
  stddev_pop: coin_activities_stddev_pop_fields
  stddev_samp: coin_activities_stddev_samp_fields
  sum: coin_activities_sum_fields
  var_pop: coin_activities_var_pop_fields
  var_samp: coin_activities_var_samp_fields
  variance: coin_activities_variance_fields
}

"""
order by aggregate values of table "legacy_migration_v1.coin_activities"
"""
input coin_activities_aggregate_order_by {
  avg: coin_activities_avg_order_by
  count: order_by
  max: coin_activities_max_order_by
  min: coin_activities_min_order_by
  stddev: coin_activities_stddev_order_by
  stddev_pop: coin_activities_stddev_pop_order_by
  stddev_samp: coin_activities_stddev_samp_order_by
  sum: coin_activities_sum_order_by
  var_pop: coin_activities_var_pop_order_by
  var_samp: coin_activities_var_samp_order_by
  variance: coin_activities_variance_order_by
}

"""
input type for inserting array relation for remote table "legacy_migration_v1.coin_activities"
"""
input coin_activities_arr_rel_insert_input {
  data: [coin_activities_insert_input!]!
}

"""aggregate avg on columns"""
type coin_activities_avg_fields {
  amount: Float
  block_height: Float
  event_creation_number: Float
  event_index: Float
  event_sequence_number: Float
  storage_refund_amount: Float
  transaction_version: Float
}

"""
order by avg() on columns of table "legacy_migration_v1.coin_activities"
"""
input coin_activities_avg_order_by {
  amount: order_by
  block_height: order_by
  event_creation_number: order_by
  event_index: order_by
  event_sequence_number: order_by
  storage_refund_amount: order_by
  transaction_version: order_by
}

"""
Boolean expression to filter rows from the table "legacy_migration_v1.coin_activities". All fields are combined with a logical 'AND'.
"""
input coin_activities_bool_exp {
  _and: [coin_activities_bool_exp!]
  _not: coin_activities_bool_exp
  _or: [coin_activities_bool_exp!]
  activity_type: String_comparison_exp
  amount: numeric_comparison_exp
  aptos_names: current_aptos_names_bool_exp
  aptos_names_aggregate: current_aptos_names_aggregate_bool_exp
  block_height: bigint_comparison_exp
  coin_info: coin_infos_bool_exp
  coin_type: String_comparison_exp
  entry_function_id_str: String_comparison_exp
  event_account_address: String_comparison_exp
  event_creation_number: Int_comparison_exp
  event_index: bigint_comparison_exp
  event_sequence_number: Int_comparison_exp
  gas_fee_payer_address: String_comparison_exp
  inserted_at: timestamp_comparison_exp
  is_gas_fee: Boolean_comparison_exp
  is_transaction_success: Boolean_comparison_exp
  owner_address: String_comparison_exp
  storage_refund_amount: numeric_comparison_exp
  transaction_timestamp: timestamp_comparison_exp
  transaction_version: bigint_comparison_exp
}

"""
input type for incrementing numeric columns in table "legacy_migration_v1.coin_activities"
"""
input coin_activities_inc_input {
  amount: numeric
  block_height: bigint
  event_creation_number: Int
  event_index: bigint
  event_sequence_number: Int
  storage_refund_amount: numeric
  transaction_version: bigint
}

"""
input type for inserting data into table "legacy_migration_v1.coin_activities"
"""
input coin_activities_insert_input {
  activity_type: String
  amount: numeric
  aptos_names: current_aptos_names_arr_rel_insert_input
  block_height: bigint
  coin_info: coin_infos_obj_rel_insert_input
  coin_type: String
  entry_function_id_str: String
  event_account_address: String
  event_creation_number: Int
  event_index: bigint
  event_sequence_number: Int
  gas_fee_payer_address: String
  inserted_at: timestamp
  is_gas_fee: Boolean
  is_transaction_success: Boolean
  owner_address: String
  storage_refund_amount: numeric
  transaction_timestamp: timestamp
  transaction_version: bigint
}

"""aggregate max on columns"""
type coin_activities_max_fields {
  activity_type: String
  amount: numeric
  block_height: bigint
  coin_type: String
  entry_function_id_str: String
  event_account_address: String
  event_creation_number: Int
  event_index: bigint
  event_sequence_number: Int
  gas_fee_payer_address: String
  inserted_at: timestamp
  owner_address: String
  storage_refund_amount: numeric
  transaction_timestamp: timestamp
  transaction_version: bigint
}

"""
order by max() on columns of table "legacy_migration_v1.coin_activities"
"""
input coin_activities_max_order_by {
  activity_type: order_by
  amount: order_by
  block_height: order_by
  coin_type: order_by
  entry_function_id_str: order_by
  event_account_address: order_by
  event_creation_number: order_by
  event_index: order_by
  event_sequence_number: order_by
  gas_fee_payer_address: order_by
  inserted_at: order_by
  owner_address: order_by
  storage_refund_amount: order_by
  transaction_timestamp: order_by
  transaction_version: order_by
}

"""aggregate min on columns"""
type coin_activities_min_fields {
  activity_type: String
  amount: numeric
  block_height: bigint
  coin_type: String
  entry_function_id_str: String
  event_account_address: String
  event_creation_number: Int
  event_index: bigint
  event_sequence_number: Int
  gas_fee_payer_address: String
  inserted_at: timestamp
  owner_address: String
  storage_refund_amount: numeric
  transaction_timestamp: timestamp
  transaction_version: bigint
}

"""
order by min() on columns of table "legacy_migration_v1.coin_activities"
"""
input coin_activities_min_order_by {
  activity_type: order_by
  amount: order_by
  block_height: order_by
  coin_type: order_by
  entry_function_id_str: order_by
  event_account_address: order_by
  event_creation_number: order_by
  event_index: order_by
  event_sequence_number: order_by
  gas_fee_payer_address: order_by
  inserted_at: order_by
  owner_address: order_by
  storage_refund_amount: order_by
  transaction_timestamp: order_by
  transaction_version: order_by
}

"""
response of any mutation on the table "legacy_migration_v1.coin_activities"
"""
type coin_activities_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [coin_activities!]!
}

"""
Ordering options when selecting data from "legacy_migration_v1.coin_activities".
"""
input coin_activities_order_by {
  activity_type: order_by
  amount: order_by
  aptos_names_aggregate: current_aptos_names_aggregate_order_by
  block_height: order_by
  coin_info: coin_infos_order_by
  coin_type: order_by
  entry_function_id_str: order_by
  event_account_address: order_by
  event_creation_number: order_by
  event_index: order_by
  event_sequence_number: order_by
  gas_fee_payer_address: order_by
  inserted_at: order_by
  is_gas_fee: order_by
  is_transaction_success: order_by
  owner_address: order_by
  storage_refund_amount: order_by
  transaction_timestamp: order_by
  transaction_version: order_by
}

"""
select columns of table "legacy_migration_v1.coin_activities"
"""
enum coin_activities_select_column {
  """column name"""
  activity_type

  """column name"""
  amount

  """column name"""
  block_height

  """column name"""
  coin_type

  """column name"""
  entry_function_id_str

  """column name"""
  event_account_address

  """column name"""
  event_creation_number

  """column name"""
  event_index

  """column name"""
  event_sequence_number

  """column name"""
  gas_fee_payer_address

  """column name"""
  inserted_at

  """column name"""
  is_gas_fee

  """column name"""
  is_transaction_success

  """column name"""
  owner_address

  """column name"""
  storage_refund_amount

  """column name"""
  transaction_timestamp

  """column name"""
  transaction_version
}

"""
select "coin_activities_aggregate_bool_exp_bool_and_arguments_columns" columns of table "legacy_migration_v1.coin_activities"
"""
enum coin_activities_select_column_coin_activities_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  is_gas_fee

  """column name"""
  is_transaction_success
}

"""
select "coin_activities_aggregate_bool_exp_bool_or_arguments_columns" columns of table "legacy_migration_v1.coin_activities"
"""
enum coin_activities_select_column_coin_activities_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  is_gas_fee

  """column name"""
  is_transaction_success
}

"""
input type for updating data in table "legacy_migration_v1.coin_activities"
"""
input coin_activities_set_input {
  activity_type: String
  amount: numeric
  block_height: bigint
  coin_type: String
  entry_function_id_str: String
  event_account_address: String
  event_creation_number: Int
  event_index: bigint
  event_sequence_number: Int
  gas_fee_payer_address: String
  inserted_at: timestamp
  is_gas_fee: Boolean
  is_transaction_success: Boolean
  owner_address: String
  storage_refund_amount: numeric
  transaction_timestamp: timestamp
  transaction_version: bigint
}

"""aggregate stddev on columns"""
type coin_activities_stddev_fields {
  amount: Float
  block_height: Float
  event_creation_number: Float
  event_index: Float
  event_sequence_number: Float
  storage_refund_amount: Float
  transaction_version: Float
}

"""
order by stddev() on columns of table "legacy_migration_v1.coin_activities"
"""
input coin_activities_stddev_order_by {
  amount: order_by
  block_height: order_by
  event_creation_number: order_by
  event_index: order_by
  event_sequence_number: order_by
  storage_refund_amount: order_by
  transaction_version: order_by
}

"""aggregate stddev_pop on columns"""
type coin_activities_stddev_pop_fields {
  amount: Float
  block_height: Float
  event_creation_number: Float
  event_index: Float
  event_sequence_number: Float
  storage_refund_amount: Float
  transaction_version: Float
}

"""
order by stddev_pop() on columns of table "legacy_migration_v1.coin_activities"
"""
input coin_activities_stddev_pop_order_by {
  amount: order_by
  block_height: order_by
  event_creation_number: order_by
  event_index: order_by
  event_sequence_number: order_by
  storage_refund_amount: order_by
  transaction_version: order_by
}

"""aggregate stddev_samp on columns"""
type coin_activities_stddev_samp_fields {
  amount: Float
  block_height: Float
  event_creation_number: Float
  event_index: Float
  event_sequence_number: Float
  storage_refund_amount: Float
  transaction_version: Float
}

"""
order by stddev_samp() on columns of table "legacy_migration_v1.coin_activities"
"""
input coin_activities_stddev_samp_order_by {
  amount: order_by
  block_height: order_by
  event_creation_number: order_by
  event_index: order_by
  event_sequence_number: order_by
  storage_refund_amount: order_by
  transaction_version: order_by
}

"""
Streaming cursor of the table "coin_activities"
"""
input coin_activities_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: coin_activities_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input coin_activities_stream_cursor_value_input {
  activity_type: String
  amount: numeric
  block_height: bigint
  coin_type: String
  entry_function_id_str: String
  event_account_address: String
  event_creation_number: Int
  event_index: bigint
  event_sequence_number: Int
  gas_fee_payer_address: String
  inserted_at: timestamp
  is_gas_fee: Boolean
  is_transaction_success: Boolean
  owner_address: String
  storage_refund_amount: numeric
  transaction_timestamp: timestamp
  transaction_version: bigint
}

"""aggregate sum on columns"""
type coin_activities_sum_fields {
  amount: numeric
  block_height: bigint
  event_creation_number: Int
  event_index: bigint
  event_sequence_number: Int
  storage_refund_amount: numeric
  transaction_version: bigint
}

"""
order by sum() on columns of table "legacy_migration_v1.coin_activities"
"""
input coin_activities_sum_order_by {
  amount: order_by
  block_height: order_by
  event_creation_number: order_by
  event_index: order_by
  event_sequence_number: order_by
  storage_refund_amount: order_by
  transaction_version: order_by
}

input coin_activities_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: coin_activities_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: coin_activities_set_input

  """filter the rows which have to be updated"""
  where: coin_activities_bool_exp!
}

"""aggregate var_pop on columns"""
type coin_activities_var_pop_fields {
  amount: Float
  block_height: Float
  event_creation_number: Float
  event_index: Float
  event_sequence_number: Float
  storage_refund_amount: Float
  transaction_version: Float
}

"""
order by var_pop() on columns of table "legacy_migration_v1.coin_activities"
"""
input coin_activities_var_pop_order_by {
  amount: order_by
  block_height: order_by
  event_creation_number: order_by
  event_index: order_by
  event_sequence_number: order_by
  storage_refund_amount: order_by
  transaction_version: order_by
}

"""aggregate var_samp on columns"""
type coin_activities_var_samp_fields {
  amount: Float
  block_height: Float
  event_creation_number: Float
  event_index: Float
  event_sequence_number: Float
  storage_refund_amount: Float
  transaction_version: Float
}

"""
order by var_samp() on columns of table "legacy_migration_v1.coin_activities"
"""
input coin_activities_var_samp_order_by {
  amount: order_by
  block_height: order_by
  event_creation_number: order_by
  event_index: order_by
  event_sequence_number: order_by
  storage_refund_amount: order_by
  transaction_version: order_by
}

"""aggregate variance on columns"""
type coin_activities_variance_fields {
  amount: Float
  block_height: Float
  event_creation_number: Float
  event_index: Float
  event_sequence_number: Float
  storage_refund_amount: Float
  transaction_version: Float
}

"""
order by variance() on columns of table "legacy_migration_v1.coin_activities"
"""
input coin_activities_variance_order_by {
  amount: order_by
  block_height: order_by
  event_creation_number: order_by
  event_index: order_by
  event_sequence_number: order_by
  storage_refund_amount: order_by
  transaction_version: order_by
}

"""
columns and relationships of "legacy_migration_v1.coin_balances"
"""
type coin_balances {
  amount: numeric
  coin_type: String
  coin_type_hash: String
  inserted_at: timestamp
  owner_address: String
  transaction_timestamp: timestamp
  transaction_version: bigint
}

"""
aggregated selection of "legacy_migration_v1.coin_balances"
"""
type coin_balances_aggregate {
  aggregate: coin_balances_aggregate_fields
  nodes: [coin_balances!]!
}

"""
aggregate fields of "legacy_migration_v1.coin_balances"
"""
type coin_balances_aggregate_fields {
  avg: coin_balances_avg_fields
  count(columns: [coin_balances_select_column!], distinct: Boolean): Int!
  max: coin_balances_max_fields
  min: coin_balances_min_fields
  stddev: coin_balances_stddev_fields
  stddev_pop: coin_balances_stddev_pop_fields
  stddev_samp: coin_balances_stddev_samp_fields
  sum: coin_balances_sum_fields
  var_pop: coin_balances_var_pop_fields
  var_samp: coin_balances_var_samp_fields
  variance: coin_balances_variance_fields
}

"""aggregate avg on columns"""
type coin_balances_avg_fields {
  amount: Float
  transaction_version: Float
}

"""
Boolean expression to filter rows from the table "legacy_migration_v1.coin_balances". All fields are combined with a logical 'AND'.
"""
input coin_balances_bool_exp {
  _and: [coin_balances_bool_exp!]
  _not: coin_balances_bool_exp
  _or: [coin_balances_bool_exp!]
  amount: numeric_comparison_exp
  coin_type: String_comparison_exp
  coin_type_hash: String_comparison_exp
  inserted_at: timestamp_comparison_exp
  owner_address: String_comparison_exp
  transaction_timestamp: timestamp_comparison_exp
  transaction_version: bigint_comparison_exp
}

"""
input type for incrementing numeric columns in table "legacy_migration_v1.coin_balances"
"""
input coin_balances_inc_input {
  amount: numeric
  transaction_version: bigint
}

"""
input type for inserting data into table "legacy_migration_v1.coin_balances"
"""
input coin_balances_insert_input {
  amount: numeric
  coin_type: String
  coin_type_hash: String
  inserted_at: timestamp
  owner_address: String
  transaction_timestamp: timestamp
  transaction_version: bigint
}

"""aggregate max on columns"""
type coin_balances_max_fields {
  amount: numeric
  coin_type: String
  coin_type_hash: String
  inserted_at: timestamp
  owner_address: String
  transaction_timestamp: timestamp
  transaction_version: bigint
}

"""aggregate min on columns"""
type coin_balances_min_fields {
  amount: numeric
  coin_type: String
  coin_type_hash: String
  inserted_at: timestamp
  owner_address: String
  transaction_timestamp: timestamp
  transaction_version: bigint
}

"""
response of any mutation on the table "legacy_migration_v1.coin_balances"
"""
type coin_balances_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [coin_balances!]!
}

"""
Ordering options when selecting data from "legacy_migration_v1.coin_balances".
"""
input coin_balances_order_by {
  amount: order_by
  coin_type: order_by
  coin_type_hash: order_by
  inserted_at: order_by
  owner_address: order_by
  transaction_timestamp: order_by
  transaction_version: order_by
}

"""
select columns of table "legacy_migration_v1.coin_balances"
"""
enum coin_balances_select_column {
  """column name"""
  amount

  """column name"""
  coin_type

  """column name"""
  coin_type_hash

  """column name"""
  inserted_at

  """column name"""
  owner_address

  """column name"""
  transaction_timestamp

  """column name"""
  transaction_version
}

"""
input type for updating data in table "legacy_migration_v1.coin_balances"
"""
input coin_balances_set_input {
  amount: numeric
  coin_type: String
  coin_type_hash: String
  inserted_at: timestamp
  owner_address: String
  transaction_timestamp: timestamp
  transaction_version: bigint
}

"""aggregate stddev on columns"""
type coin_balances_stddev_fields {
  amount: Float
  transaction_version: Float
}

"""aggregate stddev_pop on columns"""
type coin_balances_stddev_pop_fields {
  amount: Float
  transaction_version: Float
}

"""aggregate stddev_samp on columns"""
type coin_balances_stddev_samp_fields {
  amount: Float
  transaction_version: Float
}

"""
Streaming cursor of the table "coin_balances"
"""
input coin_balances_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: coin_balances_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input coin_balances_stream_cursor_value_input {
  amount: numeric
  coin_type: String
  coin_type_hash: String
  inserted_at: timestamp
  owner_address: String
  transaction_timestamp: timestamp
  transaction_version: bigint
}

"""aggregate sum on columns"""
type coin_balances_sum_fields {
  amount: numeric
  transaction_version: bigint
}

input coin_balances_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: coin_balances_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: coin_balances_set_input

  """filter the rows which have to be updated"""
  where: coin_balances_bool_exp!
}

"""aggregate var_pop on columns"""
type coin_balances_var_pop_fields {
  amount: Float
  transaction_version: Float
}

"""aggregate var_samp on columns"""
type coin_balances_var_samp_fields {
  amount: Float
  transaction_version: Float
}

"""aggregate variance on columns"""
type coin_balances_variance_fields {
  amount: Float
  transaction_version: Float
}

"""
columns and relationships of "legacy_migration_v1.coin_infos"
"""
type coin_infos {
  coin_type: String
  coin_type_hash: String
  creator_address: String
  decimals: Int
  inserted_at: timestamp
  name: String
  supply_aggregator_table_handle: String
  supply_aggregator_table_key: String
  symbol: String
  transaction_created_timestamp: timestamp
  transaction_version_created: bigint
}

"""
aggregated selection of "legacy_migration_v1.coin_infos"
"""
type coin_infos_aggregate {
  aggregate: coin_infos_aggregate_fields
  nodes: [coin_infos!]!
}

"""
aggregate fields of "legacy_migration_v1.coin_infos"
"""
type coin_infos_aggregate_fields {
  avg: coin_infos_avg_fields
  count(columns: [coin_infos_select_column!], distinct: Boolean): Int!
  max: coin_infos_max_fields
  min: coin_infos_min_fields
  stddev: coin_infos_stddev_fields
  stddev_pop: coin_infos_stddev_pop_fields
  stddev_samp: coin_infos_stddev_samp_fields
  sum: coin_infos_sum_fields
  var_pop: coin_infos_var_pop_fields
  var_samp: coin_infos_var_samp_fields
  variance: coin_infos_variance_fields
}

"""aggregate avg on columns"""
type coin_infos_avg_fields {
  decimals: Float
  transaction_version_created: Float
}

"""
Boolean expression to filter rows from the table "legacy_migration_v1.coin_infos". All fields are combined with a logical 'AND'.
"""
input coin_infos_bool_exp {
  _and: [coin_infos_bool_exp!]
  _not: coin_infos_bool_exp
  _or: [coin_infos_bool_exp!]
  coin_type: String_comparison_exp
  coin_type_hash: String_comparison_exp
  creator_address: String_comparison_exp
  decimals: Int_comparison_exp
  inserted_at: timestamp_comparison_exp
  name: String_comparison_exp
  supply_aggregator_table_handle: String_comparison_exp
  supply_aggregator_table_key: String_comparison_exp
  symbol: String_comparison_exp
  transaction_created_timestamp: timestamp_comparison_exp
  transaction_version_created: bigint_comparison_exp
}

"""
input type for incrementing numeric columns in table "legacy_migration_v1.coin_infos"
"""
input coin_infos_inc_input {
  decimals: Int
  transaction_version_created: bigint
}

"""
input type for inserting data into table "legacy_migration_v1.coin_infos"
"""
input coin_infos_insert_input {
  coin_type: String
  coin_type_hash: String
  creator_address: String
  decimals: Int
  inserted_at: timestamp
  name: String
  supply_aggregator_table_handle: String
  supply_aggregator_table_key: String
  symbol: String
  transaction_created_timestamp: timestamp
  transaction_version_created: bigint
}

"""aggregate max on columns"""
type coin_infos_max_fields {
  coin_type: String
  coin_type_hash: String
  creator_address: String
  decimals: Int
  inserted_at: timestamp
  name: String
  supply_aggregator_table_handle: String
  supply_aggregator_table_key: String
  symbol: String
  transaction_created_timestamp: timestamp
  transaction_version_created: bigint
}

"""aggregate min on columns"""
type coin_infos_min_fields {
  coin_type: String
  coin_type_hash: String
  creator_address: String
  decimals: Int
  inserted_at: timestamp
  name: String
  supply_aggregator_table_handle: String
  supply_aggregator_table_key: String
  symbol: String
  transaction_created_timestamp: timestamp
  transaction_version_created: bigint
}

"""
response of any mutation on the table "legacy_migration_v1.coin_infos"
"""
type coin_infos_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [coin_infos!]!
}

"""
input type for inserting object relation for remote table "legacy_migration_v1.coin_infos"
"""
input coin_infos_obj_rel_insert_input {
  data: coin_infos_insert_input!
}

"""
Ordering options when selecting data from "legacy_migration_v1.coin_infos".
"""
input coin_infos_order_by {
  coin_type: order_by
  coin_type_hash: order_by
  creator_address: order_by
  decimals: order_by
  inserted_at: order_by
  name: order_by
  supply_aggregator_table_handle: order_by
  supply_aggregator_table_key: order_by
  symbol: order_by
  transaction_created_timestamp: order_by
  transaction_version_created: order_by
}

"""
select columns of table "legacy_migration_v1.coin_infos"
"""
enum coin_infos_select_column {
  """column name"""
  coin_type

  """column name"""
  coin_type_hash

  """column name"""
  creator_address

  """column name"""
  decimals

  """column name"""
  inserted_at

  """column name"""
  name

  """column name"""
  supply_aggregator_table_handle

  """column name"""
  supply_aggregator_table_key

  """column name"""
  symbol

  """column name"""
  transaction_created_timestamp

  """column name"""
  transaction_version_created
}

"""
input type for updating data in table "legacy_migration_v1.coin_infos"
"""
input coin_infos_set_input {
  coin_type: String
  coin_type_hash: String
  creator_address: String
  decimals: Int
  inserted_at: timestamp
  name: String
  supply_aggregator_table_handle: String
  supply_aggregator_table_key: String
  symbol: String
  transaction_created_timestamp: timestamp
  transaction_version_created: bigint
}

"""aggregate stddev on columns"""
type coin_infos_stddev_fields {
  decimals: Float
  transaction_version_created: Float
}

"""aggregate stddev_pop on columns"""
type coin_infos_stddev_pop_fields {
  decimals: Float
  transaction_version_created: Float
}

"""aggregate stddev_samp on columns"""
type coin_infos_stddev_samp_fields {
  decimals: Float
  transaction_version_created: Float
}

"""
Streaming cursor of the table "coin_infos"
"""
input coin_infos_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: coin_infos_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input coin_infos_stream_cursor_value_input {
  coin_type: String
  coin_type_hash: String
  creator_address: String
  decimals: Int
  inserted_at: timestamp
  name: String
  supply_aggregator_table_handle: String
  supply_aggregator_table_key: String
  symbol: String
  transaction_created_timestamp: timestamp
  transaction_version_created: bigint
}

"""aggregate sum on columns"""
type coin_infos_sum_fields {
  decimals: Int
  transaction_version_created: bigint
}

input coin_infos_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: coin_infos_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: coin_infos_set_input

  """filter the rows which have to be updated"""
  where: coin_infos_bool_exp!
}

"""aggregate var_pop on columns"""
type coin_infos_var_pop_fields {
  decimals: Float
  transaction_version_created: Float
}

"""aggregate var_samp on columns"""
type coin_infos_var_samp_fields {
  decimals: Float
  transaction_version_created: Float
}

"""aggregate variance on columns"""
type coin_infos_variance_fields {
  decimals: Float
  transaction_version_created: Float
}

"""
columns and relationships of "coin_supply"
"""
type coin_supply {
  coin_type: String!
  coin_type_hash: String!
  inserted_at: timestamp!
  supply: numeric!
  transaction_epoch: bigint!
  transaction_timestamp: timestamp!
  transaction_version: bigint!
}

"""
aggregated selection of "coin_supply"
"""
type coin_supply_aggregate {
  aggregate: coin_supply_aggregate_fields
  nodes: [coin_supply!]!
}

"""
aggregate fields of "coin_supply"
"""
type coin_supply_aggregate_fields {
  avg: coin_supply_avg_fields
  count(columns: [coin_supply_select_column!], distinct: Boolean): Int!
  max: coin_supply_max_fields
  min: coin_supply_min_fields
  stddev: coin_supply_stddev_fields
  stddev_pop: coin_supply_stddev_pop_fields
  stddev_samp: coin_supply_stddev_samp_fields
  sum: coin_supply_sum_fields
  var_pop: coin_supply_var_pop_fields
  var_samp: coin_supply_var_samp_fields
  variance: coin_supply_variance_fields
}

"""aggregate avg on columns"""
type coin_supply_avg_fields {
  supply: Float
  transaction_epoch: Float
  transaction_version: Float
}

"""
Boolean expression to filter rows from the table "coin_supply". All fields are combined with a logical 'AND'.
"""
input coin_supply_bool_exp {
  _and: [coin_supply_bool_exp!]
  _not: coin_supply_bool_exp
  _or: [coin_supply_bool_exp!]
  coin_type: String_comparison_exp
  coin_type_hash: String_comparison_exp
  inserted_at: timestamp_comparison_exp
  supply: numeric_comparison_exp
  transaction_epoch: bigint_comparison_exp
  transaction_timestamp: timestamp_comparison_exp
  transaction_version: bigint_comparison_exp
}

"""
unique or primary key constraints on table "coin_supply"
"""
enum coin_supply_constraint {
  """
  unique or primary key constraint on columns "transaction_version", "coin_type_hash"
  """
  coin_supply_pkey
}

"""
input type for incrementing numeric columns in table "coin_supply"
"""
input coin_supply_inc_input {
  supply: numeric
  transaction_epoch: bigint
  transaction_version: bigint
}

"""
input type for inserting data into table "coin_supply"
"""
input coin_supply_insert_input {
  coin_type: String
  coin_type_hash: String
  inserted_at: timestamp
  supply: numeric
  transaction_epoch: bigint
  transaction_timestamp: timestamp
  transaction_version: bigint
}

"""aggregate max on columns"""
type coin_supply_max_fields {
  coin_type: String
  coin_type_hash: String
  inserted_at: timestamp
  supply: numeric
  transaction_epoch: bigint
  transaction_timestamp: timestamp
  transaction_version: bigint
}

"""aggregate min on columns"""
type coin_supply_min_fields {
  coin_type: String
  coin_type_hash: String
  inserted_at: timestamp
  supply: numeric
  transaction_epoch: bigint
  transaction_timestamp: timestamp
  transaction_version: bigint
}

"""
response of any mutation on the table "coin_supply"
"""
type coin_supply_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [coin_supply!]!
}

"""
on_conflict condition type for table "coin_supply"
"""
input coin_supply_on_conflict {
  constraint: coin_supply_constraint!
  update_columns: [coin_supply_update_column!]! = []
  where: coin_supply_bool_exp
}

"""Ordering options when selecting data from "coin_supply"."""
input coin_supply_order_by {
  coin_type: order_by
  coin_type_hash: order_by
  inserted_at: order_by
  supply: order_by
  transaction_epoch: order_by
  transaction_timestamp: order_by
  transaction_version: order_by
}

"""primary key columns input for table: coin_supply"""
input coin_supply_pk_columns_input {
  coin_type_hash: String!
  transaction_version: bigint!
}

"""
select columns of table "coin_supply"
"""
enum coin_supply_select_column {
  """column name"""
  coin_type

  """column name"""
  coin_type_hash

  """column name"""
  inserted_at

  """column name"""
  supply

  """column name"""
  transaction_epoch

  """column name"""
  transaction_timestamp

  """column name"""
  transaction_version
}

"""
input type for updating data in table "coin_supply"
"""
input coin_supply_set_input {
  coin_type: String
  coin_type_hash: String
  inserted_at: timestamp
  supply: numeric
  transaction_epoch: bigint
  transaction_timestamp: timestamp
  transaction_version: bigint
}

"""aggregate stddev on columns"""
type coin_supply_stddev_fields {
  supply: Float
  transaction_epoch: Float
  transaction_version: Float
}

"""aggregate stddev_pop on columns"""
type coin_supply_stddev_pop_fields {
  supply: Float
  transaction_epoch: Float
  transaction_version: Float
}

"""aggregate stddev_samp on columns"""
type coin_supply_stddev_samp_fields {
  supply: Float
  transaction_epoch: Float
  transaction_version: Float
}

"""
Streaming cursor of the table "coin_supply"
"""
input coin_supply_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: coin_supply_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input coin_supply_stream_cursor_value_input {
  coin_type: String
  coin_type_hash: String
  inserted_at: timestamp
  supply: numeric
  transaction_epoch: bigint
  transaction_timestamp: timestamp
  transaction_version: bigint
}

"""aggregate sum on columns"""
type coin_supply_sum_fields {
  supply: numeric
  transaction_epoch: bigint
  transaction_version: bigint
}

"""
update columns of table "coin_supply"
"""
enum coin_supply_update_column {
  """column name"""
  coin_type

  """column name"""
  coin_type_hash

  """column name"""
  inserted_at

  """column name"""
  supply

  """column name"""
  transaction_epoch

  """column name"""
  transaction_timestamp

  """column name"""
  transaction_version
}

input coin_supply_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: coin_supply_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: coin_supply_set_input

  """filter the rows which have to be updated"""
  where: coin_supply_bool_exp!
}

"""aggregate var_pop on columns"""
type coin_supply_var_pop_fields {
  supply: Float
  transaction_epoch: Float
  transaction_version: Float
}

"""aggregate var_samp on columns"""
type coin_supply_var_samp_fields {
  supply: Float
  transaction_epoch: Float
  transaction_version: Float
}

"""aggregate variance on columns"""
type coin_supply_variance_fields {
  supply: Float
  transaction_epoch: Float
  transaction_version: Float
}

"""
columns and relationships of "legacy_migration_v1.collection_datas"
"""
type collection_datas {
  collection_data_id_hash: String
  collection_name: String
  creator_address: String
  description: String
  description_mutable: Boolean
  inserted_at: timestamp
  maximum: numeric
  maximum_mutable: Boolean
  metadata_uri: String
  supply: numeric
  table_handle: String
  transaction_timestamp: timestamp
  transaction_version: bigint
  uri_mutable: Boolean
}

"""
aggregated selection of "legacy_migration_v1.collection_datas"
"""
type collection_datas_aggregate {
  aggregate: collection_datas_aggregate_fields
  nodes: [collection_datas!]!
}

"""
aggregate fields of "legacy_migration_v1.collection_datas"
"""
type collection_datas_aggregate_fields {
  avg: collection_datas_avg_fields
  count(columns: [collection_datas_select_column!], distinct: Boolean): Int!
  max: collection_datas_max_fields
  min: collection_datas_min_fields
  stddev: collection_datas_stddev_fields
  stddev_pop: collection_datas_stddev_pop_fields
  stddev_samp: collection_datas_stddev_samp_fields
  sum: collection_datas_sum_fields
  var_pop: collection_datas_var_pop_fields
  var_samp: collection_datas_var_samp_fields
  variance: collection_datas_variance_fields
}

"""aggregate avg on columns"""
type collection_datas_avg_fields {
  maximum: Float
  supply: Float
  transaction_version: Float
}

"""
Boolean expression to filter rows from the table "legacy_migration_v1.collection_datas". All fields are combined with a logical 'AND'.
"""
input collection_datas_bool_exp {
  _and: [collection_datas_bool_exp!]
  _not: collection_datas_bool_exp
  _or: [collection_datas_bool_exp!]
  collection_data_id_hash: String_comparison_exp
  collection_name: String_comparison_exp
  creator_address: String_comparison_exp
  description: String_comparison_exp
  description_mutable: Boolean_comparison_exp
  inserted_at: timestamp_comparison_exp
  maximum: numeric_comparison_exp
  maximum_mutable: Boolean_comparison_exp
  metadata_uri: String_comparison_exp
  supply: numeric_comparison_exp
  table_handle: String_comparison_exp
  transaction_timestamp: timestamp_comparison_exp
  transaction_version: bigint_comparison_exp
  uri_mutable: Boolean_comparison_exp
}

"""
input type for incrementing numeric columns in table "legacy_migration_v1.collection_datas"
"""
input collection_datas_inc_input {
  maximum: numeric
  supply: numeric
  transaction_version: bigint
}

"""
input type for inserting data into table "legacy_migration_v1.collection_datas"
"""
input collection_datas_insert_input {
  collection_data_id_hash: String
  collection_name: String
  creator_address: String
  description: String
  description_mutable: Boolean
  inserted_at: timestamp
  maximum: numeric
  maximum_mutable: Boolean
  metadata_uri: String
  supply: numeric
  table_handle: String
  transaction_timestamp: timestamp
  transaction_version: bigint
  uri_mutable: Boolean
}

"""aggregate max on columns"""
type collection_datas_max_fields {
  collection_data_id_hash: String
  collection_name: String
  creator_address: String
  description: String
  inserted_at: timestamp
  maximum: numeric
  metadata_uri: String
  supply: numeric
  table_handle: String
  transaction_timestamp: timestamp
  transaction_version: bigint
}

"""aggregate min on columns"""
type collection_datas_min_fields {
  collection_data_id_hash: String
  collection_name: String
  creator_address: String
  description: String
  inserted_at: timestamp
  maximum: numeric
  metadata_uri: String
  supply: numeric
  table_handle: String
  transaction_timestamp: timestamp
  transaction_version: bigint
}

"""
response of any mutation on the table "legacy_migration_v1.collection_datas"
"""
type collection_datas_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [collection_datas!]!
}

"""
Ordering options when selecting data from "legacy_migration_v1.collection_datas".
"""
input collection_datas_order_by {
  collection_data_id_hash: order_by
  collection_name: order_by
  creator_address: order_by
  description: order_by
  description_mutable: order_by
  inserted_at: order_by
  maximum: order_by
  maximum_mutable: order_by
  metadata_uri: order_by
  supply: order_by
  table_handle: order_by
  transaction_timestamp: order_by
  transaction_version: order_by
  uri_mutable: order_by
}

"""
select columns of table "legacy_migration_v1.collection_datas"
"""
enum collection_datas_select_column {
  """column name"""
  collection_data_id_hash

  """column name"""
  collection_name

  """column name"""
  creator_address

  """column name"""
  description

  """column name"""
  description_mutable

  """column name"""
  inserted_at

  """column name"""
  maximum

  """column name"""
  maximum_mutable

  """column name"""
  metadata_uri

  """column name"""
  supply

  """column name"""
  table_handle

  """column name"""
  transaction_timestamp

  """column name"""
  transaction_version

  """column name"""
  uri_mutable
}

"""
input type for updating data in table "legacy_migration_v1.collection_datas"
"""
input collection_datas_set_input {
  collection_data_id_hash: String
  collection_name: String
  creator_address: String
  description: String
  description_mutable: Boolean
  inserted_at: timestamp
  maximum: numeric
  maximum_mutable: Boolean
  metadata_uri: String
  supply: numeric
  table_handle: String
  transaction_timestamp: timestamp
  transaction_version: bigint
  uri_mutable: Boolean
}

"""aggregate stddev on columns"""
type collection_datas_stddev_fields {
  maximum: Float
  supply: Float
  transaction_version: Float
}

"""aggregate stddev_pop on columns"""
type collection_datas_stddev_pop_fields {
  maximum: Float
  supply: Float
  transaction_version: Float
}

"""aggregate stddev_samp on columns"""
type collection_datas_stddev_samp_fields {
  maximum: Float
  supply: Float
  transaction_version: Float
}

"""
Streaming cursor of the table "collection_datas"
"""
input collection_datas_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: collection_datas_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input collection_datas_stream_cursor_value_input {
  collection_data_id_hash: String
  collection_name: String
  creator_address: String
  description: String
  description_mutable: Boolean
  inserted_at: timestamp
  maximum: numeric
  maximum_mutable: Boolean
  metadata_uri: String
  supply: numeric
  table_handle: String
  transaction_timestamp: timestamp
  transaction_version: bigint
  uri_mutable: Boolean
}

"""aggregate sum on columns"""
type collection_datas_sum_fields {
  maximum: numeric
  supply: numeric
  transaction_version: bigint
}

input collection_datas_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: collection_datas_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: collection_datas_set_input

  """filter the rows which have to be updated"""
  where: collection_datas_bool_exp!
}

"""aggregate var_pop on columns"""
type collection_datas_var_pop_fields {
  maximum: Float
  supply: Float
  transaction_version: Float
}

"""aggregate var_samp on columns"""
type collection_datas_var_samp_fields {
  maximum: Float
  supply: Float
  transaction_version: Float
}

"""aggregate variance on columns"""
type collection_datas_variance_fields {
  maximum: Float
  supply: Float
  transaction_version: Float
}

"""
columns and relationships of "legacy_migration_v1.current_ans_lookup"
"""
type current_ans_lookup {
  """An array relationship"""
  all_token_ownerships(
    """distinct select on columns"""
    distinct_on: [current_token_ownerships_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_token_ownerships_order_by!]

    """filter the rows returned"""
    where: current_token_ownerships_bool_exp
  ): [current_token_ownerships!]!

  """An aggregate relationship"""
  all_token_ownerships_aggregate(
    """distinct select on columns"""
    distinct_on: [current_token_ownerships_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_token_ownerships_order_by!]

    """filter the rows returned"""
    where: current_token_ownerships_bool_exp
  ): current_token_ownerships_aggregate!
  domain: String
  expiration_timestamp: timestamp
  inserted_at: timestamp
  is_deleted: Boolean
  last_transaction_version: bigint
  registered_address: String
  subdomain: String
  token_name: String
}

"""
aggregated selection of "legacy_migration_v1.current_ans_lookup"
"""
type current_ans_lookup_aggregate {
  aggregate: current_ans_lookup_aggregate_fields
  nodes: [current_ans_lookup!]!
}

"""
aggregate fields of "legacy_migration_v1.current_ans_lookup"
"""
type current_ans_lookup_aggregate_fields {
  avg: current_ans_lookup_avg_fields
  count(columns: [current_ans_lookup_select_column!], distinct: Boolean): Int!
  max: current_ans_lookup_max_fields
  min: current_ans_lookup_min_fields
  stddev: current_ans_lookup_stddev_fields
  stddev_pop: current_ans_lookup_stddev_pop_fields
  stddev_samp: current_ans_lookup_stddev_samp_fields
  sum: current_ans_lookup_sum_fields
  var_pop: current_ans_lookup_var_pop_fields
  var_samp: current_ans_lookup_var_samp_fields
  variance: current_ans_lookup_variance_fields
}

"""aggregate avg on columns"""
type current_ans_lookup_avg_fields {
  last_transaction_version: Float
}

"""
Boolean expression to filter rows from the table "legacy_migration_v1.current_ans_lookup". All fields are combined with a logical 'AND'.
"""
input current_ans_lookup_bool_exp {
  _and: [current_ans_lookup_bool_exp!]
  _not: current_ans_lookup_bool_exp
  _or: [current_ans_lookup_bool_exp!]
  all_token_ownerships: current_token_ownerships_bool_exp
  all_token_ownerships_aggregate: current_token_ownerships_aggregate_bool_exp
  domain: String_comparison_exp
  expiration_timestamp: timestamp_comparison_exp
  inserted_at: timestamp_comparison_exp
  is_deleted: Boolean_comparison_exp
  last_transaction_version: bigint_comparison_exp
  registered_address: String_comparison_exp
  subdomain: String_comparison_exp
  token_name: String_comparison_exp
}

"""
input type for incrementing numeric columns in table "legacy_migration_v1.current_ans_lookup"
"""
input current_ans_lookup_inc_input {
  last_transaction_version: bigint
}

"""
input type for inserting data into table "legacy_migration_v1.current_ans_lookup"
"""
input current_ans_lookup_insert_input {
  all_token_ownerships: current_token_ownerships_arr_rel_insert_input
  domain: String
  expiration_timestamp: timestamp
  inserted_at: timestamp
  is_deleted: Boolean
  last_transaction_version: bigint
  registered_address: String
  subdomain: String
  token_name: String
}

"""aggregate max on columns"""
type current_ans_lookup_max_fields {
  domain: String
  expiration_timestamp: timestamp
  inserted_at: timestamp
  last_transaction_version: bigint
  registered_address: String
  subdomain: String
  token_name: String
}

"""aggregate min on columns"""
type current_ans_lookup_min_fields {
  domain: String
  expiration_timestamp: timestamp
  inserted_at: timestamp
  last_transaction_version: bigint
  registered_address: String
  subdomain: String
  token_name: String
}

"""
response of any mutation on the table "legacy_migration_v1.current_ans_lookup"
"""
type current_ans_lookup_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [current_ans_lookup!]!
}

"""
Ordering options when selecting data from "legacy_migration_v1.current_ans_lookup".
"""
input current_ans_lookup_order_by {
  all_token_ownerships_aggregate: current_token_ownerships_aggregate_order_by
  domain: order_by
  expiration_timestamp: order_by
  inserted_at: order_by
  is_deleted: order_by
  last_transaction_version: order_by
  registered_address: order_by
  subdomain: order_by
  token_name: order_by
}

"""
select columns of table "legacy_migration_v1.current_ans_lookup"
"""
enum current_ans_lookup_select_column {
  """column name"""
  domain

  """column name"""
  expiration_timestamp

  """column name"""
  inserted_at

  """column name"""
  is_deleted

  """column name"""
  last_transaction_version

  """column name"""
  registered_address

  """column name"""
  subdomain

  """column name"""
  token_name
}

"""
input type for updating data in table "legacy_migration_v1.current_ans_lookup"
"""
input current_ans_lookup_set_input {
  domain: String
  expiration_timestamp: timestamp
  inserted_at: timestamp
  is_deleted: Boolean
  last_transaction_version: bigint
  registered_address: String
  subdomain: String
  token_name: String
}

"""aggregate stddev on columns"""
type current_ans_lookup_stddev_fields {
  last_transaction_version: Float
}

"""aggregate stddev_pop on columns"""
type current_ans_lookup_stddev_pop_fields {
  last_transaction_version: Float
}

"""aggregate stddev_samp on columns"""
type current_ans_lookup_stddev_samp_fields {
  last_transaction_version: Float
}

"""
Streaming cursor of the table "current_ans_lookup"
"""
input current_ans_lookup_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: current_ans_lookup_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input current_ans_lookup_stream_cursor_value_input {
  domain: String
  expiration_timestamp: timestamp
  inserted_at: timestamp
  is_deleted: Boolean
  last_transaction_version: bigint
  registered_address: String
  subdomain: String
  token_name: String
}

"""aggregate sum on columns"""
type current_ans_lookup_sum_fields {
  last_transaction_version: bigint
}

input current_ans_lookup_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: current_ans_lookup_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: current_ans_lookup_set_input

  """filter the rows which have to be updated"""
  where: current_ans_lookup_bool_exp!
}

"""
columns and relationships of "current_ans_lookup_v2"
"""
type current_ans_lookup_v2 {
  domain: String!
  expiration_timestamp: timestamp!
  inserted_at: timestamp!
  is_deleted: Boolean!
  last_transaction_version: bigint!
  registered_address: String
  subdomain: String!
  subdomain_expiration_policy: bigint
  token_name: String
  token_standard: String!
}

"""
aggregated selection of "current_ans_lookup_v2"
"""
type current_ans_lookup_v2_aggregate {
  aggregate: current_ans_lookup_v2_aggregate_fields
  nodes: [current_ans_lookup_v2!]!
}

"""
aggregate fields of "current_ans_lookup_v2"
"""
type current_ans_lookup_v2_aggregate_fields {
  avg: current_ans_lookup_v2_avg_fields
  count(columns: [current_ans_lookup_v2_select_column!], distinct: Boolean): Int!
  max: current_ans_lookup_v2_max_fields
  min: current_ans_lookup_v2_min_fields
  stddev: current_ans_lookup_v2_stddev_fields
  stddev_pop: current_ans_lookup_v2_stddev_pop_fields
  stddev_samp: current_ans_lookup_v2_stddev_samp_fields
  sum: current_ans_lookup_v2_sum_fields
  var_pop: current_ans_lookup_v2_var_pop_fields
  var_samp: current_ans_lookup_v2_var_samp_fields
  variance: current_ans_lookup_v2_variance_fields
}

"""aggregate avg on columns"""
type current_ans_lookup_v2_avg_fields {
  last_transaction_version: Float
  subdomain_expiration_policy: Float
}

"""
Boolean expression to filter rows from the table "current_ans_lookup_v2". All fields are combined with a logical 'AND'.
"""
input current_ans_lookup_v2_bool_exp {
  _and: [current_ans_lookup_v2_bool_exp!]
  _not: current_ans_lookup_v2_bool_exp
  _or: [current_ans_lookup_v2_bool_exp!]
  domain: String_comparison_exp
  expiration_timestamp: timestamp_comparison_exp
  inserted_at: timestamp_comparison_exp
  is_deleted: Boolean_comparison_exp
  last_transaction_version: bigint_comparison_exp
  registered_address: String_comparison_exp
  subdomain: String_comparison_exp
  subdomain_expiration_policy: bigint_comparison_exp
  token_name: String_comparison_exp
  token_standard: String_comparison_exp
}

"""
unique or primary key constraints on table "current_ans_lookup_v2"
"""
enum current_ans_lookup_v2_constraint {
  """
  unique or primary key constraint on columns "token_standard", "subdomain", "domain"
  """
  current_ans_lookup_v2_pkey
}

"""
input type for incrementing numeric columns in table "current_ans_lookup_v2"
"""
input current_ans_lookup_v2_inc_input {
  last_transaction_version: bigint
  subdomain_expiration_policy: bigint
}

"""
input type for inserting data into table "current_ans_lookup_v2"
"""
input current_ans_lookup_v2_insert_input {
  domain: String
  expiration_timestamp: timestamp
  inserted_at: timestamp
  is_deleted: Boolean
  last_transaction_version: bigint
  registered_address: String
  subdomain: String
  subdomain_expiration_policy: bigint
  token_name: String
  token_standard: String
}

"""aggregate max on columns"""
type current_ans_lookup_v2_max_fields {
  domain: String
  expiration_timestamp: timestamp
  inserted_at: timestamp
  last_transaction_version: bigint
  registered_address: String
  subdomain: String
  subdomain_expiration_policy: bigint
  token_name: String
  token_standard: String
}

"""aggregate min on columns"""
type current_ans_lookup_v2_min_fields {
  domain: String
  expiration_timestamp: timestamp
  inserted_at: timestamp
  last_transaction_version: bigint
  registered_address: String
  subdomain: String
  subdomain_expiration_policy: bigint
  token_name: String
  token_standard: String
}

"""
response of any mutation on the table "current_ans_lookup_v2"
"""
type current_ans_lookup_v2_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [current_ans_lookup_v2!]!
}

"""
on_conflict condition type for table "current_ans_lookup_v2"
"""
input current_ans_lookup_v2_on_conflict {
  constraint: current_ans_lookup_v2_constraint!
  update_columns: [current_ans_lookup_v2_update_column!]! = []
  where: current_ans_lookup_v2_bool_exp
}

"""Ordering options when selecting data from "current_ans_lookup_v2"."""
input current_ans_lookup_v2_order_by {
  domain: order_by
  expiration_timestamp: order_by
  inserted_at: order_by
  is_deleted: order_by
  last_transaction_version: order_by
  registered_address: order_by
  subdomain: order_by
  subdomain_expiration_policy: order_by
  token_name: order_by
  token_standard: order_by
}

"""primary key columns input for table: current_ans_lookup_v2"""
input current_ans_lookup_v2_pk_columns_input {
  domain: String!
  subdomain: String!
  token_standard: String!
}

"""
select columns of table "current_ans_lookup_v2"
"""
enum current_ans_lookup_v2_select_column {
  """column name"""
  domain

  """column name"""
  expiration_timestamp

  """column name"""
  inserted_at

  """column name"""
  is_deleted

  """column name"""
  last_transaction_version

  """column name"""
  registered_address

  """column name"""
  subdomain

  """column name"""
  subdomain_expiration_policy

  """column name"""
  token_name

  """column name"""
  token_standard
}

"""
input type for updating data in table "current_ans_lookup_v2"
"""
input current_ans_lookup_v2_set_input {
  domain: String
  expiration_timestamp: timestamp
  inserted_at: timestamp
  is_deleted: Boolean
  last_transaction_version: bigint
  registered_address: String
  subdomain: String
  subdomain_expiration_policy: bigint
  token_name: String
  token_standard: String
}

"""aggregate stddev on columns"""
type current_ans_lookup_v2_stddev_fields {
  last_transaction_version: Float
  subdomain_expiration_policy: Float
}

"""aggregate stddev_pop on columns"""
type current_ans_lookup_v2_stddev_pop_fields {
  last_transaction_version: Float
  subdomain_expiration_policy: Float
}

"""aggregate stddev_samp on columns"""
type current_ans_lookup_v2_stddev_samp_fields {
  last_transaction_version: Float
  subdomain_expiration_policy: Float
}

"""
Streaming cursor of the table "current_ans_lookup_v2"
"""
input current_ans_lookup_v2_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: current_ans_lookup_v2_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input current_ans_lookup_v2_stream_cursor_value_input {
  domain: String
  expiration_timestamp: timestamp
  inserted_at: timestamp
  is_deleted: Boolean
  last_transaction_version: bigint
  registered_address: String
  subdomain: String
  subdomain_expiration_policy: bigint
  token_name: String
  token_standard: String
}

"""aggregate sum on columns"""
type current_ans_lookup_v2_sum_fields {
  last_transaction_version: bigint
  subdomain_expiration_policy: bigint
}

"""
update columns of table "current_ans_lookup_v2"
"""
enum current_ans_lookup_v2_update_column {
  """column name"""
  domain

  """column name"""
  expiration_timestamp

  """column name"""
  inserted_at

  """column name"""
  is_deleted

  """column name"""
  last_transaction_version

  """column name"""
  registered_address

  """column name"""
  subdomain

  """column name"""
  subdomain_expiration_policy

  """column name"""
  token_name

  """column name"""
  token_standard
}

input current_ans_lookup_v2_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: current_ans_lookup_v2_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: current_ans_lookup_v2_set_input

  """filter the rows which have to be updated"""
  where: current_ans_lookup_v2_bool_exp!
}

"""aggregate var_pop on columns"""
type current_ans_lookup_v2_var_pop_fields {
  last_transaction_version: Float
  subdomain_expiration_policy: Float
}

"""aggregate var_samp on columns"""
type current_ans_lookup_v2_var_samp_fields {
  last_transaction_version: Float
  subdomain_expiration_policy: Float
}

"""aggregate variance on columns"""
type current_ans_lookup_v2_variance_fields {
  last_transaction_version: Float
  subdomain_expiration_policy: Float
}

"""aggregate var_pop on columns"""
type current_ans_lookup_var_pop_fields {
  last_transaction_version: Float
}

"""aggregate var_samp on columns"""
type current_ans_lookup_var_samp_fields {
  last_transaction_version: Float
}

"""aggregate variance on columns"""
type current_ans_lookup_variance_fields {
  last_transaction_version: Float
}

"""
columns and relationships of "current_aptos_names"
"""
type current_aptos_names {
  domain: String
  domain_expiration_timestamp: timestamp
  domain_with_suffix: String
  expiration_timestamp: timestamp
  is_active: Boolean

  """An object relationship"""
  is_domain_owner: current_aptos_names
  is_primary: Boolean
  last_transaction_version: bigint
  owner_address: String
  registered_address: String
  subdomain: String
  subdomain_expiration_policy: bigint
  token_data_id: String
  token_name: String
  token_standard: String
}

"""
aggregated selection of "current_aptos_names"
"""
type current_aptos_names_aggregate {
  aggregate: current_aptos_names_aggregate_fields
  nodes: [current_aptos_names!]!
}

input current_aptos_names_aggregate_bool_exp {
  bool_and: current_aptos_names_aggregate_bool_exp_bool_and
  bool_or: current_aptos_names_aggregate_bool_exp_bool_or
  count: current_aptos_names_aggregate_bool_exp_count
}

input current_aptos_names_aggregate_bool_exp_bool_and {
  arguments: current_aptos_names_select_column_current_aptos_names_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: current_aptos_names_bool_exp
  predicate: Boolean_comparison_exp!
}

input current_aptos_names_aggregate_bool_exp_bool_or {
  arguments: current_aptos_names_select_column_current_aptos_names_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: current_aptos_names_bool_exp
  predicate: Boolean_comparison_exp!
}

input current_aptos_names_aggregate_bool_exp_count {
  arguments: [current_aptos_names_select_column!]
  distinct: Boolean
  filter: current_aptos_names_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "current_aptos_names"
"""
type current_aptos_names_aggregate_fields {
  avg: current_aptos_names_avg_fields
  count(columns: [current_aptos_names_select_column!], distinct: Boolean): Int!
  max: current_aptos_names_max_fields
  min: current_aptos_names_min_fields
  stddev: current_aptos_names_stddev_fields
  stddev_pop: current_aptos_names_stddev_pop_fields
  stddev_samp: current_aptos_names_stddev_samp_fields
  sum: current_aptos_names_sum_fields
  var_pop: current_aptos_names_var_pop_fields
  var_samp: current_aptos_names_var_samp_fields
  variance: current_aptos_names_variance_fields
}

"""
order by aggregate values of table "current_aptos_names"
"""
input current_aptos_names_aggregate_order_by {
  avg: current_aptos_names_avg_order_by
  count: order_by
  max: current_aptos_names_max_order_by
  min: current_aptos_names_min_order_by
  stddev: current_aptos_names_stddev_order_by
  stddev_pop: current_aptos_names_stddev_pop_order_by
  stddev_samp: current_aptos_names_stddev_samp_order_by
  sum: current_aptos_names_sum_order_by
  var_pop: current_aptos_names_var_pop_order_by
  var_samp: current_aptos_names_var_samp_order_by
  variance: current_aptos_names_variance_order_by
}

"""
input type for inserting array relation for remote table "current_aptos_names"
"""
input current_aptos_names_arr_rel_insert_input {
  data: [current_aptos_names_insert_input!]!
}

"""aggregate avg on columns"""
type current_aptos_names_avg_fields {
  last_transaction_version: Float
  subdomain_expiration_policy: Float
}

"""
order by avg() on columns of table "current_aptos_names"
"""
input current_aptos_names_avg_order_by {
  last_transaction_version: order_by
  subdomain_expiration_policy: order_by
}

"""
Boolean expression to filter rows from the table "current_aptos_names". All fields are combined with a logical 'AND'.
"""
input current_aptos_names_bool_exp {
  _and: [current_aptos_names_bool_exp!]
  _not: current_aptos_names_bool_exp
  _or: [current_aptos_names_bool_exp!]
  domain: String_comparison_exp
  domain_expiration_timestamp: timestamp_comparison_exp
  domain_with_suffix: String_comparison_exp
  expiration_timestamp: timestamp_comparison_exp
  is_active: Boolean_comparison_exp
  is_domain_owner: current_aptos_names_bool_exp
  is_primary: Boolean_comparison_exp
  last_transaction_version: bigint_comparison_exp
  owner_address: String_comparison_exp
  registered_address: String_comparison_exp
  subdomain: String_comparison_exp
  subdomain_expiration_policy: bigint_comparison_exp
  token_data_id: String_comparison_exp
  token_name: String_comparison_exp
  token_standard: String_comparison_exp
}

"""
input type for inserting data into table "current_aptos_names"
"""
input current_aptos_names_insert_input {
  domain: String
  domain_expiration_timestamp: timestamp
  domain_with_suffix: String
  expiration_timestamp: timestamp
  is_active: Boolean
  is_domain_owner: current_aptos_names_obj_rel_insert_input
  is_primary: Boolean
  last_transaction_version: bigint
  owner_address: String
  registered_address: String
  subdomain: String
  subdomain_expiration_policy: bigint
  token_data_id: String
  token_name: String
  token_standard: String
}

"""aggregate max on columns"""
type current_aptos_names_max_fields {
  domain: String
  domain_expiration_timestamp: timestamp
  domain_with_suffix: String
  expiration_timestamp: timestamp
  last_transaction_version: bigint
  owner_address: String
  registered_address: String
  subdomain: String
  subdomain_expiration_policy: bigint
  token_data_id: String
  token_name: String
  token_standard: String
}

"""
order by max() on columns of table "current_aptos_names"
"""
input current_aptos_names_max_order_by {
  domain: order_by
  domain_expiration_timestamp: order_by
  domain_with_suffix: order_by
  expiration_timestamp: order_by
  last_transaction_version: order_by
  owner_address: order_by
  registered_address: order_by
  subdomain: order_by
  subdomain_expiration_policy: order_by
  token_data_id: order_by
  token_name: order_by
  token_standard: order_by
}

"""aggregate min on columns"""
type current_aptos_names_min_fields {
  domain: String
  domain_expiration_timestamp: timestamp
  domain_with_suffix: String
  expiration_timestamp: timestamp
  last_transaction_version: bigint
  owner_address: String
  registered_address: String
  subdomain: String
  subdomain_expiration_policy: bigint
  token_data_id: String
  token_name: String
  token_standard: String
}

"""
order by min() on columns of table "current_aptos_names"
"""
input current_aptos_names_min_order_by {
  domain: order_by
  domain_expiration_timestamp: order_by
  domain_with_suffix: order_by
  expiration_timestamp: order_by
  last_transaction_version: order_by
  owner_address: order_by
  registered_address: order_by
  subdomain: order_by
  subdomain_expiration_policy: order_by
  token_data_id: order_by
  token_name: order_by
  token_standard: order_by
}

"""
input type for inserting object relation for remote table "current_aptos_names"
"""
input current_aptos_names_obj_rel_insert_input {
  data: current_aptos_names_insert_input!
}

"""Ordering options when selecting data from "current_aptos_names"."""
input current_aptos_names_order_by {
  domain: order_by
  domain_expiration_timestamp: order_by
  domain_with_suffix: order_by
  expiration_timestamp: order_by
  is_active: order_by
  is_domain_owner: current_aptos_names_order_by
  is_primary: order_by
  last_transaction_version: order_by
  owner_address: order_by
  registered_address: order_by
  subdomain: order_by
  subdomain_expiration_policy: order_by
  token_data_id: order_by
  token_name: order_by
  token_standard: order_by
}

"""
select columns of table "current_aptos_names"
"""
enum current_aptos_names_select_column {
  """column name"""
  domain

  """column name"""
  domain_expiration_timestamp

  """column name"""
  domain_with_suffix

  """column name"""
  expiration_timestamp

  """column name"""
  is_active

  """column name"""
  is_primary

  """column name"""
  last_transaction_version

  """column name"""
  owner_address

  """column name"""
  registered_address

  """column name"""
  subdomain

  """column name"""
  subdomain_expiration_policy

  """column name"""
  token_data_id

  """column name"""
  token_name

  """column name"""
  token_standard
}

"""
select "current_aptos_names_aggregate_bool_exp_bool_and_arguments_columns" columns of table "current_aptos_names"
"""
enum current_aptos_names_select_column_current_aptos_names_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  is_active

  """column name"""
  is_primary
}

"""
select "current_aptos_names_aggregate_bool_exp_bool_or_arguments_columns" columns of table "current_aptos_names"
"""
enum current_aptos_names_select_column_current_aptos_names_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  is_active

  """column name"""
  is_primary
}

"""aggregate stddev on columns"""
type current_aptos_names_stddev_fields {
  last_transaction_version: Float
  subdomain_expiration_policy: Float
}

"""
order by stddev() on columns of table "current_aptos_names"
"""
input current_aptos_names_stddev_order_by {
  last_transaction_version: order_by
  subdomain_expiration_policy: order_by
}

"""aggregate stddev_pop on columns"""
type current_aptos_names_stddev_pop_fields {
  last_transaction_version: Float
  subdomain_expiration_policy: Float
}

"""
order by stddev_pop() on columns of table "current_aptos_names"
"""
input current_aptos_names_stddev_pop_order_by {
  last_transaction_version: order_by
  subdomain_expiration_policy: order_by
}

"""aggregate stddev_samp on columns"""
type current_aptos_names_stddev_samp_fields {
  last_transaction_version: Float
  subdomain_expiration_policy: Float
}

"""
order by stddev_samp() on columns of table "current_aptos_names"
"""
input current_aptos_names_stddev_samp_order_by {
  last_transaction_version: order_by
  subdomain_expiration_policy: order_by
}

"""
Streaming cursor of the table "current_aptos_names"
"""
input current_aptos_names_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: current_aptos_names_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input current_aptos_names_stream_cursor_value_input {
  domain: String
  domain_expiration_timestamp: timestamp
  domain_with_suffix: String
  expiration_timestamp: timestamp
  is_active: Boolean
  is_primary: Boolean
  last_transaction_version: bigint
  owner_address: String
  registered_address: String
  subdomain: String
  subdomain_expiration_policy: bigint
  token_data_id: String
  token_name: String
  token_standard: String
}

"""aggregate sum on columns"""
type current_aptos_names_sum_fields {
  last_transaction_version: bigint
  subdomain_expiration_policy: bigint
}

"""
order by sum() on columns of table "current_aptos_names"
"""
input current_aptos_names_sum_order_by {
  last_transaction_version: order_by
  subdomain_expiration_policy: order_by
}

"""aggregate var_pop on columns"""
type current_aptos_names_var_pop_fields {
  last_transaction_version: Float
  subdomain_expiration_policy: Float
}

"""
order by var_pop() on columns of table "current_aptos_names"
"""
input current_aptos_names_var_pop_order_by {
  last_transaction_version: order_by
  subdomain_expiration_policy: order_by
}

"""aggregate var_samp on columns"""
type current_aptos_names_var_samp_fields {
  last_transaction_version: Float
  subdomain_expiration_policy: Float
}

"""
order by var_samp() on columns of table "current_aptos_names"
"""
input current_aptos_names_var_samp_order_by {
  last_transaction_version: order_by
  subdomain_expiration_policy: order_by
}

"""aggregate variance on columns"""
type current_aptos_names_variance_fields {
  last_transaction_version: Float
  subdomain_expiration_policy: Float
}

"""
order by variance() on columns of table "current_aptos_names"
"""
input current_aptos_names_variance_order_by {
  last_transaction_version: order_by
  subdomain_expiration_policy: order_by
}

"""
columns and relationships of "legacy_migration_v1.current_coin_balances"
"""
type current_coin_balances {
  amount: numeric

  """An object relationship"""
  coin_info: coin_infos
  coin_type: String
  coin_type_hash: String
  inserted_at: timestamp
  last_transaction_timestamp: timestamp
  last_transaction_version: bigint
  owner_address: String
}

"""
aggregated selection of "legacy_migration_v1.current_coin_balances"
"""
type current_coin_balances_aggregate {
  aggregate: current_coin_balances_aggregate_fields
  nodes: [current_coin_balances!]!
}

"""
aggregate fields of "legacy_migration_v1.current_coin_balances"
"""
type current_coin_balances_aggregate_fields {
  avg: current_coin_balances_avg_fields
  count(columns: [current_coin_balances_select_column!], distinct: Boolean): Int!
  max: current_coin_balances_max_fields
  min: current_coin_balances_min_fields
  stddev: current_coin_balances_stddev_fields
  stddev_pop: current_coin_balances_stddev_pop_fields
  stddev_samp: current_coin_balances_stddev_samp_fields
  sum: current_coin_balances_sum_fields
  var_pop: current_coin_balances_var_pop_fields
  var_samp: current_coin_balances_var_samp_fields
  variance: current_coin_balances_variance_fields
}

"""aggregate avg on columns"""
type current_coin_balances_avg_fields {
  amount: Float
  last_transaction_version: Float
}

"""
Boolean expression to filter rows from the table "legacy_migration_v1.current_coin_balances". All fields are combined with a logical 'AND'.
"""
input current_coin_balances_bool_exp {
  _and: [current_coin_balances_bool_exp!]
  _not: current_coin_balances_bool_exp
  _or: [current_coin_balances_bool_exp!]
  amount: numeric_comparison_exp
  coin_info: coin_infos_bool_exp
  coin_type: String_comparison_exp
  coin_type_hash: String_comparison_exp
  inserted_at: timestamp_comparison_exp
  last_transaction_timestamp: timestamp_comparison_exp
  last_transaction_version: bigint_comparison_exp
  owner_address: String_comparison_exp
}

"""
input type for incrementing numeric columns in table "legacy_migration_v1.current_coin_balances"
"""
input current_coin_balances_inc_input {
  amount: numeric
  last_transaction_version: bigint
}

"""
input type for inserting data into table "legacy_migration_v1.current_coin_balances"
"""
input current_coin_balances_insert_input {
  amount: numeric
  coin_info: coin_infos_obj_rel_insert_input
  coin_type: String
  coin_type_hash: String
  inserted_at: timestamp
  last_transaction_timestamp: timestamp
  last_transaction_version: bigint
  owner_address: String
}

"""aggregate max on columns"""
type current_coin_balances_max_fields {
  amount: numeric
  coin_type: String
  coin_type_hash: String
  inserted_at: timestamp
  last_transaction_timestamp: timestamp
  last_transaction_version: bigint
  owner_address: String
}

"""aggregate min on columns"""
type current_coin_balances_min_fields {
  amount: numeric
  coin_type: String
  coin_type_hash: String
  inserted_at: timestamp
  last_transaction_timestamp: timestamp
  last_transaction_version: bigint
  owner_address: String
}

"""
response of any mutation on the table "legacy_migration_v1.current_coin_balances"
"""
type current_coin_balances_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [current_coin_balances!]!
}

"""
Ordering options when selecting data from "legacy_migration_v1.current_coin_balances".
"""
input current_coin_balances_order_by {
  amount: order_by
  coin_info: coin_infos_order_by
  coin_type: order_by
  coin_type_hash: order_by
  inserted_at: order_by
  last_transaction_timestamp: order_by
  last_transaction_version: order_by
  owner_address: order_by
}

"""
select columns of table "legacy_migration_v1.current_coin_balances"
"""
enum current_coin_balances_select_column {
  """column name"""
  amount

  """column name"""
  coin_type

  """column name"""
  coin_type_hash

  """column name"""
  inserted_at

  """column name"""
  last_transaction_timestamp

  """column name"""
  last_transaction_version

  """column name"""
  owner_address
}

"""
input type for updating data in table "legacy_migration_v1.current_coin_balances"
"""
input current_coin_balances_set_input {
  amount: numeric
  coin_type: String
  coin_type_hash: String
  inserted_at: timestamp
  last_transaction_timestamp: timestamp
  last_transaction_version: bigint
  owner_address: String
}

"""aggregate stddev on columns"""
type current_coin_balances_stddev_fields {
  amount: Float
  last_transaction_version: Float
}

"""aggregate stddev_pop on columns"""
type current_coin_balances_stddev_pop_fields {
  amount: Float
  last_transaction_version: Float
}

"""aggregate stddev_samp on columns"""
type current_coin_balances_stddev_samp_fields {
  amount: Float
  last_transaction_version: Float
}

"""
Streaming cursor of the table "current_coin_balances"
"""
input current_coin_balances_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: current_coin_balances_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input current_coin_balances_stream_cursor_value_input {
  amount: numeric
  coin_type: String
  coin_type_hash: String
  inserted_at: timestamp
  last_transaction_timestamp: timestamp
  last_transaction_version: bigint
  owner_address: String
}

"""aggregate sum on columns"""
type current_coin_balances_sum_fields {
  amount: numeric
  last_transaction_version: bigint
}

input current_coin_balances_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: current_coin_balances_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: current_coin_balances_set_input

  """filter the rows which have to be updated"""
  where: current_coin_balances_bool_exp!
}

"""aggregate var_pop on columns"""
type current_coin_balances_var_pop_fields {
  amount: Float
  last_transaction_version: Float
}

"""aggregate var_samp on columns"""
type current_coin_balances_var_samp_fields {
  amount: Float
  last_transaction_version: Float
}

"""aggregate variance on columns"""
type current_coin_balances_variance_fields {
  amount: Float
  last_transaction_version: Float
}

"""
columns and relationships of "legacy_migration_v1.current_collection_datas"
"""
type current_collection_datas {
  collection_data_id_hash: String
  collection_name: String
  creator_address: String
  description: String
  description_mutable: Boolean
  inserted_at: timestamp
  last_transaction_timestamp: timestamp
  last_transaction_version: bigint
  maximum: numeric
  maximum_mutable: Boolean
  metadata_uri: String
  supply: numeric
  table_handle: String
  uri_mutable: Boolean
}

"""
aggregated selection of "legacy_migration_v1.current_collection_datas"
"""
type current_collection_datas_aggregate {
  aggregate: current_collection_datas_aggregate_fields
  nodes: [current_collection_datas!]!
}

"""
aggregate fields of "legacy_migration_v1.current_collection_datas"
"""
type current_collection_datas_aggregate_fields {
  avg: current_collection_datas_avg_fields
  count(columns: [current_collection_datas_select_column!], distinct: Boolean): Int!
  max: current_collection_datas_max_fields
  min: current_collection_datas_min_fields
  stddev: current_collection_datas_stddev_fields
  stddev_pop: current_collection_datas_stddev_pop_fields
  stddev_samp: current_collection_datas_stddev_samp_fields
  sum: current_collection_datas_sum_fields
  var_pop: current_collection_datas_var_pop_fields
  var_samp: current_collection_datas_var_samp_fields
  variance: current_collection_datas_variance_fields
}

"""aggregate avg on columns"""
type current_collection_datas_avg_fields {
  last_transaction_version: Float
  maximum: Float
  supply: Float
}

"""
Boolean expression to filter rows from the table "legacy_migration_v1.current_collection_datas". All fields are combined with a logical 'AND'.
"""
input current_collection_datas_bool_exp {
  _and: [current_collection_datas_bool_exp!]
  _not: current_collection_datas_bool_exp
  _or: [current_collection_datas_bool_exp!]
  collection_data_id_hash: String_comparison_exp
  collection_name: String_comparison_exp
  creator_address: String_comparison_exp
  description: String_comparison_exp
  description_mutable: Boolean_comparison_exp
  inserted_at: timestamp_comparison_exp
  last_transaction_timestamp: timestamp_comparison_exp
  last_transaction_version: bigint_comparison_exp
  maximum: numeric_comparison_exp
  maximum_mutable: Boolean_comparison_exp
  metadata_uri: String_comparison_exp
  supply: numeric_comparison_exp
  table_handle: String_comparison_exp
  uri_mutable: Boolean_comparison_exp
}

"""
input type for incrementing numeric columns in table "legacy_migration_v1.current_collection_datas"
"""
input current_collection_datas_inc_input {
  last_transaction_version: bigint
  maximum: numeric
  supply: numeric
}

"""
input type for inserting data into table "legacy_migration_v1.current_collection_datas"
"""
input current_collection_datas_insert_input {
  collection_data_id_hash: String
  collection_name: String
  creator_address: String
  description: String
  description_mutable: Boolean
  inserted_at: timestamp
  last_transaction_timestamp: timestamp
  last_transaction_version: bigint
  maximum: numeric
  maximum_mutable: Boolean
  metadata_uri: String
  supply: numeric
  table_handle: String
  uri_mutable: Boolean
}

"""aggregate max on columns"""
type current_collection_datas_max_fields {
  collection_data_id_hash: String
  collection_name: String
  creator_address: String
  description: String
  inserted_at: timestamp
  last_transaction_timestamp: timestamp
  last_transaction_version: bigint
  maximum: numeric
  metadata_uri: String
  supply: numeric
  table_handle: String
}

"""aggregate min on columns"""
type current_collection_datas_min_fields {
  collection_data_id_hash: String
  collection_name: String
  creator_address: String
  description: String
  inserted_at: timestamp
  last_transaction_timestamp: timestamp
  last_transaction_version: bigint
  maximum: numeric
  metadata_uri: String
  supply: numeric
  table_handle: String
}

"""
response of any mutation on the table "legacy_migration_v1.current_collection_datas"
"""
type current_collection_datas_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [current_collection_datas!]!
}

"""
input type for inserting object relation for remote table "legacy_migration_v1.current_collection_datas"
"""
input current_collection_datas_obj_rel_insert_input {
  data: current_collection_datas_insert_input!
}

"""
Ordering options when selecting data from "legacy_migration_v1.current_collection_datas".
"""
input current_collection_datas_order_by {
  collection_data_id_hash: order_by
  collection_name: order_by
  creator_address: order_by
  description: order_by
  description_mutable: order_by
  inserted_at: order_by
  last_transaction_timestamp: order_by
  last_transaction_version: order_by
  maximum: order_by
  maximum_mutable: order_by
  metadata_uri: order_by
  supply: order_by
  table_handle: order_by
  uri_mutable: order_by
}

"""
select columns of table "legacy_migration_v1.current_collection_datas"
"""
enum current_collection_datas_select_column {
  """column name"""
  collection_data_id_hash

  """column name"""
  collection_name

  """column name"""
  creator_address

  """column name"""
  description

  """column name"""
  description_mutable

  """column name"""
  inserted_at

  """column name"""
  last_transaction_timestamp

  """column name"""
  last_transaction_version

  """column name"""
  maximum

  """column name"""
  maximum_mutable

  """column name"""
  metadata_uri

  """column name"""
  supply

  """column name"""
  table_handle

  """column name"""
  uri_mutable
}

"""
input type for updating data in table "legacy_migration_v1.current_collection_datas"
"""
input current_collection_datas_set_input {
  collection_data_id_hash: String
  collection_name: String
  creator_address: String
  description: String
  description_mutable: Boolean
  inserted_at: timestamp
  last_transaction_timestamp: timestamp
  last_transaction_version: bigint
  maximum: numeric
  maximum_mutable: Boolean
  metadata_uri: String
  supply: numeric
  table_handle: String
  uri_mutable: Boolean
}

"""aggregate stddev on columns"""
type current_collection_datas_stddev_fields {
  last_transaction_version: Float
  maximum: Float
  supply: Float
}

"""aggregate stddev_pop on columns"""
type current_collection_datas_stddev_pop_fields {
  last_transaction_version: Float
  maximum: Float
  supply: Float
}

"""aggregate stddev_samp on columns"""
type current_collection_datas_stddev_samp_fields {
  last_transaction_version: Float
  maximum: Float
  supply: Float
}

"""
Streaming cursor of the table "current_collection_datas"
"""
input current_collection_datas_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: current_collection_datas_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input current_collection_datas_stream_cursor_value_input {
  collection_data_id_hash: String
  collection_name: String
  creator_address: String
  description: String
  description_mutable: Boolean
  inserted_at: timestamp
  last_transaction_timestamp: timestamp
  last_transaction_version: bigint
  maximum: numeric
  maximum_mutable: Boolean
  metadata_uri: String
  supply: numeric
  table_handle: String
  uri_mutable: Boolean
}

"""aggregate sum on columns"""
type current_collection_datas_sum_fields {
  last_transaction_version: bigint
  maximum: numeric
  supply: numeric
}

input current_collection_datas_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: current_collection_datas_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: current_collection_datas_set_input

  """filter the rows which have to be updated"""
  where: current_collection_datas_bool_exp!
}

"""aggregate var_pop on columns"""
type current_collection_datas_var_pop_fields {
  last_transaction_version: Float
  maximum: Float
  supply: Float
}

"""aggregate var_samp on columns"""
type current_collection_datas_var_samp_fields {
  last_transaction_version: Float
  maximum: Float
  supply: Float
}

"""aggregate variance on columns"""
type current_collection_datas_variance_fields {
  last_transaction_version: Float
  maximum: Float
  supply: Float
}

"""
columns and relationships of "current_collection_ownership_v2_view"
"""
type current_collection_ownership_v2_view {
  collection_id: String
  collection_name: String
  collection_uri: String
  creator_address: String

  """An object relationship"""
  current_collection: current_collections_v2
  distinct_tokens: bigint
  last_transaction_version: bigint
  owner_address: String
  single_token_uri: String
}

"""
aggregated selection of "current_collection_ownership_v2_view"
"""
type current_collection_ownership_v2_view_aggregate {
  aggregate: current_collection_ownership_v2_view_aggregate_fields
  nodes: [current_collection_ownership_v2_view!]!
}

"""
aggregate fields of "current_collection_ownership_v2_view"
"""
type current_collection_ownership_v2_view_aggregate_fields {
  avg: current_collection_ownership_v2_view_avg_fields
  count(columns: [current_collection_ownership_v2_view_select_column!], distinct: Boolean): Int!
  max: current_collection_ownership_v2_view_max_fields
  min: current_collection_ownership_v2_view_min_fields
  stddev: current_collection_ownership_v2_view_stddev_fields
  stddev_pop: current_collection_ownership_v2_view_stddev_pop_fields
  stddev_samp: current_collection_ownership_v2_view_stddev_samp_fields
  sum: current_collection_ownership_v2_view_sum_fields
  var_pop: current_collection_ownership_v2_view_var_pop_fields
  var_samp: current_collection_ownership_v2_view_var_samp_fields
  variance: current_collection_ownership_v2_view_variance_fields
}

"""aggregate avg on columns"""
type current_collection_ownership_v2_view_avg_fields {
  distinct_tokens: Float
  last_transaction_version: Float
}

"""
Boolean expression to filter rows from the table "current_collection_ownership_v2_view". All fields are combined with a logical 'AND'.
"""
input current_collection_ownership_v2_view_bool_exp {
  _and: [current_collection_ownership_v2_view_bool_exp!]
  _not: current_collection_ownership_v2_view_bool_exp
  _or: [current_collection_ownership_v2_view_bool_exp!]
  collection_id: String_comparison_exp
  collection_name: String_comparison_exp
  collection_uri: String_comparison_exp
  creator_address: String_comparison_exp
  current_collection: current_collections_v2_bool_exp
  distinct_tokens: bigint_comparison_exp
  last_transaction_version: bigint_comparison_exp
  owner_address: String_comparison_exp
  single_token_uri: String_comparison_exp
}

"""aggregate max on columns"""
type current_collection_ownership_v2_view_max_fields {
  collection_id: String
  collection_name: String
  collection_uri: String
  creator_address: String
  distinct_tokens: bigint
  last_transaction_version: bigint
  owner_address: String
  single_token_uri: String
}

"""aggregate min on columns"""
type current_collection_ownership_v2_view_min_fields {
  collection_id: String
  collection_name: String
  collection_uri: String
  creator_address: String
  distinct_tokens: bigint
  last_transaction_version: bigint
  owner_address: String
  single_token_uri: String
}

"""
Ordering options when selecting data from "current_collection_ownership_v2_view".
"""
input current_collection_ownership_v2_view_order_by {
  collection_id: order_by
  collection_name: order_by
  collection_uri: order_by
  creator_address: order_by
  current_collection: current_collections_v2_order_by
  distinct_tokens: order_by
  last_transaction_version: order_by
  owner_address: order_by
  single_token_uri: order_by
}

"""
select columns of table "current_collection_ownership_v2_view"
"""
enum current_collection_ownership_v2_view_select_column {
  """column name"""
  collection_id

  """column name"""
  collection_name

  """column name"""
  collection_uri

  """column name"""
  creator_address

  """column name"""
  distinct_tokens

  """column name"""
  last_transaction_version

  """column name"""
  owner_address

  """column name"""
  single_token_uri
}

"""aggregate stddev on columns"""
type current_collection_ownership_v2_view_stddev_fields {
  distinct_tokens: Float
  last_transaction_version: Float
}

"""aggregate stddev_pop on columns"""
type current_collection_ownership_v2_view_stddev_pop_fields {
  distinct_tokens: Float
  last_transaction_version: Float
}

"""aggregate stddev_samp on columns"""
type current_collection_ownership_v2_view_stddev_samp_fields {
  distinct_tokens: Float
  last_transaction_version: Float
}

"""
Streaming cursor of the table "current_collection_ownership_v2_view"
"""
input current_collection_ownership_v2_view_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: current_collection_ownership_v2_view_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input current_collection_ownership_v2_view_stream_cursor_value_input {
  collection_id: String
  collection_name: String
  collection_uri: String
  creator_address: String
  distinct_tokens: bigint
  last_transaction_version: bigint
  owner_address: String
  single_token_uri: String
}

"""aggregate sum on columns"""
type current_collection_ownership_v2_view_sum_fields {
  distinct_tokens: bigint
  last_transaction_version: bigint
}

"""aggregate var_pop on columns"""
type current_collection_ownership_v2_view_var_pop_fields {
  distinct_tokens: Float
  last_transaction_version: Float
}

"""aggregate var_samp on columns"""
type current_collection_ownership_v2_view_var_samp_fields {
  distinct_tokens: Float
  last_transaction_version: Float
}

"""aggregate variance on columns"""
type current_collection_ownership_v2_view_variance_fields {
  distinct_tokens: Float
  last_transaction_version: Float
}

"""
columns and relationships of "current_collections_v2"
"""
type current_collections_v2 {
  """An object relationship"""
  cdn_asset_uris: nft_metadata_crawler_parsed_asset_uris
  collection_id: String!
  collection_name: String!
  collection_properties(
    """JSON select path"""
    path: String
  ): jsonb
  creator_address: String!
  current_supply: numeric!
  description: String!
  inserted_at: timestamp!
  last_transaction_timestamp: timestamp!
  last_transaction_version: bigint!
  max_supply: numeric
  mutable_description: Boolean
  mutable_uri: Boolean
  table_handle_v1: String
  token_standard: String!
  total_minted_v2: numeric
  uri: String!
}

"""
aggregated selection of "current_collections_v2"
"""
type current_collections_v2_aggregate {
  aggregate: current_collections_v2_aggregate_fields
  nodes: [current_collections_v2!]!
}

"""
aggregate fields of "current_collections_v2"
"""
type current_collections_v2_aggregate_fields {
  avg: current_collections_v2_avg_fields
  count(columns: [current_collections_v2_select_column!], distinct: Boolean): Int!
  max: current_collections_v2_max_fields
  min: current_collections_v2_min_fields
  stddev: current_collections_v2_stddev_fields
  stddev_pop: current_collections_v2_stddev_pop_fields
  stddev_samp: current_collections_v2_stddev_samp_fields
  sum: current_collections_v2_sum_fields
  var_pop: current_collections_v2_var_pop_fields
  var_samp: current_collections_v2_var_samp_fields
  variance: current_collections_v2_variance_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input current_collections_v2_append_input {
  collection_properties: jsonb
}

"""aggregate avg on columns"""
type current_collections_v2_avg_fields {
  current_supply: Float
  last_transaction_version: Float
  max_supply: Float
  total_minted_v2: Float
}

"""
Boolean expression to filter rows from the table "current_collections_v2". All fields are combined with a logical 'AND'.
"""
input current_collections_v2_bool_exp {
  _and: [current_collections_v2_bool_exp!]
  _not: current_collections_v2_bool_exp
  _or: [current_collections_v2_bool_exp!]
  cdn_asset_uris: nft_metadata_crawler_parsed_asset_uris_bool_exp
  collection_id: String_comparison_exp
  collection_name: String_comparison_exp
  collection_properties: jsonb_comparison_exp
  creator_address: String_comparison_exp
  current_supply: numeric_comparison_exp
  description: String_comparison_exp
  inserted_at: timestamp_comparison_exp
  last_transaction_timestamp: timestamp_comparison_exp
  last_transaction_version: bigint_comparison_exp
  max_supply: numeric_comparison_exp
  mutable_description: Boolean_comparison_exp
  mutable_uri: Boolean_comparison_exp
  table_handle_v1: String_comparison_exp
  token_standard: String_comparison_exp
  total_minted_v2: numeric_comparison_exp
  uri: String_comparison_exp
}

"""
unique or primary key constraints on table "current_collections_v2"
"""
enum current_collections_v2_constraint {
  """
  unique or primary key constraint on columns "collection_id"
  """
  current_collections_v2_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input current_collections_v2_delete_at_path_input {
  collection_properties: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input current_collections_v2_delete_elem_input {
  collection_properties: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input current_collections_v2_delete_key_input {
  collection_properties: String
}

"""
input type for incrementing numeric columns in table "current_collections_v2"
"""
input current_collections_v2_inc_input {
  current_supply: numeric
  last_transaction_version: bigint
  max_supply: numeric
  total_minted_v2: numeric
}

"""
input type for inserting data into table "current_collections_v2"
"""
input current_collections_v2_insert_input {
  cdn_asset_uris: nft_metadata_crawler_parsed_asset_uris_obj_rel_insert_input
  collection_id: String
  collection_name: String
  collection_properties: jsonb
  creator_address: String
  current_supply: numeric
  description: String
  inserted_at: timestamp
  last_transaction_timestamp: timestamp
  last_transaction_version: bigint
  max_supply: numeric
  mutable_description: Boolean
  mutable_uri: Boolean
  table_handle_v1: String
  token_standard: String
  total_minted_v2: numeric
  uri: String
}

"""aggregate max on columns"""
type current_collections_v2_max_fields {
  collection_id: String
  collection_name: String
  creator_address: String
  current_supply: numeric
  description: String
  inserted_at: timestamp
  last_transaction_timestamp: timestamp
  last_transaction_version: bigint
  max_supply: numeric
  table_handle_v1: String
  token_standard: String
  total_minted_v2: numeric
  uri: String
}

"""aggregate min on columns"""
type current_collections_v2_min_fields {
  collection_id: String
  collection_name: String
  creator_address: String
  current_supply: numeric
  description: String
  inserted_at: timestamp
  last_transaction_timestamp: timestamp
  last_transaction_version: bigint
  max_supply: numeric
  table_handle_v1: String
  token_standard: String
  total_minted_v2: numeric
  uri: String
}

"""
response of any mutation on the table "current_collections_v2"
"""
type current_collections_v2_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [current_collections_v2!]!
}

"""
input type for inserting object relation for remote table "current_collections_v2"
"""
input current_collections_v2_obj_rel_insert_input {
  data: current_collections_v2_insert_input!

  """upsert condition"""
  on_conflict: current_collections_v2_on_conflict
}

"""
on_conflict condition type for table "current_collections_v2"
"""
input current_collections_v2_on_conflict {
  constraint: current_collections_v2_constraint!
  update_columns: [current_collections_v2_update_column!]! = []
  where: current_collections_v2_bool_exp
}

"""Ordering options when selecting data from "current_collections_v2"."""
input current_collections_v2_order_by {
  cdn_asset_uris: nft_metadata_crawler_parsed_asset_uris_order_by
  collection_id: order_by
  collection_name: order_by
  collection_properties: order_by
  creator_address: order_by
  current_supply: order_by
  description: order_by
  inserted_at: order_by
  last_transaction_timestamp: order_by
  last_transaction_version: order_by
  max_supply: order_by
  mutable_description: order_by
  mutable_uri: order_by
  table_handle_v1: order_by
  token_standard: order_by
  total_minted_v2: order_by
  uri: order_by
}

"""primary key columns input for table: current_collections_v2"""
input current_collections_v2_pk_columns_input {
  collection_id: String!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input current_collections_v2_prepend_input {
  collection_properties: jsonb
}

"""
select columns of table "current_collections_v2"
"""
enum current_collections_v2_select_column {
  """column name"""
  collection_id

  """column name"""
  collection_name

  """column name"""
  collection_properties

  """column name"""
  creator_address

  """column name"""
  current_supply

  """column name"""
  description

  """column name"""
  inserted_at

  """column name"""
  last_transaction_timestamp

  """column name"""
  last_transaction_version

  """column name"""
  max_supply

  """column name"""
  mutable_description

  """column name"""
  mutable_uri

  """column name"""
  table_handle_v1

  """column name"""
  token_standard

  """column name"""
  total_minted_v2

  """column name"""
  uri
}

"""
input type for updating data in table "current_collections_v2"
"""
input current_collections_v2_set_input {
  collection_id: String
  collection_name: String
  collection_properties: jsonb
  creator_address: String
  current_supply: numeric
  description: String
  inserted_at: timestamp
  last_transaction_timestamp: timestamp
  last_transaction_version: bigint
  max_supply: numeric
  mutable_description: Boolean
  mutable_uri: Boolean
  table_handle_v1: String
  token_standard: String
  total_minted_v2: numeric
  uri: String
}

"""aggregate stddev on columns"""
type current_collections_v2_stddev_fields {
  current_supply: Float
  last_transaction_version: Float
  max_supply: Float
  total_minted_v2: Float
}

"""aggregate stddev_pop on columns"""
type current_collections_v2_stddev_pop_fields {
  current_supply: Float
  last_transaction_version: Float
  max_supply: Float
  total_minted_v2: Float
}

"""aggregate stddev_samp on columns"""
type current_collections_v2_stddev_samp_fields {
  current_supply: Float
  last_transaction_version: Float
  max_supply: Float
  total_minted_v2: Float
}

"""
Streaming cursor of the table "current_collections_v2"
"""
input current_collections_v2_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: current_collections_v2_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input current_collections_v2_stream_cursor_value_input {
  collection_id: String
  collection_name: String
  collection_properties: jsonb
  creator_address: String
  current_supply: numeric
  description: String
  inserted_at: timestamp
  last_transaction_timestamp: timestamp
  last_transaction_version: bigint
  max_supply: numeric
  mutable_description: Boolean
  mutable_uri: Boolean
  table_handle_v1: String
  token_standard: String
  total_minted_v2: numeric
  uri: String
}

"""aggregate sum on columns"""
type current_collections_v2_sum_fields {
  current_supply: numeric
  last_transaction_version: bigint
  max_supply: numeric
  total_minted_v2: numeric
}

"""
update columns of table "current_collections_v2"
"""
enum current_collections_v2_update_column {
  """column name"""
  collection_id

  """column name"""
  collection_name

  """column name"""
  collection_properties

  """column name"""
  creator_address

  """column name"""
  current_supply

  """column name"""
  description

  """column name"""
  inserted_at

  """column name"""
  last_transaction_timestamp

  """column name"""
  last_transaction_version

  """column name"""
  max_supply

  """column name"""
  mutable_description

  """column name"""
  mutable_uri

  """column name"""
  table_handle_v1

  """column name"""
  token_standard

  """column name"""
  total_minted_v2

  """column name"""
  uri
}

input current_collections_v2_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: current_collections_v2_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: current_collections_v2_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: current_collections_v2_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: current_collections_v2_delete_key_input

  """increments the numeric columns with given value of the filtered values"""
  _inc: current_collections_v2_inc_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: current_collections_v2_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: current_collections_v2_set_input

  """filter the rows which have to be updated"""
  where: current_collections_v2_bool_exp!
}

"""aggregate var_pop on columns"""
type current_collections_v2_var_pop_fields {
  current_supply: Float
  last_transaction_version: Float
  max_supply: Float
  total_minted_v2: Float
}

"""aggregate var_samp on columns"""
type current_collections_v2_var_samp_fields {
  current_supply: Float
  last_transaction_version: Float
  max_supply: Float
  total_minted_v2: Float
}

"""aggregate variance on columns"""
type current_collections_v2_variance_fields {
  current_supply: Float
  last_transaction_version: Float
  max_supply: Float
  total_minted_v2: Float
}

"""
columns and relationships of "current_delegated_staking_pool_balances"
"""
type current_delegated_staking_pool_balances {
  active_table_handle: String!
  inactive_table_handle: String!
  inserted_at: timestamp!
  last_transaction_version: bigint!
  operator_commission_percentage: numeric!
  staking_pool_address: String!
  total_coins: numeric!
  total_shares: numeric!
}

"""
aggregated selection of "current_delegated_staking_pool_balances"
"""
type current_delegated_staking_pool_balances_aggregate {
  aggregate: current_delegated_staking_pool_balances_aggregate_fields
  nodes: [current_delegated_staking_pool_balances!]!
}

"""
aggregate fields of "current_delegated_staking_pool_balances"
"""
type current_delegated_staking_pool_balances_aggregate_fields {
  avg: current_delegated_staking_pool_balances_avg_fields
  count(columns: [current_delegated_staking_pool_balances_select_column!], distinct: Boolean): Int!
  max: current_delegated_staking_pool_balances_max_fields
  min: current_delegated_staking_pool_balances_min_fields
  stddev: current_delegated_staking_pool_balances_stddev_fields
  stddev_pop: current_delegated_staking_pool_balances_stddev_pop_fields
  stddev_samp: current_delegated_staking_pool_balances_stddev_samp_fields
  sum: current_delegated_staking_pool_balances_sum_fields
  var_pop: current_delegated_staking_pool_balances_var_pop_fields
  var_samp: current_delegated_staking_pool_balances_var_samp_fields
  variance: current_delegated_staking_pool_balances_variance_fields
}

"""aggregate avg on columns"""
type current_delegated_staking_pool_balances_avg_fields {
  last_transaction_version: Float
  operator_commission_percentage: Float
  total_coins: Float
  total_shares: Float
}

"""
Boolean expression to filter rows from the table "current_delegated_staking_pool_balances". All fields are combined with a logical 'AND'.
"""
input current_delegated_staking_pool_balances_bool_exp {
  _and: [current_delegated_staking_pool_balances_bool_exp!]
  _not: current_delegated_staking_pool_balances_bool_exp
  _or: [current_delegated_staking_pool_balances_bool_exp!]
  active_table_handle: String_comparison_exp
  inactive_table_handle: String_comparison_exp
  inserted_at: timestamp_comparison_exp
  last_transaction_version: bigint_comparison_exp
  operator_commission_percentage: numeric_comparison_exp
  staking_pool_address: String_comparison_exp
  total_coins: numeric_comparison_exp
  total_shares: numeric_comparison_exp
}

"""
unique or primary key constraints on table "current_delegated_staking_pool_balances"
"""
enum current_delegated_staking_pool_balances_constraint {
  """
  unique or primary key constraint on columns "staking_pool_address"
  """
  current_delegated_staking_pool_balances_pkey
}

"""
input type for incrementing numeric columns in table "current_delegated_staking_pool_balances"
"""
input current_delegated_staking_pool_balances_inc_input {
  last_transaction_version: bigint
  operator_commission_percentage: numeric
  total_coins: numeric
  total_shares: numeric
}

"""
input type for inserting data into table "current_delegated_staking_pool_balances"
"""
input current_delegated_staking_pool_balances_insert_input {
  active_table_handle: String
  inactive_table_handle: String
  inserted_at: timestamp
  last_transaction_version: bigint
  operator_commission_percentage: numeric
  staking_pool_address: String
  total_coins: numeric
  total_shares: numeric
}

"""aggregate max on columns"""
type current_delegated_staking_pool_balances_max_fields {
  active_table_handle: String
  inactive_table_handle: String
  inserted_at: timestamp
  last_transaction_version: bigint
  operator_commission_percentage: numeric
  staking_pool_address: String
  total_coins: numeric
  total_shares: numeric
}

"""aggregate min on columns"""
type current_delegated_staking_pool_balances_min_fields {
  active_table_handle: String
  inactive_table_handle: String
  inserted_at: timestamp
  last_transaction_version: bigint
  operator_commission_percentage: numeric
  staking_pool_address: String
  total_coins: numeric
  total_shares: numeric
}

"""
response of any mutation on the table "current_delegated_staking_pool_balances"
"""
type current_delegated_staking_pool_balances_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [current_delegated_staking_pool_balances!]!
}

"""
input type for inserting object relation for remote table "current_delegated_staking_pool_balances"
"""
input current_delegated_staking_pool_balances_obj_rel_insert_input {
  data: current_delegated_staking_pool_balances_insert_input!

  """upsert condition"""
  on_conflict: current_delegated_staking_pool_balances_on_conflict
}

"""
on_conflict condition type for table "current_delegated_staking_pool_balances"
"""
input current_delegated_staking_pool_balances_on_conflict {
  constraint: current_delegated_staking_pool_balances_constraint!
  update_columns: [current_delegated_staking_pool_balances_update_column!]! = []
  where: current_delegated_staking_pool_balances_bool_exp
}

"""
Ordering options when selecting data from "current_delegated_staking_pool_balances".
"""
input current_delegated_staking_pool_balances_order_by {
  active_table_handle: order_by
  inactive_table_handle: order_by
  inserted_at: order_by
  last_transaction_version: order_by
  operator_commission_percentage: order_by
  staking_pool_address: order_by
  total_coins: order_by
  total_shares: order_by
}

"""
primary key columns input for table: current_delegated_staking_pool_balances
"""
input current_delegated_staking_pool_balances_pk_columns_input {
  staking_pool_address: String!
}

"""
select columns of table "current_delegated_staking_pool_balances"
"""
enum current_delegated_staking_pool_balances_select_column {
  """column name"""
  active_table_handle

  """column name"""
  inactive_table_handle

  """column name"""
  inserted_at

  """column name"""
  last_transaction_version

  """column name"""
  operator_commission_percentage

  """column name"""
  staking_pool_address

  """column name"""
  total_coins

  """column name"""
  total_shares
}

"""
input type for updating data in table "current_delegated_staking_pool_balances"
"""
input current_delegated_staking_pool_balances_set_input {
  active_table_handle: String
  inactive_table_handle: String
  inserted_at: timestamp
  last_transaction_version: bigint
  operator_commission_percentage: numeric
  staking_pool_address: String
  total_coins: numeric
  total_shares: numeric
}

"""aggregate stddev on columns"""
type current_delegated_staking_pool_balances_stddev_fields {
  last_transaction_version: Float
  operator_commission_percentage: Float
  total_coins: Float
  total_shares: Float
}

"""aggregate stddev_pop on columns"""
type current_delegated_staking_pool_balances_stddev_pop_fields {
  last_transaction_version: Float
  operator_commission_percentage: Float
  total_coins: Float
  total_shares: Float
}

"""aggregate stddev_samp on columns"""
type current_delegated_staking_pool_balances_stddev_samp_fields {
  last_transaction_version: Float
  operator_commission_percentage: Float
  total_coins: Float
  total_shares: Float
}

"""
Streaming cursor of the table "current_delegated_staking_pool_balances"
"""
input current_delegated_staking_pool_balances_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: current_delegated_staking_pool_balances_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input current_delegated_staking_pool_balances_stream_cursor_value_input {
  active_table_handle: String
  inactive_table_handle: String
  inserted_at: timestamp
  last_transaction_version: bigint
  operator_commission_percentage: numeric
  staking_pool_address: String
  total_coins: numeric
  total_shares: numeric
}

"""aggregate sum on columns"""
type current_delegated_staking_pool_balances_sum_fields {
  last_transaction_version: bigint
  operator_commission_percentage: numeric
  total_coins: numeric
  total_shares: numeric
}

"""
update columns of table "current_delegated_staking_pool_balances"
"""
enum current_delegated_staking_pool_balances_update_column {
  """column name"""
  active_table_handle

  """column name"""
  inactive_table_handle

  """column name"""
  inserted_at

  """column name"""
  last_transaction_version

  """column name"""
  operator_commission_percentage

  """column name"""
  staking_pool_address

  """column name"""
  total_coins

  """column name"""
  total_shares
}

input current_delegated_staking_pool_balances_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: current_delegated_staking_pool_balances_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: current_delegated_staking_pool_balances_set_input

  """filter the rows which have to be updated"""
  where: current_delegated_staking_pool_balances_bool_exp!
}

"""aggregate var_pop on columns"""
type current_delegated_staking_pool_balances_var_pop_fields {
  last_transaction_version: Float
  operator_commission_percentage: Float
  total_coins: Float
  total_shares: Float
}

"""aggregate var_samp on columns"""
type current_delegated_staking_pool_balances_var_samp_fields {
  last_transaction_version: Float
  operator_commission_percentage: Float
  total_coins: Float
  total_shares: Float
}

"""aggregate variance on columns"""
type current_delegated_staking_pool_balances_variance_fields {
  last_transaction_version: Float
  operator_commission_percentage: Float
  total_coins: Float
  total_shares: Float
}

"""
columns and relationships of "current_delegated_voter"
"""
type current_delegated_voter {
  delegation_pool_address: String!
  delegator_address: String!
  inserted_at: timestamp!
  last_transaction_timestamp: timestamp!
  last_transaction_version: bigint!
  pending_voter: String
  table_handle: String
  voter: String
}

"""
aggregated selection of "current_delegated_voter"
"""
type current_delegated_voter_aggregate {
  aggregate: current_delegated_voter_aggregate_fields
  nodes: [current_delegated_voter!]!
}

"""
aggregate fields of "current_delegated_voter"
"""
type current_delegated_voter_aggregate_fields {
  avg: current_delegated_voter_avg_fields
  count(columns: [current_delegated_voter_select_column!], distinct: Boolean): Int!
  max: current_delegated_voter_max_fields
  min: current_delegated_voter_min_fields
  stddev: current_delegated_voter_stddev_fields
  stddev_pop: current_delegated_voter_stddev_pop_fields
  stddev_samp: current_delegated_voter_stddev_samp_fields
  sum: current_delegated_voter_sum_fields
  var_pop: current_delegated_voter_var_pop_fields
  var_samp: current_delegated_voter_var_samp_fields
  variance: current_delegated_voter_variance_fields
}

"""aggregate avg on columns"""
type current_delegated_voter_avg_fields {
  last_transaction_version: Float
}

"""
Boolean expression to filter rows from the table "current_delegated_voter". All fields are combined with a logical 'AND'.
"""
input current_delegated_voter_bool_exp {
  _and: [current_delegated_voter_bool_exp!]
  _not: current_delegated_voter_bool_exp
  _or: [current_delegated_voter_bool_exp!]
  delegation_pool_address: String_comparison_exp
  delegator_address: String_comparison_exp
  inserted_at: timestamp_comparison_exp
  last_transaction_timestamp: timestamp_comparison_exp
  last_transaction_version: bigint_comparison_exp
  pending_voter: String_comparison_exp
  table_handle: String_comparison_exp
  voter: String_comparison_exp
}

"""
unique or primary key constraints on table "current_delegated_voter"
"""
enum current_delegated_voter_constraint {
  """
  unique or primary key constraint on columns "delegator_address", "delegation_pool_address"
  """
  current_delegated_voter_pkey
}

"""
input type for incrementing numeric columns in table "current_delegated_voter"
"""
input current_delegated_voter_inc_input {
  last_transaction_version: bigint
}

"""
input type for inserting data into table "current_delegated_voter"
"""
input current_delegated_voter_insert_input {
  delegation_pool_address: String
  delegator_address: String
  inserted_at: timestamp
  last_transaction_timestamp: timestamp
  last_transaction_version: bigint
  pending_voter: String
  table_handle: String
  voter: String
}

"""aggregate max on columns"""
type current_delegated_voter_max_fields {
  delegation_pool_address: String
  delegator_address: String
  inserted_at: timestamp
  last_transaction_timestamp: timestamp
  last_transaction_version: bigint
  pending_voter: String
  table_handle: String
  voter: String
}

"""aggregate min on columns"""
type current_delegated_voter_min_fields {
  delegation_pool_address: String
  delegator_address: String
  inserted_at: timestamp
  last_transaction_timestamp: timestamp
  last_transaction_version: bigint
  pending_voter: String
  table_handle: String
  voter: String
}

"""
response of any mutation on the table "current_delegated_voter"
"""
type current_delegated_voter_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [current_delegated_voter!]!
}

"""
on_conflict condition type for table "current_delegated_voter"
"""
input current_delegated_voter_on_conflict {
  constraint: current_delegated_voter_constraint!
  update_columns: [current_delegated_voter_update_column!]! = []
  where: current_delegated_voter_bool_exp
}

"""Ordering options when selecting data from "current_delegated_voter"."""
input current_delegated_voter_order_by {
  delegation_pool_address: order_by
  delegator_address: order_by
  inserted_at: order_by
  last_transaction_timestamp: order_by
  last_transaction_version: order_by
  pending_voter: order_by
  table_handle: order_by
  voter: order_by
}

"""primary key columns input for table: current_delegated_voter"""
input current_delegated_voter_pk_columns_input {
  delegation_pool_address: String!
  delegator_address: String!
}

"""
select columns of table "current_delegated_voter"
"""
enum current_delegated_voter_select_column {
  """column name"""
  delegation_pool_address

  """column name"""
  delegator_address

  """column name"""
  inserted_at

  """column name"""
  last_transaction_timestamp

  """column name"""
  last_transaction_version

  """column name"""
  pending_voter

  """column name"""
  table_handle

  """column name"""
  voter
}

"""
input type for updating data in table "current_delegated_voter"
"""
input current_delegated_voter_set_input {
  delegation_pool_address: String
  delegator_address: String
  inserted_at: timestamp
  last_transaction_timestamp: timestamp
  last_transaction_version: bigint
  pending_voter: String
  table_handle: String
  voter: String
}

"""aggregate stddev on columns"""
type current_delegated_voter_stddev_fields {
  last_transaction_version: Float
}

"""aggregate stddev_pop on columns"""
type current_delegated_voter_stddev_pop_fields {
  last_transaction_version: Float
}

"""aggregate stddev_samp on columns"""
type current_delegated_voter_stddev_samp_fields {
  last_transaction_version: Float
}

"""
Streaming cursor of the table "current_delegated_voter"
"""
input current_delegated_voter_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: current_delegated_voter_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input current_delegated_voter_stream_cursor_value_input {
  delegation_pool_address: String
  delegator_address: String
  inserted_at: timestamp
  last_transaction_timestamp: timestamp
  last_transaction_version: bigint
  pending_voter: String
  table_handle: String
  voter: String
}

"""aggregate sum on columns"""
type current_delegated_voter_sum_fields {
  last_transaction_version: bigint
}

"""
update columns of table "current_delegated_voter"
"""
enum current_delegated_voter_update_column {
  """column name"""
  delegation_pool_address

  """column name"""
  delegator_address

  """column name"""
  inserted_at

  """column name"""
  last_transaction_timestamp

  """column name"""
  last_transaction_version

  """column name"""
  pending_voter

  """column name"""
  table_handle

  """column name"""
  voter
}

input current_delegated_voter_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: current_delegated_voter_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: current_delegated_voter_set_input

  """filter the rows which have to be updated"""
  where: current_delegated_voter_bool_exp!
}

"""aggregate var_pop on columns"""
type current_delegated_voter_var_pop_fields {
  last_transaction_version: Float
}

"""aggregate var_samp on columns"""
type current_delegated_voter_var_samp_fields {
  last_transaction_version: Float
}

"""aggregate variance on columns"""
type current_delegated_voter_variance_fields {
  last_transaction_version: Float
}

"""
columns and relationships of "current_delegator_balances"
"""
type current_delegator_balances {
  """An object relationship"""
  current_pool_balance: current_delegated_staking_pool_balances
  delegator_address: String!
  inserted_at: timestamp!
  last_transaction_version: bigint!
  parent_table_handle: String!
  pool_address: String!
  pool_type: String!
  shares: numeric!

  """An object relationship"""
  staking_pool_metadata: current_staking_pool_voter
  table_handle: String!
}

"""
aggregated selection of "current_delegator_balances"
"""
type current_delegator_balances_aggregate {
  aggregate: current_delegator_balances_aggregate_fields
  nodes: [current_delegator_balances!]!
}

"""
aggregate fields of "current_delegator_balances"
"""
type current_delegator_balances_aggregate_fields {
  avg: current_delegator_balances_avg_fields
  count(columns: [current_delegator_balances_select_column!], distinct: Boolean): Int!
  max: current_delegator_balances_max_fields
  min: current_delegator_balances_min_fields
  stddev: current_delegator_balances_stddev_fields
  stddev_pop: current_delegator_balances_stddev_pop_fields
  stddev_samp: current_delegator_balances_stddev_samp_fields
  sum: current_delegator_balances_sum_fields
  var_pop: current_delegator_balances_var_pop_fields
  var_samp: current_delegator_balances_var_samp_fields
  variance: current_delegator_balances_variance_fields
}

"""aggregate avg on columns"""
type current_delegator_balances_avg_fields {
  last_transaction_version: Float
  shares: Float
}

"""
Boolean expression to filter rows from the table "current_delegator_balances". All fields are combined with a logical 'AND'.
"""
input current_delegator_balances_bool_exp {
  _and: [current_delegator_balances_bool_exp!]
  _not: current_delegator_balances_bool_exp
  _or: [current_delegator_balances_bool_exp!]
  current_pool_balance: current_delegated_staking_pool_balances_bool_exp
  delegator_address: String_comparison_exp
  inserted_at: timestamp_comparison_exp
  last_transaction_version: bigint_comparison_exp
  parent_table_handle: String_comparison_exp
  pool_address: String_comparison_exp
  pool_type: String_comparison_exp
  shares: numeric_comparison_exp
  staking_pool_metadata: current_staking_pool_voter_bool_exp
  table_handle: String_comparison_exp
}

"""
unique or primary key constraints on table "current_delegator_balances"
"""
enum current_delegator_balances_constraint {
  """
  unique or primary key constraint on columns "pool_address", "delegator_address", "pool_type", "table_handle"
  """
  current_delegator_balances_pkey
}

"""
input type for incrementing numeric columns in table "current_delegator_balances"
"""
input current_delegator_balances_inc_input {
  last_transaction_version: bigint
  shares: numeric
}

"""
input type for inserting data into table "current_delegator_balances"
"""
input current_delegator_balances_insert_input {
  current_pool_balance: current_delegated_staking_pool_balances_obj_rel_insert_input
  delegator_address: String
  inserted_at: timestamp
  last_transaction_version: bigint
  parent_table_handle: String
  pool_address: String
  pool_type: String
  shares: numeric
  staking_pool_metadata: current_staking_pool_voter_obj_rel_insert_input
  table_handle: String
}

"""aggregate max on columns"""
type current_delegator_balances_max_fields {
  delegator_address: String
  inserted_at: timestamp
  last_transaction_version: bigint
  parent_table_handle: String
  pool_address: String
  pool_type: String
  shares: numeric
  table_handle: String
}

"""aggregate min on columns"""
type current_delegator_balances_min_fields {
  delegator_address: String
  inserted_at: timestamp
  last_transaction_version: bigint
  parent_table_handle: String
  pool_address: String
  pool_type: String
  shares: numeric
  table_handle: String
}

"""
response of any mutation on the table "current_delegator_balances"
"""
type current_delegator_balances_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [current_delegator_balances!]!
}

"""
on_conflict condition type for table "current_delegator_balances"
"""
input current_delegator_balances_on_conflict {
  constraint: current_delegator_balances_constraint!
  update_columns: [current_delegator_balances_update_column!]! = []
  where: current_delegator_balances_bool_exp
}

"""
Ordering options when selecting data from "current_delegator_balances".
"""
input current_delegator_balances_order_by {
  current_pool_balance: current_delegated_staking_pool_balances_order_by
  delegator_address: order_by
  inserted_at: order_by
  last_transaction_version: order_by
  parent_table_handle: order_by
  pool_address: order_by
  pool_type: order_by
  shares: order_by
  staking_pool_metadata: current_staking_pool_voter_order_by
  table_handle: order_by
}

"""primary key columns input for table: current_delegator_balances"""
input current_delegator_balances_pk_columns_input {
  delegator_address: String!
  pool_address: String!
  pool_type: String!
  table_handle: String!
}

"""
select columns of table "current_delegator_balances"
"""
enum current_delegator_balances_select_column {
  """column name"""
  delegator_address

  """column name"""
  inserted_at

  """column name"""
  last_transaction_version

  """column name"""
  parent_table_handle

  """column name"""
  pool_address

  """column name"""
  pool_type

  """column name"""
  shares

  """column name"""
  table_handle
}

"""
input type for updating data in table "current_delegator_balances"
"""
input current_delegator_balances_set_input {
  delegator_address: String
  inserted_at: timestamp
  last_transaction_version: bigint
  parent_table_handle: String
  pool_address: String
  pool_type: String
  shares: numeric
  table_handle: String
}

"""aggregate stddev on columns"""
type current_delegator_balances_stddev_fields {
  last_transaction_version: Float
  shares: Float
}

"""aggregate stddev_pop on columns"""
type current_delegator_balances_stddev_pop_fields {
  last_transaction_version: Float
  shares: Float
}

"""aggregate stddev_samp on columns"""
type current_delegator_balances_stddev_samp_fields {
  last_transaction_version: Float
  shares: Float
}

"""
Streaming cursor of the table "current_delegator_balances"
"""
input current_delegator_balances_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: current_delegator_balances_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input current_delegator_balances_stream_cursor_value_input {
  delegator_address: String
  inserted_at: timestamp
  last_transaction_version: bigint
  parent_table_handle: String
  pool_address: String
  pool_type: String
  shares: numeric
  table_handle: String
}

"""aggregate sum on columns"""
type current_delegator_balances_sum_fields {
  last_transaction_version: bigint
  shares: numeric
}

"""
update columns of table "current_delegator_balances"
"""
enum current_delegator_balances_update_column {
  """column name"""
  delegator_address

  """column name"""
  inserted_at

  """column name"""
  last_transaction_version

  """column name"""
  parent_table_handle

  """column name"""
  pool_address

  """column name"""
  pool_type

  """column name"""
  shares

  """column name"""
  table_handle
}

input current_delegator_balances_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: current_delegator_balances_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: current_delegator_balances_set_input

  """filter the rows which have to be updated"""
  where: current_delegator_balances_bool_exp!
}

"""aggregate var_pop on columns"""
type current_delegator_balances_var_pop_fields {
  last_transaction_version: Float
  shares: Float
}

"""aggregate var_samp on columns"""
type current_delegator_balances_var_samp_fields {
  last_transaction_version: Float
  shares: Float
}

"""aggregate variance on columns"""
type current_delegator_balances_variance_fields {
  last_transaction_version: Float
  shares: Float
}

"""
columns and relationships of "current_fungible_asset_balances"
"""
type current_fungible_asset_balances {
  amount: numeric!
  amount_v1: numeric
  amount_v2: numeric
  asset_type: String!
  asset_type_v1: String
  asset_type_v2: String
  inserted_at: timestamp!
  is_frozen: Boolean!
  is_primary: Boolean!
  last_transaction_timestamp: timestamp
  last_transaction_timestamp_v1: timestamp
  last_transaction_timestamp_v2: timestamp
  last_transaction_version: bigint
  last_transaction_version_v1: bigint
  last_transaction_version_v2: bigint

  """An object relationship"""
  metadata: fungible_asset_metadata
  owner_address: String!
  storage_id: String!
  token_standard: String!
}

"""
aggregated selection of "current_fungible_asset_balances"
"""
type current_fungible_asset_balances_aggregate {
  aggregate: current_fungible_asset_balances_aggregate_fields
  nodes: [current_fungible_asset_balances!]!
}

"""
aggregate fields of "current_fungible_asset_balances"
"""
type current_fungible_asset_balances_aggregate_fields {
  avg: current_fungible_asset_balances_avg_fields
  count(columns: [current_fungible_asset_balances_select_column!], distinct: Boolean): Int!
  max: current_fungible_asset_balances_max_fields
  min: current_fungible_asset_balances_min_fields
  stddev: current_fungible_asset_balances_stddev_fields
  stddev_pop: current_fungible_asset_balances_stddev_pop_fields
  stddev_samp: current_fungible_asset_balances_stddev_samp_fields
  sum: current_fungible_asset_balances_sum_fields
  var_pop: current_fungible_asset_balances_var_pop_fields
  var_samp: current_fungible_asset_balances_var_samp_fields
  variance: current_fungible_asset_balances_variance_fields
}

"""aggregate avg on columns"""
type current_fungible_asset_balances_avg_fields {
  amount: Float
  amount_v1: Float
  amount_v2: Float
  last_transaction_version: Float
  last_transaction_version_v1: Float
  last_transaction_version_v2: Float
}

"""
Boolean expression to filter rows from the table "current_fungible_asset_balances". All fields are combined with a logical 'AND'.
"""
input current_fungible_asset_balances_bool_exp {
  _and: [current_fungible_asset_balances_bool_exp!]
  _not: current_fungible_asset_balances_bool_exp
  _or: [current_fungible_asset_balances_bool_exp!]
  amount: numeric_comparison_exp
  amount_v1: numeric_comparison_exp
  amount_v2: numeric_comparison_exp
  asset_type: String_comparison_exp
  asset_type_v1: String_comparison_exp
  asset_type_v2: String_comparison_exp
  inserted_at: timestamp_comparison_exp
  is_frozen: Boolean_comparison_exp
  is_primary: Boolean_comparison_exp
  last_transaction_timestamp: timestamp_comparison_exp
  last_transaction_timestamp_v1: timestamp_comparison_exp
  last_transaction_timestamp_v2: timestamp_comparison_exp
  last_transaction_version: bigint_comparison_exp
  last_transaction_version_v1: bigint_comparison_exp
  last_transaction_version_v2: bigint_comparison_exp
  metadata: fungible_asset_metadata_bool_exp
  owner_address: String_comparison_exp
  storage_id: String_comparison_exp
  token_standard: String_comparison_exp
}

"""
unique or primary key constraints on table "current_fungible_asset_balances"
"""
enum current_fungible_asset_balances_constraint {
  """
  unique or primary key constraint on columns "storage_id"
  """
  current_unified_fungible_asset_balances_pkey
}

"""
input type for incrementing numeric columns in table "current_fungible_asset_balances"
"""
input current_fungible_asset_balances_inc_input {
  amount_v1: numeric
  amount_v2: numeric
  last_transaction_version_v1: bigint
  last_transaction_version_v2: bigint
}

"""
input type for inserting data into table "current_fungible_asset_balances"
"""
input current_fungible_asset_balances_insert_input {
  amount_v1: numeric
  amount_v2: numeric
  asset_type_v1: String
  asset_type_v2: String
  inserted_at: timestamp
  is_frozen: Boolean
  is_primary: Boolean
  last_transaction_timestamp_v1: timestamp
  last_transaction_timestamp_v2: timestamp
  last_transaction_version_v1: bigint
  last_transaction_version_v2: bigint
  metadata: fungible_asset_metadata_obj_rel_insert_input
  owner_address: String
  storage_id: String
}

"""aggregate max on columns"""
type current_fungible_asset_balances_max_fields {
  amount: numeric
  amount_v1: numeric
  amount_v2: numeric
  asset_type: String
  asset_type_v1: String
  asset_type_v2: String
  inserted_at: timestamp
  last_transaction_timestamp: timestamp
  last_transaction_timestamp_v1: timestamp
  last_transaction_timestamp_v2: timestamp
  last_transaction_version: bigint
  last_transaction_version_v1: bigint
  last_transaction_version_v2: bigint
  owner_address: String
  storage_id: String
  token_standard: String
}

"""aggregate min on columns"""
type current_fungible_asset_balances_min_fields {
  amount: numeric
  amount_v1: numeric
  amount_v2: numeric
  asset_type: String
  asset_type_v1: String
  asset_type_v2: String
  inserted_at: timestamp
  last_transaction_timestamp: timestamp
  last_transaction_timestamp_v1: timestamp
  last_transaction_timestamp_v2: timestamp
  last_transaction_version: bigint
  last_transaction_version_v1: bigint
  last_transaction_version_v2: bigint
  owner_address: String
  storage_id: String
  token_standard: String
}

"""
response of any mutation on the table "current_fungible_asset_balances"
"""
type current_fungible_asset_balances_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [current_fungible_asset_balances!]!
}

"""
on_conflict condition type for table "current_fungible_asset_balances"
"""
input current_fungible_asset_balances_on_conflict {
  constraint: current_fungible_asset_balances_constraint!
  update_columns: [current_fungible_asset_balances_update_column!]! = []
  where: current_fungible_asset_balances_bool_exp
}

"""
Ordering options when selecting data from "current_fungible_asset_balances".
"""
input current_fungible_asset_balances_order_by {
  amount: order_by
  amount_v1: order_by
  amount_v2: order_by
  asset_type: order_by
  asset_type_v1: order_by
  asset_type_v2: order_by
  inserted_at: order_by
  is_frozen: order_by
  is_primary: order_by
  last_transaction_timestamp: order_by
  last_transaction_timestamp_v1: order_by
  last_transaction_timestamp_v2: order_by
  last_transaction_version: order_by
  last_transaction_version_v1: order_by
  last_transaction_version_v2: order_by
  metadata: fungible_asset_metadata_order_by
  owner_address: order_by
  storage_id: order_by
  token_standard: order_by
}

"""primary key columns input for table: current_fungible_asset_balances"""
input current_fungible_asset_balances_pk_columns_input {
  storage_id: String!
}

"""
select columns of table "current_fungible_asset_balances"
"""
enum current_fungible_asset_balances_select_column {
  """column name"""
  amount

  """column name"""
  amount_v1

  """column name"""
  amount_v2

  """column name"""
  asset_type

  """column name"""
  asset_type_v1

  """column name"""
  asset_type_v2

  """column name"""
  inserted_at

  """column name"""
  is_frozen

  """column name"""
  is_primary

  """column name"""
  last_transaction_timestamp

  """column name"""
  last_transaction_timestamp_v1

  """column name"""
  last_transaction_timestamp_v2

  """column name"""
  last_transaction_version

  """column name"""
  last_transaction_version_v1

  """column name"""
  last_transaction_version_v2

  """column name"""
  owner_address

  """column name"""
  storage_id

  """column name"""
  token_standard
}

"""
input type for updating data in table "current_fungible_asset_balances"
"""
input current_fungible_asset_balances_set_input {
  amount_v1: numeric
  amount_v2: numeric
  asset_type_v1: String
  asset_type_v2: String
  inserted_at: timestamp
  is_frozen: Boolean
  is_primary: Boolean
  last_transaction_timestamp_v1: timestamp
  last_transaction_timestamp_v2: timestamp
  last_transaction_version_v1: bigint
  last_transaction_version_v2: bigint
  owner_address: String
  storage_id: String
}

"""aggregate stddev on columns"""
type current_fungible_asset_balances_stddev_fields {
  amount: Float
  amount_v1: Float
  amount_v2: Float
  last_transaction_version: Float
  last_transaction_version_v1: Float
  last_transaction_version_v2: Float
}

"""aggregate stddev_pop on columns"""
type current_fungible_asset_balances_stddev_pop_fields {
  amount: Float
  amount_v1: Float
  amount_v2: Float
  last_transaction_version: Float
  last_transaction_version_v1: Float
  last_transaction_version_v2: Float
}

"""aggregate stddev_samp on columns"""
type current_fungible_asset_balances_stddev_samp_fields {
  amount: Float
  amount_v1: Float
  amount_v2: Float
  last_transaction_version: Float
  last_transaction_version_v1: Float
  last_transaction_version_v2: Float
}

"""
Streaming cursor of the table "current_fungible_asset_balances"
"""
input current_fungible_asset_balances_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: current_fungible_asset_balances_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input current_fungible_asset_balances_stream_cursor_value_input {
  amount: numeric
  amount_v1: numeric
  amount_v2: numeric
  asset_type: String
  asset_type_v1: String
  asset_type_v2: String
  inserted_at: timestamp
  is_frozen: Boolean
  is_primary: Boolean
  last_transaction_timestamp: timestamp
  last_transaction_timestamp_v1: timestamp
  last_transaction_timestamp_v2: timestamp
  last_transaction_version: bigint
  last_transaction_version_v1: bigint
  last_transaction_version_v2: bigint
  owner_address: String
  storage_id: String
  token_standard: String
}

"""aggregate sum on columns"""
type current_fungible_asset_balances_sum_fields {
  amount: numeric
  amount_v1: numeric
  amount_v2: numeric
  last_transaction_version: bigint
  last_transaction_version_v1: bigint
  last_transaction_version_v2: bigint
}

"""
update columns of table "current_fungible_asset_balances"
"""
enum current_fungible_asset_balances_update_column {
  """column name"""
  amount_v1

  """column name"""
  amount_v2

  """column name"""
  asset_type_v1

  """column name"""
  asset_type_v2

  """column name"""
  inserted_at

  """column name"""
  is_frozen

  """column name"""
  is_primary

  """column name"""
  last_transaction_timestamp_v1

  """column name"""
  last_transaction_timestamp_v2

  """column name"""
  last_transaction_version_v1

  """column name"""
  last_transaction_version_v2

  """column name"""
  owner_address

  """column name"""
  storage_id
}

input current_fungible_asset_balances_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: current_fungible_asset_balances_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: current_fungible_asset_balances_set_input

  """filter the rows which have to be updated"""
  where: current_fungible_asset_balances_bool_exp!
}

"""aggregate var_pop on columns"""
type current_fungible_asset_balances_var_pop_fields {
  amount: Float
  amount_v1: Float
  amount_v2: Float
  last_transaction_version: Float
  last_transaction_version_v1: Float
  last_transaction_version_v2: Float
}

"""aggregate var_samp on columns"""
type current_fungible_asset_balances_var_samp_fields {
  amount: Float
  amount_v1: Float
  amount_v2: Float
  last_transaction_version: Float
  last_transaction_version_v1: Float
  last_transaction_version_v2: Float
}

"""aggregate variance on columns"""
type current_fungible_asset_balances_variance_fields {
  amount: Float
  amount_v1: Float
  amount_v2: Float
  last_transaction_version: Float
  last_transaction_version_v1: Float
  last_transaction_version_v2: Float
}

"""
columns and relationships of "current_objects"
"""
type current_objects {
  allow_ungated_transfer: Boolean!
  inserted_at: timestamp!
  is_deleted: Boolean!
  last_guid_creation_num: numeric!
  last_transaction_version: bigint!
  object_address: String!
  owner_address: String!
  state_key_hash: String!
  untransferrable: Boolean!
}

"""
aggregated selection of "current_objects"
"""
type current_objects_aggregate {
  aggregate: current_objects_aggregate_fields
  nodes: [current_objects!]!
}

"""
aggregate fields of "current_objects"
"""
type current_objects_aggregate_fields {
  avg: current_objects_avg_fields
  count(columns: [current_objects_select_column!], distinct: Boolean): Int!
  max: current_objects_max_fields
  min: current_objects_min_fields
  stddev: current_objects_stddev_fields
  stddev_pop: current_objects_stddev_pop_fields
  stddev_samp: current_objects_stddev_samp_fields
  sum: current_objects_sum_fields
  var_pop: current_objects_var_pop_fields
  var_samp: current_objects_var_samp_fields
  variance: current_objects_variance_fields
}

"""aggregate avg on columns"""
type current_objects_avg_fields {
  last_guid_creation_num: Float
  last_transaction_version: Float
}

"""
Boolean expression to filter rows from the table "current_objects". All fields are combined with a logical 'AND'.
"""
input current_objects_bool_exp {
  _and: [current_objects_bool_exp!]
  _not: current_objects_bool_exp
  _or: [current_objects_bool_exp!]
  allow_ungated_transfer: Boolean_comparison_exp
  inserted_at: timestamp_comparison_exp
  is_deleted: Boolean_comparison_exp
  last_guid_creation_num: numeric_comparison_exp
  last_transaction_version: bigint_comparison_exp
  object_address: String_comparison_exp
  owner_address: String_comparison_exp
  state_key_hash: String_comparison_exp
  untransferrable: Boolean_comparison_exp
}

"""
unique or primary key constraints on table "current_objects"
"""
enum current_objects_constraint {
  """
  unique or primary key constraint on columns "object_address"
  """
  current_objects_pkey
}

"""
input type for incrementing numeric columns in table "current_objects"
"""
input current_objects_inc_input {
  last_guid_creation_num: numeric
  last_transaction_version: bigint
}

"""
input type for inserting data into table "current_objects"
"""
input current_objects_insert_input {
  allow_ungated_transfer: Boolean
  inserted_at: timestamp
  is_deleted: Boolean
  last_guid_creation_num: numeric
  last_transaction_version: bigint
  object_address: String
  owner_address: String
  state_key_hash: String
  untransferrable: Boolean
}

"""aggregate max on columns"""
type current_objects_max_fields {
  inserted_at: timestamp
  last_guid_creation_num: numeric
  last_transaction_version: bigint
  object_address: String
  owner_address: String
  state_key_hash: String
}

"""aggregate min on columns"""
type current_objects_min_fields {
  inserted_at: timestamp
  last_guid_creation_num: numeric
  last_transaction_version: bigint
  object_address: String
  owner_address: String
  state_key_hash: String
}

"""
response of any mutation on the table "current_objects"
"""
type current_objects_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [current_objects!]!
}

"""
on_conflict condition type for table "current_objects"
"""
input current_objects_on_conflict {
  constraint: current_objects_constraint!
  update_columns: [current_objects_update_column!]! = []
  where: current_objects_bool_exp
}

"""Ordering options when selecting data from "current_objects"."""
input current_objects_order_by {
  allow_ungated_transfer: order_by
  inserted_at: order_by
  is_deleted: order_by
  last_guid_creation_num: order_by
  last_transaction_version: order_by
  object_address: order_by
  owner_address: order_by
  state_key_hash: order_by
  untransferrable: order_by
}

"""primary key columns input for table: current_objects"""
input current_objects_pk_columns_input {
  object_address: String!
}

"""
select columns of table "current_objects"
"""
enum current_objects_select_column {
  """column name"""
  allow_ungated_transfer

  """column name"""
  inserted_at

  """column name"""
  is_deleted

  """column name"""
  last_guid_creation_num

  """column name"""
  last_transaction_version

  """column name"""
  object_address

  """column name"""
  owner_address

  """column name"""
  state_key_hash

  """column name"""
  untransferrable
}

"""
input type for updating data in table "current_objects"
"""
input current_objects_set_input {
  allow_ungated_transfer: Boolean
  inserted_at: timestamp
  is_deleted: Boolean
  last_guid_creation_num: numeric
  last_transaction_version: bigint
  object_address: String
  owner_address: String
  state_key_hash: String
  untransferrable: Boolean
}

"""aggregate stddev on columns"""
type current_objects_stddev_fields {
  last_guid_creation_num: Float
  last_transaction_version: Float
}

"""aggregate stddev_pop on columns"""
type current_objects_stddev_pop_fields {
  last_guid_creation_num: Float
  last_transaction_version: Float
}

"""aggregate stddev_samp on columns"""
type current_objects_stddev_samp_fields {
  last_guid_creation_num: Float
  last_transaction_version: Float
}

"""
Streaming cursor of the table "current_objects"
"""
input current_objects_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: current_objects_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input current_objects_stream_cursor_value_input {
  allow_ungated_transfer: Boolean
  inserted_at: timestamp
  is_deleted: Boolean
  last_guid_creation_num: numeric
  last_transaction_version: bigint
  object_address: String
  owner_address: String
  state_key_hash: String
  untransferrable: Boolean
}

"""aggregate sum on columns"""
type current_objects_sum_fields {
  last_guid_creation_num: numeric
  last_transaction_version: bigint
}

"""
update columns of table "current_objects"
"""
enum current_objects_update_column {
  """column name"""
  allow_ungated_transfer

  """column name"""
  inserted_at

  """column name"""
  is_deleted

  """column name"""
  last_guid_creation_num

  """column name"""
  last_transaction_version

  """column name"""
  object_address

  """column name"""
  owner_address

  """column name"""
  state_key_hash

  """column name"""
  untransferrable
}

input current_objects_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: current_objects_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: current_objects_set_input

  """filter the rows which have to be updated"""
  where: current_objects_bool_exp!
}

"""aggregate var_pop on columns"""
type current_objects_var_pop_fields {
  last_guid_creation_num: Float
  last_transaction_version: Float
}

"""aggregate var_samp on columns"""
type current_objects_var_samp_fields {
  last_guid_creation_num: Float
  last_transaction_version: Float
}

"""aggregate variance on columns"""
type current_objects_variance_fields {
  last_guid_creation_num: Float
  last_transaction_version: Float
}

"""
columns and relationships of "current_staking_pool_voter"
"""
type current_staking_pool_voter {
  inserted_at: timestamp!
  last_transaction_version: bigint!
  operator_address: String!

  """An array relationship"""
  operator_aptos_name(
    """distinct select on columns"""
    distinct_on: [current_aptos_names_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_aptos_names_order_by!]

    """filter the rows returned"""
    where: current_aptos_names_bool_exp
  ): [current_aptos_names!]!

  """An aggregate relationship"""
  operator_aptos_name_aggregate(
    """distinct select on columns"""
    distinct_on: [current_aptos_names_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_aptos_names_order_by!]

    """filter the rows returned"""
    where: current_aptos_names_bool_exp
  ): current_aptos_names_aggregate!
  staking_pool_address: String!
  voter_address: String!
}

"""
aggregated selection of "current_staking_pool_voter"
"""
type current_staking_pool_voter_aggregate {
  aggregate: current_staking_pool_voter_aggregate_fields
  nodes: [current_staking_pool_voter!]!
}

"""
aggregate fields of "current_staking_pool_voter"
"""
type current_staking_pool_voter_aggregate_fields {
  avg: current_staking_pool_voter_avg_fields
  count(columns: [current_staking_pool_voter_select_column!], distinct: Boolean): Int!
  max: current_staking_pool_voter_max_fields
  min: current_staking_pool_voter_min_fields
  stddev: current_staking_pool_voter_stddev_fields
  stddev_pop: current_staking_pool_voter_stddev_pop_fields
  stddev_samp: current_staking_pool_voter_stddev_samp_fields
  sum: current_staking_pool_voter_sum_fields
  var_pop: current_staking_pool_voter_var_pop_fields
  var_samp: current_staking_pool_voter_var_samp_fields
  variance: current_staking_pool_voter_variance_fields
}

"""aggregate avg on columns"""
type current_staking_pool_voter_avg_fields {
  last_transaction_version: Float
}

"""
Boolean expression to filter rows from the table "current_staking_pool_voter". All fields are combined with a logical 'AND'.
"""
input current_staking_pool_voter_bool_exp {
  _and: [current_staking_pool_voter_bool_exp!]
  _not: current_staking_pool_voter_bool_exp
  _or: [current_staking_pool_voter_bool_exp!]
  inserted_at: timestamp_comparison_exp
  last_transaction_version: bigint_comparison_exp
  operator_address: String_comparison_exp
  operator_aptos_name: current_aptos_names_bool_exp
  operator_aptos_name_aggregate: current_aptos_names_aggregate_bool_exp
  staking_pool_address: String_comparison_exp
  voter_address: String_comparison_exp
}

"""
unique or primary key constraints on table "current_staking_pool_voter"
"""
enum current_staking_pool_voter_constraint {
  """
  unique or primary key constraint on columns "staking_pool_address"
  """
  current_staking_pool_voter_pkey
}

"""
input type for incrementing numeric columns in table "current_staking_pool_voter"
"""
input current_staking_pool_voter_inc_input {
  last_transaction_version: bigint
}

"""
input type for inserting data into table "current_staking_pool_voter"
"""
input current_staking_pool_voter_insert_input {
  inserted_at: timestamp
  last_transaction_version: bigint
  operator_address: String
  operator_aptos_name: current_aptos_names_arr_rel_insert_input
  staking_pool_address: String
  voter_address: String
}

"""aggregate max on columns"""
type current_staking_pool_voter_max_fields {
  inserted_at: timestamp
  last_transaction_version: bigint
  operator_address: String
  staking_pool_address: String
  voter_address: String
}

"""aggregate min on columns"""
type current_staking_pool_voter_min_fields {
  inserted_at: timestamp
  last_transaction_version: bigint
  operator_address: String
  staking_pool_address: String
  voter_address: String
}

"""
response of any mutation on the table "current_staking_pool_voter"
"""
type current_staking_pool_voter_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [current_staking_pool_voter!]!
}

"""
input type for inserting object relation for remote table "current_staking_pool_voter"
"""
input current_staking_pool_voter_obj_rel_insert_input {
  data: current_staking_pool_voter_insert_input!

  """upsert condition"""
  on_conflict: current_staking_pool_voter_on_conflict
}

"""
on_conflict condition type for table "current_staking_pool_voter"
"""
input current_staking_pool_voter_on_conflict {
  constraint: current_staking_pool_voter_constraint!
  update_columns: [current_staking_pool_voter_update_column!]! = []
  where: current_staking_pool_voter_bool_exp
}

"""
Ordering options when selecting data from "current_staking_pool_voter".
"""
input current_staking_pool_voter_order_by {
  inserted_at: order_by
  last_transaction_version: order_by
  operator_address: order_by
  operator_aptos_name_aggregate: current_aptos_names_aggregate_order_by
  staking_pool_address: order_by
  voter_address: order_by
}

"""primary key columns input for table: current_staking_pool_voter"""
input current_staking_pool_voter_pk_columns_input {
  staking_pool_address: String!
}

"""
select columns of table "current_staking_pool_voter"
"""
enum current_staking_pool_voter_select_column {
  """column name"""
  inserted_at

  """column name"""
  last_transaction_version

  """column name"""
  operator_address

  """column name"""
  staking_pool_address

  """column name"""
  voter_address
}

"""
input type for updating data in table "current_staking_pool_voter"
"""
input current_staking_pool_voter_set_input {
  inserted_at: timestamp
  last_transaction_version: bigint
  operator_address: String
  staking_pool_address: String
  voter_address: String
}

"""aggregate stddev on columns"""
type current_staking_pool_voter_stddev_fields {
  last_transaction_version: Float
}

"""aggregate stddev_pop on columns"""
type current_staking_pool_voter_stddev_pop_fields {
  last_transaction_version: Float
}

"""aggregate stddev_samp on columns"""
type current_staking_pool_voter_stddev_samp_fields {
  last_transaction_version: Float
}

"""
Streaming cursor of the table "current_staking_pool_voter"
"""
input current_staking_pool_voter_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: current_staking_pool_voter_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input current_staking_pool_voter_stream_cursor_value_input {
  inserted_at: timestamp
  last_transaction_version: bigint
  operator_address: String
  staking_pool_address: String
  voter_address: String
}

"""aggregate sum on columns"""
type current_staking_pool_voter_sum_fields {
  last_transaction_version: bigint
}

"""
update columns of table "current_staking_pool_voter"
"""
enum current_staking_pool_voter_update_column {
  """column name"""
  inserted_at

  """column name"""
  last_transaction_version

  """column name"""
  operator_address

  """column name"""
  staking_pool_address

  """column name"""
  voter_address
}

input current_staking_pool_voter_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: current_staking_pool_voter_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: current_staking_pool_voter_set_input

  """filter the rows which have to be updated"""
  where: current_staking_pool_voter_bool_exp!
}

"""aggregate var_pop on columns"""
type current_staking_pool_voter_var_pop_fields {
  last_transaction_version: Float
}

"""aggregate var_samp on columns"""
type current_staking_pool_voter_var_samp_fields {
  last_transaction_version: Float
}

"""aggregate variance on columns"""
type current_staking_pool_voter_variance_fields {
  last_transaction_version: Float
}

"""
columns and relationships of "current_table_items"
"""
type current_table_items {
  decoded_key(
    """JSON select path"""
    path: String
  ): jsonb!
  decoded_value(
    """JSON select path"""
    path: String
  ): jsonb
  inserted_at: timestamp!
  is_deleted: Boolean!
  key: String!
  key_hash: String!
  last_transaction_version: bigint!
  table_handle: String!
}

"""
aggregated selection of "current_table_items"
"""
type current_table_items_aggregate {
  aggregate: current_table_items_aggregate_fields
  nodes: [current_table_items!]!
}

"""
aggregate fields of "current_table_items"
"""
type current_table_items_aggregate_fields {
  avg: current_table_items_avg_fields
  count(columns: [current_table_items_select_column!], distinct: Boolean): Int!
  max: current_table_items_max_fields
  min: current_table_items_min_fields
  stddev: current_table_items_stddev_fields
  stddev_pop: current_table_items_stddev_pop_fields
  stddev_samp: current_table_items_stddev_samp_fields
  sum: current_table_items_sum_fields
  var_pop: current_table_items_var_pop_fields
  var_samp: current_table_items_var_samp_fields
  variance: current_table_items_variance_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input current_table_items_append_input {
  decoded_key: jsonb
  decoded_value: jsonb
}

"""aggregate avg on columns"""
type current_table_items_avg_fields {
  last_transaction_version: Float
}

"""
Boolean expression to filter rows from the table "current_table_items". All fields are combined with a logical 'AND'.
"""
input current_table_items_bool_exp {
  _and: [current_table_items_bool_exp!]
  _not: current_table_items_bool_exp
  _or: [current_table_items_bool_exp!]
  decoded_key: jsonb_comparison_exp
  decoded_value: jsonb_comparison_exp
  inserted_at: timestamp_comparison_exp
  is_deleted: Boolean_comparison_exp
  key: String_comparison_exp
  key_hash: String_comparison_exp
  last_transaction_version: bigint_comparison_exp
  table_handle: String_comparison_exp
}

"""
unique or primary key constraints on table "current_table_items"
"""
enum current_table_items_constraint {
  """
  unique or primary key constraint on columns "key_hash", "table_handle"
  """
  current_table_items_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input current_table_items_delete_at_path_input {
  decoded_key: [String!]
  decoded_value: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input current_table_items_delete_elem_input {
  decoded_key: Int
  decoded_value: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input current_table_items_delete_key_input {
  decoded_key: String
  decoded_value: String
}

"""
input type for incrementing numeric columns in table "current_table_items"
"""
input current_table_items_inc_input {
  last_transaction_version: bigint
}

"""
input type for inserting data into table "current_table_items"
"""
input current_table_items_insert_input {
  decoded_key: jsonb
  decoded_value: jsonb
  inserted_at: timestamp
  is_deleted: Boolean
  key: String
  key_hash: String
  last_transaction_version: bigint
  table_handle: String
}

"""aggregate max on columns"""
type current_table_items_max_fields {
  inserted_at: timestamp
  key: String
  key_hash: String
  last_transaction_version: bigint
  table_handle: String
}

"""aggregate min on columns"""
type current_table_items_min_fields {
  inserted_at: timestamp
  key: String
  key_hash: String
  last_transaction_version: bigint
  table_handle: String
}

"""
response of any mutation on the table "current_table_items"
"""
type current_table_items_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [current_table_items!]!
}

"""
on_conflict condition type for table "current_table_items"
"""
input current_table_items_on_conflict {
  constraint: current_table_items_constraint!
  update_columns: [current_table_items_update_column!]! = []
  where: current_table_items_bool_exp
}

"""Ordering options when selecting data from "current_table_items"."""
input current_table_items_order_by {
  decoded_key: order_by
  decoded_value: order_by
  inserted_at: order_by
  is_deleted: order_by
  key: order_by
  key_hash: order_by
  last_transaction_version: order_by
  table_handle: order_by
}

"""primary key columns input for table: current_table_items"""
input current_table_items_pk_columns_input {
  key_hash: String!
  table_handle: String!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input current_table_items_prepend_input {
  decoded_key: jsonb
  decoded_value: jsonb
}

"""
select columns of table "current_table_items"
"""
enum current_table_items_select_column {
  """column name"""
  decoded_key

  """column name"""
  decoded_value

  """column name"""
  inserted_at

  """column name"""
  is_deleted

  """column name"""
  key

  """column name"""
  key_hash

  """column name"""
  last_transaction_version

  """column name"""
  table_handle
}

"""
input type for updating data in table "current_table_items"
"""
input current_table_items_set_input {
  decoded_key: jsonb
  decoded_value: jsonb
  inserted_at: timestamp
  is_deleted: Boolean
  key: String
  key_hash: String
  last_transaction_version: bigint
  table_handle: String
}

"""aggregate stddev on columns"""
type current_table_items_stddev_fields {
  last_transaction_version: Float
}

"""aggregate stddev_pop on columns"""
type current_table_items_stddev_pop_fields {
  last_transaction_version: Float
}

"""aggregate stddev_samp on columns"""
type current_table_items_stddev_samp_fields {
  last_transaction_version: Float
}

"""
Streaming cursor of the table "current_table_items"
"""
input current_table_items_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: current_table_items_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input current_table_items_stream_cursor_value_input {
  decoded_key: jsonb
  decoded_value: jsonb
  inserted_at: timestamp
  is_deleted: Boolean
  key: String
  key_hash: String
  last_transaction_version: bigint
  table_handle: String
}

"""aggregate sum on columns"""
type current_table_items_sum_fields {
  last_transaction_version: bigint
}

"""
update columns of table "current_table_items"
"""
enum current_table_items_update_column {
  """column name"""
  decoded_key

  """column name"""
  decoded_value

  """column name"""
  inserted_at

  """column name"""
  is_deleted

  """column name"""
  key

  """column name"""
  key_hash

  """column name"""
  last_transaction_version

  """column name"""
  table_handle
}

input current_table_items_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: current_table_items_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: current_table_items_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: current_table_items_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: current_table_items_delete_key_input

  """increments the numeric columns with given value of the filtered values"""
  _inc: current_table_items_inc_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: current_table_items_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: current_table_items_set_input

  """filter the rows which have to be updated"""
  where: current_table_items_bool_exp!
}

"""aggregate var_pop on columns"""
type current_table_items_var_pop_fields {
  last_transaction_version: Float
}

"""aggregate var_samp on columns"""
type current_table_items_var_samp_fields {
  last_transaction_version: Float
}

"""aggregate variance on columns"""
type current_table_items_variance_fields {
  last_transaction_version: Float
}

"""
columns and relationships of "legacy_migration_v1.current_token_datas"
"""
type current_token_datas {
  collection_data_id_hash: String
  collection_name: String
  creator_address: String

  """An object relationship"""
  current_collection_data: current_collection_datas
  default_properties(
    """JSON select path"""
    path: String
  ): jsonb
  description: String
  description_mutable: Boolean
  inserted_at: timestamp
  largest_property_version: numeric
  last_transaction_timestamp: timestamp
  last_transaction_version: bigint
  maximum: numeric
  maximum_mutable: Boolean
  metadata_uri: String
  name: String
  payee_address: String
  properties_mutable: Boolean
  royalty_mutable: Boolean
  royalty_points_denominator: numeric
  royalty_points_numerator: numeric
  supply: numeric
  token_data_id_hash: String
  uri_mutable: Boolean
}

"""
aggregated selection of "legacy_migration_v1.current_token_datas"
"""
type current_token_datas_aggregate {
  aggregate: current_token_datas_aggregate_fields
  nodes: [current_token_datas!]!
}

"""
aggregate fields of "legacy_migration_v1.current_token_datas"
"""
type current_token_datas_aggregate_fields {
  avg: current_token_datas_avg_fields
  count(columns: [current_token_datas_select_column!], distinct: Boolean): Int!
  max: current_token_datas_max_fields
  min: current_token_datas_min_fields
  stddev: current_token_datas_stddev_fields
  stddev_pop: current_token_datas_stddev_pop_fields
  stddev_samp: current_token_datas_stddev_samp_fields
  sum: current_token_datas_sum_fields
  var_pop: current_token_datas_var_pop_fields
  var_samp: current_token_datas_var_samp_fields
  variance: current_token_datas_variance_fields
}

"""aggregate avg on columns"""
type current_token_datas_avg_fields {
  largest_property_version: Float
  last_transaction_version: Float
  maximum: Float
  royalty_points_denominator: Float
  royalty_points_numerator: Float
  supply: Float
}

"""
Boolean expression to filter rows from the table "legacy_migration_v1.current_token_datas". All fields are combined with a logical 'AND'.
"""
input current_token_datas_bool_exp {
  _and: [current_token_datas_bool_exp!]
  _not: current_token_datas_bool_exp
  _or: [current_token_datas_bool_exp!]
  collection_data_id_hash: String_comparison_exp
  collection_name: String_comparison_exp
  creator_address: String_comparison_exp
  current_collection_data: current_collection_datas_bool_exp
  default_properties: jsonb_comparison_exp
  description: String_comparison_exp
  description_mutable: Boolean_comparison_exp
  inserted_at: timestamp_comparison_exp
  largest_property_version: numeric_comparison_exp
  last_transaction_timestamp: timestamp_comparison_exp
  last_transaction_version: bigint_comparison_exp
  maximum: numeric_comparison_exp
  maximum_mutable: Boolean_comparison_exp
  metadata_uri: String_comparison_exp
  name: String_comparison_exp
  payee_address: String_comparison_exp
  properties_mutable: Boolean_comparison_exp
  royalty_mutable: Boolean_comparison_exp
  royalty_points_denominator: numeric_comparison_exp
  royalty_points_numerator: numeric_comparison_exp
  supply: numeric_comparison_exp
  token_data_id_hash: String_comparison_exp
  uri_mutable: Boolean_comparison_exp
}

"""
input type for inserting data into table "legacy_migration_v1.current_token_datas"
"""
input current_token_datas_insert_input {
  collection_data_id_hash: String
  collection_name: String
  creator_address: String
  current_collection_data: current_collection_datas_obj_rel_insert_input
  default_properties: jsonb
  description: String
  description_mutable: Boolean
  inserted_at: timestamp
  largest_property_version: numeric
  last_transaction_timestamp: timestamp
  last_transaction_version: bigint
  maximum: numeric
  maximum_mutable: Boolean
  metadata_uri: String
  name: String
  payee_address: String
  properties_mutable: Boolean
  royalty_mutable: Boolean
  royalty_points_denominator: numeric
  royalty_points_numerator: numeric
  supply: numeric
  token_data_id_hash: String
  uri_mutable: Boolean
}

"""aggregate max on columns"""
type current_token_datas_max_fields {
  collection_data_id_hash: String
  collection_name: String
  creator_address: String
  description: String
  inserted_at: timestamp
  largest_property_version: numeric
  last_transaction_timestamp: timestamp
  last_transaction_version: bigint
  maximum: numeric
  metadata_uri: String
  name: String
  payee_address: String
  royalty_points_denominator: numeric
  royalty_points_numerator: numeric
  supply: numeric
  token_data_id_hash: String
}

"""aggregate min on columns"""
type current_token_datas_min_fields {
  collection_data_id_hash: String
  collection_name: String
  creator_address: String
  description: String
  inserted_at: timestamp
  largest_property_version: numeric
  last_transaction_timestamp: timestamp
  last_transaction_version: bigint
  maximum: numeric
  metadata_uri: String
  name: String
  payee_address: String
  royalty_points_denominator: numeric
  royalty_points_numerator: numeric
  supply: numeric
  token_data_id_hash: String
}

"""
input type for inserting object relation for remote table "legacy_migration_v1.current_token_datas"
"""
input current_token_datas_obj_rel_insert_input {
  data: current_token_datas_insert_input!
}

"""
Ordering options when selecting data from "legacy_migration_v1.current_token_datas".
"""
input current_token_datas_order_by {
  collection_data_id_hash: order_by
  collection_name: order_by
  creator_address: order_by
  current_collection_data: current_collection_datas_order_by
  default_properties: order_by
  description: order_by
  description_mutable: order_by
  inserted_at: order_by
  largest_property_version: order_by
  last_transaction_timestamp: order_by
  last_transaction_version: order_by
  maximum: order_by
  maximum_mutable: order_by
  metadata_uri: order_by
  name: order_by
  payee_address: order_by
  properties_mutable: order_by
  royalty_mutable: order_by
  royalty_points_denominator: order_by
  royalty_points_numerator: order_by
  supply: order_by
  token_data_id_hash: order_by
  uri_mutable: order_by
}

"""
select columns of table "legacy_migration_v1.current_token_datas"
"""
enum current_token_datas_select_column {
  """column name"""
  collection_data_id_hash

  """column name"""
  collection_name

  """column name"""
  creator_address

  """column name"""
  default_properties

  """column name"""
  description

  """column name"""
  description_mutable

  """column name"""
  inserted_at

  """column name"""
  largest_property_version

  """column name"""
  last_transaction_timestamp

  """column name"""
  last_transaction_version

  """column name"""
  maximum

  """column name"""
  maximum_mutable

  """column name"""
  metadata_uri

  """column name"""
  name

  """column name"""
  payee_address

  """column name"""
  properties_mutable

  """column name"""
  royalty_mutable

  """column name"""
  royalty_points_denominator

  """column name"""
  royalty_points_numerator

  """column name"""
  supply

  """column name"""
  token_data_id_hash

  """column name"""
  uri_mutable
}

"""aggregate stddev on columns"""
type current_token_datas_stddev_fields {
  largest_property_version: Float
  last_transaction_version: Float
  maximum: Float
  royalty_points_denominator: Float
  royalty_points_numerator: Float
  supply: Float
}

"""aggregate stddev_pop on columns"""
type current_token_datas_stddev_pop_fields {
  largest_property_version: Float
  last_transaction_version: Float
  maximum: Float
  royalty_points_denominator: Float
  royalty_points_numerator: Float
  supply: Float
}

"""aggregate stddev_samp on columns"""
type current_token_datas_stddev_samp_fields {
  largest_property_version: Float
  last_transaction_version: Float
  maximum: Float
  royalty_points_denominator: Float
  royalty_points_numerator: Float
  supply: Float
}

"""
Streaming cursor of the table "current_token_datas"
"""
input current_token_datas_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: current_token_datas_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input current_token_datas_stream_cursor_value_input {
  collection_data_id_hash: String
  collection_name: String
  creator_address: String
  default_properties: jsonb
  description: String
  description_mutable: Boolean
  inserted_at: timestamp
  largest_property_version: numeric
  last_transaction_timestamp: timestamp
  last_transaction_version: bigint
  maximum: numeric
  maximum_mutable: Boolean
  metadata_uri: String
  name: String
  payee_address: String
  properties_mutable: Boolean
  royalty_mutable: Boolean
  royalty_points_denominator: numeric
  royalty_points_numerator: numeric
  supply: numeric
  token_data_id_hash: String
  uri_mutable: Boolean
}

"""aggregate sum on columns"""
type current_token_datas_sum_fields {
  largest_property_version: numeric
  last_transaction_version: bigint
  maximum: numeric
  royalty_points_denominator: numeric
  royalty_points_numerator: numeric
  supply: numeric
}

"""
columns and relationships of "current_token_datas_v2"
"""
type current_token_datas_v2 {
  """An object relationship"""
  aptos_name: current_aptos_names

  """An object relationship"""
  cdn_asset_uris: nft_metadata_crawler_parsed_asset_uris
  collection_id: String!

  """An object relationship"""
  current_collection: current_collections_v2

  """An object relationship"""
  current_royalty_v1: current_token_royalty_v1

  """An array relationship"""
  current_token_ownerships(
    """distinct select on columns"""
    distinct_on: [current_token_ownerships_v2_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_token_ownerships_v2_order_by!]

    """filter the rows returned"""
    where: current_token_ownerships_v2_bool_exp
  ): [current_token_ownerships_v2!]!

  """An aggregate relationship"""
  current_token_ownerships_aggregate(
    """distinct select on columns"""
    distinct_on: [current_token_ownerships_v2_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_token_ownerships_v2_order_by!]

    """filter the rows returned"""
    where: current_token_ownerships_v2_bool_exp
  ): current_token_ownerships_v2_aggregate!
  decimals: bigint
  description: String!
  inserted_at: timestamp!
  is_deleted_v2: Boolean
  is_fungible_v2: Boolean
  largest_property_version_v1: numeric
  last_transaction_timestamp: timestamp!
  last_transaction_version: bigint!
  maximum: numeric
  supply: numeric
  token_data_id: String!
  token_name: String!
  token_properties(
    """JSON select path"""
    path: String
  ): jsonb!
  token_standard: String!
  token_uri: String!
}

"""
aggregated selection of "current_token_datas_v2"
"""
type current_token_datas_v2_aggregate {
  aggregate: current_token_datas_v2_aggregate_fields
  nodes: [current_token_datas_v2!]!
}

"""
aggregate fields of "current_token_datas_v2"
"""
type current_token_datas_v2_aggregate_fields {
  avg: current_token_datas_v2_avg_fields
  count(columns: [current_token_datas_v2_select_column!], distinct: Boolean): Int!
  max: current_token_datas_v2_max_fields
  min: current_token_datas_v2_min_fields
  stddev: current_token_datas_v2_stddev_fields
  stddev_pop: current_token_datas_v2_stddev_pop_fields
  stddev_samp: current_token_datas_v2_stddev_samp_fields
  sum: current_token_datas_v2_sum_fields
  var_pop: current_token_datas_v2_var_pop_fields
  var_samp: current_token_datas_v2_var_samp_fields
  variance: current_token_datas_v2_variance_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input current_token_datas_v2_append_input {
  token_properties: jsonb
}

"""aggregate avg on columns"""
type current_token_datas_v2_avg_fields {
  decimals: Float
  largest_property_version_v1: Float
  last_transaction_version: Float
  maximum: Float
  supply: Float
}

"""
Boolean expression to filter rows from the table "current_token_datas_v2". All fields are combined with a logical 'AND'.
"""
input current_token_datas_v2_bool_exp {
  _and: [current_token_datas_v2_bool_exp!]
  _not: current_token_datas_v2_bool_exp
  _or: [current_token_datas_v2_bool_exp!]
  aptos_name: current_aptos_names_bool_exp
  cdn_asset_uris: nft_metadata_crawler_parsed_asset_uris_bool_exp
  collection_id: String_comparison_exp
  current_collection: current_collections_v2_bool_exp
  current_royalty_v1: current_token_royalty_v1_bool_exp
  current_token_ownerships: current_token_ownerships_v2_bool_exp
  current_token_ownerships_aggregate: current_token_ownerships_v2_aggregate_bool_exp
  decimals: bigint_comparison_exp
  description: String_comparison_exp
  inserted_at: timestamp_comparison_exp
  is_deleted_v2: Boolean_comparison_exp
  is_fungible_v2: Boolean_comparison_exp
  largest_property_version_v1: numeric_comparison_exp
  last_transaction_timestamp: timestamp_comparison_exp
  last_transaction_version: bigint_comparison_exp
  maximum: numeric_comparison_exp
  supply: numeric_comparison_exp
  token_data_id: String_comparison_exp
  token_name: String_comparison_exp
  token_properties: jsonb_comparison_exp
  token_standard: String_comparison_exp
  token_uri: String_comparison_exp
}

"""
unique or primary key constraints on table "current_token_datas_v2"
"""
enum current_token_datas_v2_constraint {
  """
  unique or primary key constraint on columns "token_data_id"
  """
  current_token_datas_v2_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input current_token_datas_v2_delete_at_path_input {
  token_properties: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input current_token_datas_v2_delete_elem_input {
  token_properties: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input current_token_datas_v2_delete_key_input {
  token_properties: String
}

"""
input type for incrementing numeric columns in table "current_token_datas_v2"
"""
input current_token_datas_v2_inc_input {
  decimals: bigint
  largest_property_version_v1: numeric
  last_transaction_version: bigint
  maximum: numeric
  supply: numeric
}

"""
input type for inserting data into table "current_token_datas_v2"
"""
input current_token_datas_v2_insert_input {
  aptos_name: current_aptos_names_obj_rel_insert_input
  cdn_asset_uris: nft_metadata_crawler_parsed_asset_uris_obj_rel_insert_input
  collection_id: String
  current_collection: current_collections_v2_obj_rel_insert_input
  current_royalty_v1: current_token_royalty_v1_obj_rel_insert_input
  current_token_ownerships: current_token_ownerships_v2_arr_rel_insert_input
  decimals: bigint
  description: String
  inserted_at: timestamp
  is_deleted_v2: Boolean
  is_fungible_v2: Boolean
  largest_property_version_v1: numeric
  last_transaction_timestamp: timestamp
  last_transaction_version: bigint
  maximum: numeric
  supply: numeric
  token_data_id: String
  token_name: String
  token_properties: jsonb
  token_standard: String
  token_uri: String
}

"""aggregate max on columns"""
type current_token_datas_v2_max_fields {
  collection_id: String
  decimals: bigint
  description: String
  inserted_at: timestamp
  largest_property_version_v1: numeric
  last_transaction_timestamp: timestamp
  last_transaction_version: bigint
  maximum: numeric
  supply: numeric
  token_data_id: String
  token_name: String
  token_standard: String
  token_uri: String
}

"""aggregate min on columns"""
type current_token_datas_v2_min_fields {
  collection_id: String
  decimals: bigint
  description: String
  inserted_at: timestamp
  largest_property_version_v1: numeric
  last_transaction_timestamp: timestamp
  last_transaction_version: bigint
  maximum: numeric
  supply: numeric
  token_data_id: String
  token_name: String
  token_standard: String
  token_uri: String
}

"""
response of any mutation on the table "current_token_datas_v2"
"""
type current_token_datas_v2_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [current_token_datas_v2!]!
}

"""
input type for inserting object relation for remote table "current_token_datas_v2"
"""
input current_token_datas_v2_obj_rel_insert_input {
  data: current_token_datas_v2_insert_input!

  """upsert condition"""
  on_conflict: current_token_datas_v2_on_conflict
}

"""
on_conflict condition type for table "current_token_datas_v2"
"""
input current_token_datas_v2_on_conflict {
  constraint: current_token_datas_v2_constraint!
  update_columns: [current_token_datas_v2_update_column!]! = []
  where: current_token_datas_v2_bool_exp
}

"""Ordering options when selecting data from "current_token_datas_v2"."""
input current_token_datas_v2_order_by {
  aptos_name: current_aptos_names_order_by
  cdn_asset_uris: nft_metadata_crawler_parsed_asset_uris_order_by
  collection_id: order_by
  current_collection: current_collections_v2_order_by
  current_royalty_v1: current_token_royalty_v1_order_by
  current_token_ownerships_aggregate: current_token_ownerships_v2_aggregate_order_by
  decimals: order_by
  description: order_by
  inserted_at: order_by
  is_deleted_v2: order_by
  is_fungible_v2: order_by
  largest_property_version_v1: order_by
  last_transaction_timestamp: order_by
  last_transaction_version: order_by
  maximum: order_by
  supply: order_by
  token_data_id: order_by
  token_name: order_by
  token_properties: order_by
  token_standard: order_by
  token_uri: order_by
}

"""primary key columns input for table: current_token_datas_v2"""
input current_token_datas_v2_pk_columns_input {
  token_data_id: String!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input current_token_datas_v2_prepend_input {
  token_properties: jsonb
}

"""
select columns of table "current_token_datas_v2"
"""
enum current_token_datas_v2_select_column {
  """column name"""
  collection_id

  """column name"""
  decimals

  """column name"""
  description

  """column name"""
  inserted_at

  """column name"""
  is_deleted_v2

  """column name"""
  is_fungible_v2

  """column name"""
  largest_property_version_v1

  """column name"""
  last_transaction_timestamp

  """column name"""
  last_transaction_version

  """column name"""
  maximum

  """column name"""
  supply

  """column name"""
  token_data_id

  """column name"""
  token_name

  """column name"""
  token_properties

  """column name"""
  token_standard

  """column name"""
  token_uri
}

"""
input type for updating data in table "current_token_datas_v2"
"""
input current_token_datas_v2_set_input {
  collection_id: String
  decimals: bigint
  description: String
  inserted_at: timestamp
  is_deleted_v2: Boolean
  is_fungible_v2: Boolean
  largest_property_version_v1: numeric
  last_transaction_timestamp: timestamp
  last_transaction_version: bigint
  maximum: numeric
  supply: numeric
  token_data_id: String
  token_name: String
  token_properties: jsonb
  token_standard: String
  token_uri: String
}

"""aggregate stddev on columns"""
type current_token_datas_v2_stddev_fields {
  decimals: Float
  largest_property_version_v1: Float
  last_transaction_version: Float
  maximum: Float
  supply: Float
}

"""aggregate stddev_pop on columns"""
type current_token_datas_v2_stddev_pop_fields {
  decimals: Float
  largest_property_version_v1: Float
  last_transaction_version: Float
  maximum: Float
  supply: Float
}

"""aggregate stddev_samp on columns"""
type current_token_datas_v2_stddev_samp_fields {
  decimals: Float
  largest_property_version_v1: Float
  last_transaction_version: Float
  maximum: Float
  supply: Float
}

"""
Streaming cursor of the table "current_token_datas_v2"
"""
input current_token_datas_v2_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: current_token_datas_v2_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input current_token_datas_v2_stream_cursor_value_input {
  collection_id: String
  decimals: bigint
  description: String
  inserted_at: timestamp
  is_deleted_v2: Boolean
  is_fungible_v2: Boolean
  largest_property_version_v1: numeric
  last_transaction_timestamp: timestamp
  last_transaction_version: bigint
  maximum: numeric
  supply: numeric
  token_data_id: String
  token_name: String
  token_properties: jsonb
  token_standard: String
  token_uri: String
}

"""aggregate sum on columns"""
type current_token_datas_v2_sum_fields {
  decimals: bigint
  largest_property_version_v1: numeric
  last_transaction_version: bigint
  maximum: numeric
  supply: numeric
}

"""
update columns of table "current_token_datas_v2"
"""
enum current_token_datas_v2_update_column {
  """column name"""
  collection_id

  """column name"""
  decimals

  """column name"""
  description

  """column name"""
  inserted_at

  """column name"""
  is_deleted_v2

  """column name"""
  is_fungible_v2

  """column name"""
  largest_property_version_v1

  """column name"""
  last_transaction_timestamp

  """column name"""
  last_transaction_version

  """column name"""
  maximum

  """column name"""
  supply

  """column name"""
  token_data_id

  """column name"""
  token_name

  """column name"""
  token_properties

  """column name"""
  token_standard

  """column name"""
  token_uri
}

input current_token_datas_v2_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: current_token_datas_v2_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: current_token_datas_v2_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: current_token_datas_v2_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: current_token_datas_v2_delete_key_input

  """increments the numeric columns with given value of the filtered values"""
  _inc: current_token_datas_v2_inc_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: current_token_datas_v2_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: current_token_datas_v2_set_input

  """filter the rows which have to be updated"""
  where: current_token_datas_v2_bool_exp!
}

"""aggregate var_pop on columns"""
type current_token_datas_v2_var_pop_fields {
  decimals: Float
  largest_property_version_v1: Float
  last_transaction_version: Float
  maximum: Float
  supply: Float
}

"""aggregate var_samp on columns"""
type current_token_datas_v2_var_samp_fields {
  decimals: Float
  largest_property_version_v1: Float
  last_transaction_version: Float
  maximum: Float
  supply: Float
}

"""aggregate variance on columns"""
type current_token_datas_v2_variance_fields {
  decimals: Float
  largest_property_version_v1: Float
  last_transaction_version: Float
  maximum: Float
  supply: Float
}

"""aggregate var_pop on columns"""
type current_token_datas_var_pop_fields {
  largest_property_version: Float
  last_transaction_version: Float
  maximum: Float
  royalty_points_denominator: Float
  royalty_points_numerator: Float
  supply: Float
}

"""aggregate var_samp on columns"""
type current_token_datas_var_samp_fields {
  largest_property_version: Float
  last_transaction_version: Float
  maximum: Float
  royalty_points_denominator: Float
  royalty_points_numerator: Float
  supply: Float
}

"""aggregate variance on columns"""
type current_token_datas_variance_fields {
  largest_property_version: Float
  last_transaction_version: Float
  maximum: Float
  royalty_points_denominator: Float
  royalty_points_numerator: Float
  supply: Float
}

"""
columns and relationships of "legacy_migration_v1.current_token_ownerships"
"""
type current_token_ownerships {
  amount: numeric

  """An object relationship"""
  aptos_name: current_aptos_names
  collection_data_id_hash: String
  collection_name: String
  creator_address: String

  """An object relationship"""
  current_collection_data: current_collection_datas

  """An object relationship"""
  current_token_data: current_token_datas
  inserted_at: timestamp
  last_transaction_timestamp: timestamp
  last_transaction_version: bigint
  name: String
  owner_address: String
  property_version: numeric
  table_type: String
  token_data_id_hash: String
  token_properties(
    """JSON select path"""
    path: String
  ): jsonb
}

"""
aggregated selection of "legacy_migration_v1.current_token_ownerships"
"""
type current_token_ownerships_aggregate {
  aggregate: current_token_ownerships_aggregate_fields
  nodes: [current_token_ownerships!]!
}

input current_token_ownerships_aggregate_bool_exp {
  count: current_token_ownerships_aggregate_bool_exp_count
}

input current_token_ownerships_aggregate_bool_exp_count {
  arguments: [current_token_ownerships_select_column!]
  distinct: Boolean
  filter: current_token_ownerships_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "legacy_migration_v1.current_token_ownerships"
"""
type current_token_ownerships_aggregate_fields {
  avg: current_token_ownerships_avg_fields
  count(columns: [current_token_ownerships_select_column!], distinct: Boolean): Int!
  max: current_token_ownerships_max_fields
  min: current_token_ownerships_min_fields
  stddev: current_token_ownerships_stddev_fields
  stddev_pop: current_token_ownerships_stddev_pop_fields
  stddev_samp: current_token_ownerships_stddev_samp_fields
  sum: current_token_ownerships_sum_fields
  var_pop: current_token_ownerships_var_pop_fields
  var_samp: current_token_ownerships_var_samp_fields
  variance: current_token_ownerships_variance_fields
}

"""
order by aggregate values of table "legacy_migration_v1.current_token_ownerships"
"""
input current_token_ownerships_aggregate_order_by {
  avg: current_token_ownerships_avg_order_by
  count: order_by
  max: current_token_ownerships_max_order_by
  min: current_token_ownerships_min_order_by
  stddev: current_token_ownerships_stddev_order_by
  stddev_pop: current_token_ownerships_stddev_pop_order_by
  stddev_samp: current_token_ownerships_stddev_samp_order_by
  sum: current_token_ownerships_sum_order_by
  var_pop: current_token_ownerships_var_pop_order_by
  var_samp: current_token_ownerships_var_samp_order_by
  variance: current_token_ownerships_variance_order_by
}

"""
input type for inserting array relation for remote table "legacy_migration_v1.current_token_ownerships"
"""
input current_token_ownerships_arr_rel_insert_input {
  data: [current_token_ownerships_insert_input!]!
}

"""aggregate avg on columns"""
type current_token_ownerships_avg_fields {
  amount: Float
  last_transaction_version: Float
  property_version: Float
}

"""
order by avg() on columns of table "legacy_migration_v1.current_token_ownerships"
"""
input current_token_ownerships_avg_order_by {
  amount: order_by
  last_transaction_version: order_by
  property_version: order_by
}

"""
Boolean expression to filter rows from the table "legacy_migration_v1.current_token_ownerships". All fields are combined with a logical 'AND'.
"""
input current_token_ownerships_bool_exp {
  _and: [current_token_ownerships_bool_exp!]
  _not: current_token_ownerships_bool_exp
  _or: [current_token_ownerships_bool_exp!]
  amount: numeric_comparison_exp
  aptos_name: current_aptos_names_bool_exp
  collection_data_id_hash: String_comparison_exp
  collection_name: String_comparison_exp
  creator_address: String_comparison_exp
  current_collection_data: current_collection_datas_bool_exp
  current_token_data: current_token_datas_bool_exp
  inserted_at: timestamp_comparison_exp
  last_transaction_timestamp: timestamp_comparison_exp
  last_transaction_version: bigint_comparison_exp
  name: String_comparison_exp
  owner_address: String_comparison_exp
  property_version: numeric_comparison_exp
  table_type: String_comparison_exp
  token_data_id_hash: String_comparison_exp
  token_properties: jsonb_comparison_exp
}

"""
input type for inserting data into table "legacy_migration_v1.current_token_ownerships"
"""
input current_token_ownerships_insert_input {
  amount: numeric
  aptos_name: current_aptos_names_obj_rel_insert_input
  collection_data_id_hash: String
  collection_name: String
  creator_address: String
  current_collection_data: current_collection_datas_obj_rel_insert_input
  current_token_data: current_token_datas_obj_rel_insert_input
  inserted_at: timestamp
  last_transaction_timestamp: timestamp
  last_transaction_version: bigint
  name: String
  owner_address: String
  property_version: numeric
  table_type: String
  token_data_id_hash: String
  token_properties: jsonb
}

"""aggregate max on columns"""
type current_token_ownerships_max_fields {
  amount: numeric
  collection_data_id_hash: String
  collection_name: String
  creator_address: String
  inserted_at: timestamp
  last_transaction_timestamp: timestamp
  last_transaction_version: bigint
  name: String
  owner_address: String
  property_version: numeric
  table_type: String
  token_data_id_hash: String
}

"""
order by max() on columns of table "legacy_migration_v1.current_token_ownerships"
"""
input current_token_ownerships_max_order_by {
  amount: order_by
  collection_data_id_hash: order_by
  collection_name: order_by
  creator_address: order_by
  inserted_at: order_by
  last_transaction_timestamp: order_by
  last_transaction_version: order_by
  name: order_by
  owner_address: order_by
  property_version: order_by
  table_type: order_by
  token_data_id_hash: order_by
}

"""aggregate min on columns"""
type current_token_ownerships_min_fields {
  amount: numeric
  collection_data_id_hash: String
  collection_name: String
  creator_address: String
  inserted_at: timestamp
  last_transaction_timestamp: timestamp
  last_transaction_version: bigint
  name: String
  owner_address: String
  property_version: numeric
  table_type: String
  token_data_id_hash: String
}

"""
order by min() on columns of table "legacy_migration_v1.current_token_ownerships"
"""
input current_token_ownerships_min_order_by {
  amount: order_by
  collection_data_id_hash: order_by
  collection_name: order_by
  creator_address: order_by
  inserted_at: order_by
  last_transaction_timestamp: order_by
  last_transaction_version: order_by
  name: order_by
  owner_address: order_by
  property_version: order_by
  table_type: order_by
  token_data_id_hash: order_by
}

"""
Ordering options when selecting data from "legacy_migration_v1.current_token_ownerships".
"""
input current_token_ownerships_order_by {
  amount: order_by
  aptos_name: current_aptos_names_order_by
  collection_data_id_hash: order_by
  collection_name: order_by
  creator_address: order_by
  current_collection_data: current_collection_datas_order_by
  current_token_data: current_token_datas_order_by
  inserted_at: order_by
  last_transaction_timestamp: order_by
  last_transaction_version: order_by
  name: order_by
  owner_address: order_by
  property_version: order_by
  table_type: order_by
  token_data_id_hash: order_by
  token_properties: order_by
}

"""
select columns of table "legacy_migration_v1.current_token_ownerships"
"""
enum current_token_ownerships_select_column {
  """column name"""
  amount

  """column name"""
  collection_data_id_hash

  """column name"""
  collection_name

  """column name"""
  creator_address

  """column name"""
  inserted_at

  """column name"""
  last_transaction_timestamp

  """column name"""
  last_transaction_version

  """column name"""
  name

  """column name"""
  owner_address

  """column name"""
  property_version

  """column name"""
  table_type

  """column name"""
  token_data_id_hash

  """column name"""
  token_properties
}

"""aggregate stddev on columns"""
type current_token_ownerships_stddev_fields {
  amount: Float
  last_transaction_version: Float
  property_version: Float
}

"""
order by stddev() on columns of table "legacy_migration_v1.current_token_ownerships"
"""
input current_token_ownerships_stddev_order_by {
  amount: order_by
  last_transaction_version: order_by
  property_version: order_by
}

"""aggregate stddev_pop on columns"""
type current_token_ownerships_stddev_pop_fields {
  amount: Float
  last_transaction_version: Float
  property_version: Float
}

"""
order by stddev_pop() on columns of table "legacy_migration_v1.current_token_ownerships"
"""
input current_token_ownerships_stddev_pop_order_by {
  amount: order_by
  last_transaction_version: order_by
  property_version: order_by
}

"""aggregate stddev_samp on columns"""
type current_token_ownerships_stddev_samp_fields {
  amount: Float
  last_transaction_version: Float
  property_version: Float
}

"""
order by stddev_samp() on columns of table "legacy_migration_v1.current_token_ownerships"
"""
input current_token_ownerships_stddev_samp_order_by {
  amount: order_by
  last_transaction_version: order_by
  property_version: order_by
}

"""
Streaming cursor of the table "current_token_ownerships"
"""
input current_token_ownerships_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: current_token_ownerships_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input current_token_ownerships_stream_cursor_value_input {
  amount: numeric
  collection_data_id_hash: String
  collection_name: String
  creator_address: String
  inserted_at: timestamp
  last_transaction_timestamp: timestamp
  last_transaction_version: bigint
  name: String
  owner_address: String
  property_version: numeric
  table_type: String
  token_data_id_hash: String
  token_properties: jsonb
}

"""aggregate sum on columns"""
type current_token_ownerships_sum_fields {
  amount: numeric
  last_transaction_version: bigint
  property_version: numeric
}

"""
order by sum() on columns of table "legacy_migration_v1.current_token_ownerships"
"""
input current_token_ownerships_sum_order_by {
  amount: order_by
  last_transaction_version: order_by
  property_version: order_by
}

"""
columns and relationships of "current_token_ownerships_v2"
"""
type current_token_ownerships_v2 {
  amount: numeric!

  """An array relationship"""
  composed_nfts(
    """distinct select on columns"""
    distinct_on: [current_token_ownerships_v2_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_token_ownerships_v2_order_by!]

    """filter the rows returned"""
    where: current_token_ownerships_v2_bool_exp
  ): [current_token_ownerships_v2!]!

  """An aggregate relationship"""
  composed_nfts_aggregate(
    """distinct select on columns"""
    distinct_on: [current_token_ownerships_v2_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_token_ownerships_v2_order_by!]

    """filter the rows returned"""
    where: current_token_ownerships_v2_bool_exp
  ): current_token_ownerships_v2_aggregate!

  """An object relationship"""
  current_token_data: current_token_datas_v2
  inserted_at: timestamp!
  is_fungible_v2: Boolean
  is_soulbound_v2: Boolean
  last_transaction_timestamp: timestamp!
  last_transaction_version: bigint!
  non_transferrable_by_owner: Boolean
  owner_address: String!
  property_version_v1: numeric!
  storage_id: String!
  table_type_v1: String
  token_data_id: String!
  token_properties_mutated_v1(
    """JSON select path"""
    path: String
  ): jsonb
  token_standard: String!
}

"""
aggregated selection of "current_token_ownerships_v2"
"""
type current_token_ownerships_v2_aggregate {
  aggregate: current_token_ownerships_v2_aggregate_fields
  nodes: [current_token_ownerships_v2!]!
}

input current_token_ownerships_v2_aggregate_bool_exp {
  bool_and: current_token_ownerships_v2_aggregate_bool_exp_bool_and
  bool_or: current_token_ownerships_v2_aggregate_bool_exp_bool_or
  count: current_token_ownerships_v2_aggregate_bool_exp_count
}

input current_token_ownerships_v2_aggregate_bool_exp_bool_and {
  arguments: current_token_ownerships_v2_select_column_current_token_ownerships_v2_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: current_token_ownerships_v2_bool_exp
  predicate: Boolean_comparison_exp!
}

input current_token_ownerships_v2_aggregate_bool_exp_bool_or {
  arguments: current_token_ownerships_v2_select_column_current_token_ownerships_v2_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: current_token_ownerships_v2_bool_exp
  predicate: Boolean_comparison_exp!
}

input current_token_ownerships_v2_aggregate_bool_exp_count {
  arguments: [current_token_ownerships_v2_select_column!]
  distinct: Boolean
  filter: current_token_ownerships_v2_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "current_token_ownerships_v2"
"""
type current_token_ownerships_v2_aggregate_fields {
  avg: current_token_ownerships_v2_avg_fields
  count(columns: [current_token_ownerships_v2_select_column!], distinct: Boolean): Int!
  max: current_token_ownerships_v2_max_fields
  min: current_token_ownerships_v2_min_fields
  stddev: current_token_ownerships_v2_stddev_fields
  stddev_pop: current_token_ownerships_v2_stddev_pop_fields
  stddev_samp: current_token_ownerships_v2_stddev_samp_fields
  sum: current_token_ownerships_v2_sum_fields
  var_pop: current_token_ownerships_v2_var_pop_fields
  var_samp: current_token_ownerships_v2_var_samp_fields
  variance: current_token_ownerships_v2_variance_fields
}

"""
order by aggregate values of table "current_token_ownerships_v2"
"""
input current_token_ownerships_v2_aggregate_order_by {
  avg: current_token_ownerships_v2_avg_order_by
  count: order_by
  max: current_token_ownerships_v2_max_order_by
  min: current_token_ownerships_v2_min_order_by
  stddev: current_token_ownerships_v2_stddev_order_by
  stddev_pop: current_token_ownerships_v2_stddev_pop_order_by
  stddev_samp: current_token_ownerships_v2_stddev_samp_order_by
  sum: current_token_ownerships_v2_sum_order_by
  var_pop: current_token_ownerships_v2_var_pop_order_by
  var_samp: current_token_ownerships_v2_var_samp_order_by
  variance: current_token_ownerships_v2_variance_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input current_token_ownerships_v2_append_input {
  token_properties_mutated_v1: jsonb
}

"""
input type for inserting array relation for remote table "current_token_ownerships_v2"
"""
input current_token_ownerships_v2_arr_rel_insert_input {
  data: [current_token_ownerships_v2_insert_input!]!

  """upsert condition"""
  on_conflict: current_token_ownerships_v2_on_conflict
}

"""aggregate avg on columns"""
type current_token_ownerships_v2_avg_fields {
  amount: Float
  last_transaction_version: Float
  property_version_v1: Float
}

"""
order by avg() on columns of table "current_token_ownerships_v2"
"""
input current_token_ownerships_v2_avg_order_by {
  amount: order_by
  last_transaction_version: order_by
  property_version_v1: order_by
}

"""
Boolean expression to filter rows from the table "current_token_ownerships_v2". All fields are combined with a logical 'AND'.
"""
input current_token_ownerships_v2_bool_exp {
  _and: [current_token_ownerships_v2_bool_exp!]
  _not: current_token_ownerships_v2_bool_exp
  _or: [current_token_ownerships_v2_bool_exp!]
  amount: numeric_comparison_exp
  composed_nfts: current_token_ownerships_v2_bool_exp
  composed_nfts_aggregate: current_token_ownerships_v2_aggregate_bool_exp
  current_token_data: current_token_datas_v2_bool_exp
  inserted_at: timestamp_comparison_exp
  is_fungible_v2: Boolean_comparison_exp
  is_soulbound_v2: Boolean_comparison_exp
  last_transaction_timestamp: timestamp_comparison_exp
  last_transaction_version: bigint_comparison_exp
  non_transferrable_by_owner: Boolean_comparison_exp
  owner_address: String_comparison_exp
  property_version_v1: numeric_comparison_exp
  storage_id: String_comparison_exp
  table_type_v1: String_comparison_exp
  token_data_id: String_comparison_exp
  token_properties_mutated_v1: jsonb_comparison_exp
  token_standard: String_comparison_exp
}

"""
unique or primary key constraints on table "current_token_ownerships_v2"
"""
enum current_token_ownerships_v2_constraint {
  """
  unique or primary key constraint on columns "owner_address", "property_version_v1", "token_data_id", "storage_id"
  """
  current_token_ownerships_v2_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input current_token_ownerships_v2_delete_at_path_input {
  token_properties_mutated_v1: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input current_token_ownerships_v2_delete_elem_input {
  token_properties_mutated_v1: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input current_token_ownerships_v2_delete_key_input {
  token_properties_mutated_v1: String
}

"""
input type for incrementing numeric columns in table "current_token_ownerships_v2"
"""
input current_token_ownerships_v2_inc_input {
  amount: numeric
  last_transaction_version: bigint
  property_version_v1: numeric
}

"""
input type for inserting data into table "current_token_ownerships_v2"
"""
input current_token_ownerships_v2_insert_input {
  amount: numeric
  composed_nfts: current_token_ownerships_v2_arr_rel_insert_input
  current_token_data: current_token_datas_v2_obj_rel_insert_input
  inserted_at: timestamp
  is_fungible_v2: Boolean
  is_soulbound_v2: Boolean
  last_transaction_timestamp: timestamp
  last_transaction_version: bigint
  non_transferrable_by_owner: Boolean
  owner_address: String
  property_version_v1: numeric
  storage_id: String
  table_type_v1: String
  token_data_id: String
  token_properties_mutated_v1: jsonb
  token_standard: String
}

"""aggregate max on columns"""
type current_token_ownerships_v2_max_fields {
  amount: numeric
  inserted_at: timestamp
  last_transaction_timestamp: timestamp
  last_transaction_version: bigint
  owner_address: String
  property_version_v1: numeric
  storage_id: String
  table_type_v1: String
  token_data_id: String
  token_standard: String
}

"""
order by max() on columns of table "current_token_ownerships_v2"
"""
input current_token_ownerships_v2_max_order_by {
  amount: order_by
  inserted_at: order_by
  last_transaction_timestamp: order_by
  last_transaction_version: order_by
  owner_address: order_by
  property_version_v1: order_by
  storage_id: order_by
  table_type_v1: order_by
  token_data_id: order_by
  token_standard: order_by
}

"""aggregate min on columns"""
type current_token_ownerships_v2_min_fields {
  amount: numeric
  inserted_at: timestamp
  last_transaction_timestamp: timestamp
  last_transaction_version: bigint
  owner_address: String
  property_version_v1: numeric
  storage_id: String
  table_type_v1: String
  token_data_id: String
  token_standard: String
}

"""
order by min() on columns of table "current_token_ownerships_v2"
"""
input current_token_ownerships_v2_min_order_by {
  amount: order_by
  inserted_at: order_by
  last_transaction_timestamp: order_by
  last_transaction_version: order_by
  owner_address: order_by
  property_version_v1: order_by
  storage_id: order_by
  table_type_v1: order_by
  token_data_id: order_by
  token_standard: order_by
}

"""
response of any mutation on the table "current_token_ownerships_v2"
"""
type current_token_ownerships_v2_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [current_token_ownerships_v2!]!
}

"""
on_conflict condition type for table "current_token_ownerships_v2"
"""
input current_token_ownerships_v2_on_conflict {
  constraint: current_token_ownerships_v2_constraint!
  update_columns: [current_token_ownerships_v2_update_column!]! = []
  where: current_token_ownerships_v2_bool_exp
}

"""
Ordering options when selecting data from "current_token_ownerships_v2".
"""
input current_token_ownerships_v2_order_by {
  amount: order_by
  composed_nfts_aggregate: current_token_ownerships_v2_aggregate_order_by
  current_token_data: current_token_datas_v2_order_by
  inserted_at: order_by
  is_fungible_v2: order_by
  is_soulbound_v2: order_by
  last_transaction_timestamp: order_by
  last_transaction_version: order_by
  non_transferrable_by_owner: order_by
  owner_address: order_by
  property_version_v1: order_by
  storage_id: order_by
  table_type_v1: order_by
  token_data_id: order_by
  token_properties_mutated_v1: order_by
  token_standard: order_by
}

"""primary key columns input for table: current_token_ownerships_v2"""
input current_token_ownerships_v2_pk_columns_input {
  owner_address: String!
  property_version_v1: numeric!
  storage_id: String!
  token_data_id: String!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input current_token_ownerships_v2_prepend_input {
  token_properties_mutated_v1: jsonb
}

"""
select columns of table "current_token_ownerships_v2"
"""
enum current_token_ownerships_v2_select_column {
  """column name"""
  amount

  """column name"""
  inserted_at

  """column name"""
  is_fungible_v2

  """column name"""
  is_soulbound_v2

  """column name"""
  last_transaction_timestamp

  """column name"""
  last_transaction_version

  """column name"""
  non_transferrable_by_owner

  """column name"""
  owner_address

  """column name"""
  property_version_v1

  """column name"""
  storage_id

  """column name"""
  table_type_v1

  """column name"""
  token_data_id

  """column name"""
  token_properties_mutated_v1

  """column name"""
  token_standard
}

"""
select "current_token_ownerships_v2_aggregate_bool_exp_bool_and_arguments_columns" columns of table "current_token_ownerships_v2"
"""
enum current_token_ownerships_v2_select_column_current_token_ownerships_v2_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  is_fungible_v2

  """column name"""
  is_soulbound_v2

  """column name"""
  non_transferrable_by_owner
}

"""
select "current_token_ownerships_v2_aggregate_bool_exp_bool_or_arguments_columns" columns of table "current_token_ownerships_v2"
"""
enum current_token_ownerships_v2_select_column_current_token_ownerships_v2_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  is_fungible_v2

  """column name"""
  is_soulbound_v2

  """column name"""
  non_transferrable_by_owner
}

"""
input type for updating data in table "current_token_ownerships_v2"
"""
input current_token_ownerships_v2_set_input {
  amount: numeric
  inserted_at: timestamp
  is_fungible_v2: Boolean
  is_soulbound_v2: Boolean
  last_transaction_timestamp: timestamp
  last_transaction_version: bigint
  non_transferrable_by_owner: Boolean
  owner_address: String
  property_version_v1: numeric
  storage_id: String
  table_type_v1: String
  token_data_id: String
  token_properties_mutated_v1: jsonb
  token_standard: String
}

"""aggregate stddev on columns"""
type current_token_ownerships_v2_stddev_fields {
  amount: Float
  last_transaction_version: Float
  property_version_v1: Float
}

"""
order by stddev() on columns of table "current_token_ownerships_v2"
"""
input current_token_ownerships_v2_stddev_order_by {
  amount: order_by
  last_transaction_version: order_by
  property_version_v1: order_by
}

"""aggregate stddev_pop on columns"""
type current_token_ownerships_v2_stddev_pop_fields {
  amount: Float
  last_transaction_version: Float
  property_version_v1: Float
}

"""
order by stddev_pop() on columns of table "current_token_ownerships_v2"
"""
input current_token_ownerships_v2_stddev_pop_order_by {
  amount: order_by
  last_transaction_version: order_by
  property_version_v1: order_by
}

"""aggregate stddev_samp on columns"""
type current_token_ownerships_v2_stddev_samp_fields {
  amount: Float
  last_transaction_version: Float
  property_version_v1: Float
}

"""
order by stddev_samp() on columns of table "current_token_ownerships_v2"
"""
input current_token_ownerships_v2_stddev_samp_order_by {
  amount: order_by
  last_transaction_version: order_by
  property_version_v1: order_by
}

"""
Streaming cursor of the table "current_token_ownerships_v2"
"""
input current_token_ownerships_v2_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: current_token_ownerships_v2_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input current_token_ownerships_v2_stream_cursor_value_input {
  amount: numeric
  inserted_at: timestamp
  is_fungible_v2: Boolean
  is_soulbound_v2: Boolean
  last_transaction_timestamp: timestamp
  last_transaction_version: bigint
  non_transferrable_by_owner: Boolean
  owner_address: String
  property_version_v1: numeric
  storage_id: String
  table_type_v1: String
  token_data_id: String
  token_properties_mutated_v1: jsonb
  token_standard: String
}

"""aggregate sum on columns"""
type current_token_ownerships_v2_sum_fields {
  amount: numeric
  last_transaction_version: bigint
  property_version_v1: numeric
}

"""
order by sum() on columns of table "current_token_ownerships_v2"
"""
input current_token_ownerships_v2_sum_order_by {
  amount: order_by
  last_transaction_version: order_by
  property_version_v1: order_by
}

"""
update columns of table "current_token_ownerships_v2"
"""
enum current_token_ownerships_v2_update_column {
  """column name"""
  amount

  """column name"""
  inserted_at

  """column name"""
  is_fungible_v2

  """column name"""
  is_soulbound_v2

  """column name"""
  last_transaction_timestamp

  """column name"""
  last_transaction_version

  """column name"""
  non_transferrable_by_owner

  """column name"""
  owner_address

  """column name"""
  property_version_v1

  """column name"""
  storage_id

  """column name"""
  table_type_v1

  """column name"""
  token_data_id

  """column name"""
  token_properties_mutated_v1

  """column name"""
  token_standard
}

input current_token_ownerships_v2_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: current_token_ownerships_v2_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: current_token_ownerships_v2_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: current_token_ownerships_v2_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: current_token_ownerships_v2_delete_key_input

  """increments the numeric columns with given value of the filtered values"""
  _inc: current_token_ownerships_v2_inc_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: current_token_ownerships_v2_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: current_token_ownerships_v2_set_input

  """filter the rows which have to be updated"""
  where: current_token_ownerships_v2_bool_exp!
}

"""aggregate var_pop on columns"""
type current_token_ownerships_v2_var_pop_fields {
  amount: Float
  last_transaction_version: Float
  property_version_v1: Float
}

"""
order by var_pop() on columns of table "current_token_ownerships_v2"
"""
input current_token_ownerships_v2_var_pop_order_by {
  amount: order_by
  last_transaction_version: order_by
  property_version_v1: order_by
}

"""aggregate var_samp on columns"""
type current_token_ownerships_v2_var_samp_fields {
  amount: Float
  last_transaction_version: Float
  property_version_v1: Float
}

"""
order by var_samp() on columns of table "current_token_ownerships_v2"
"""
input current_token_ownerships_v2_var_samp_order_by {
  amount: order_by
  last_transaction_version: order_by
  property_version_v1: order_by
}

"""aggregate variance on columns"""
type current_token_ownerships_v2_variance_fields {
  amount: Float
  last_transaction_version: Float
  property_version_v1: Float
}

"""
order by variance() on columns of table "current_token_ownerships_v2"
"""
input current_token_ownerships_v2_variance_order_by {
  amount: order_by
  last_transaction_version: order_by
  property_version_v1: order_by
}

"""aggregate var_pop on columns"""
type current_token_ownerships_var_pop_fields {
  amount: Float
  last_transaction_version: Float
  property_version: Float
}

"""
order by var_pop() on columns of table "legacy_migration_v1.current_token_ownerships"
"""
input current_token_ownerships_var_pop_order_by {
  amount: order_by
  last_transaction_version: order_by
  property_version: order_by
}

"""aggregate var_samp on columns"""
type current_token_ownerships_var_samp_fields {
  amount: Float
  last_transaction_version: Float
  property_version: Float
}

"""
order by var_samp() on columns of table "legacy_migration_v1.current_token_ownerships"
"""
input current_token_ownerships_var_samp_order_by {
  amount: order_by
  last_transaction_version: order_by
  property_version: order_by
}

"""aggregate variance on columns"""
type current_token_ownerships_variance_fields {
  amount: Float
  last_transaction_version: Float
  property_version: Float
}

"""
order by variance() on columns of table "legacy_migration_v1.current_token_ownerships"
"""
input current_token_ownerships_variance_order_by {
  amount: order_by
  last_transaction_version: order_by
  property_version: order_by
}

"""
columns and relationships of "current_token_pending_claims"
"""
type current_token_pending_claims {
  amount: numeric!
  collection_data_id_hash: String!
  collection_id: String!
  collection_name: String!
  creator_address: String!

  """An object relationship"""
  current_collection_data: current_collection_datas

  """An object relationship"""
  current_collection_v2: current_collections_v2

  """An object relationship"""
  current_token_data: current_token_datas

  """An object relationship"""
  current_token_data_v2: current_token_datas_v2
  from_address: String!
  inserted_at: timestamp!
  last_transaction_timestamp: timestamp!
  last_transaction_version: bigint!
  name: String!
  property_version: numeric!
  table_handle: String!
  to_address: String!

  """An object relationship"""
  token: tokens
  token_data_id: String!
  token_data_id_hash: String!
}

"""
aggregated selection of "current_token_pending_claims"
"""
type current_token_pending_claims_aggregate {
  aggregate: current_token_pending_claims_aggregate_fields
  nodes: [current_token_pending_claims!]!
}

"""
aggregate fields of "current_token_pending_claims"
"""
type current_token_pending_claims_aggregate_fields {
  avg: current_token_pending_claims_avg_fields
  count(columns: [current_token_pending_claims_select_column!], distinct: Boolean): Int!
  max: current_token_pending_claims_max_fields
  min: current_token_pending_claims_min_fields
  stddev: current_token_pending_claims_stddev_fields
  stddev_pop: current_token_pending_claims_stddev_pop_fields
  stddev_samp: current_token_pending_claims_stddev_samp_fields
  sum: current_token_pending_claims_sum_fields
  var_pop: current_token_pending_claims_var_pop_fields
  var_samp: current_token_pending_claims_var_samp_fields
  variance: current_token_pending_claims_variance_fields
}

"""aggregate avg on columns"""
type current_token_pending_claims_avg_fields {
  amount: Float
  last_transaction_version: Float
  property_version: Float
}

"""
Boolean expression to filter rows from the table "current_token_pending_claims". All fields are combined with a logical 'AND'.
"""
input current_token_pending_claims_bool_exp {
  _and: [current_token_pending_claims_bool_exp!]
  _not: current_token_pending_claims_bool_exp
  _or: [current_token_pending_claims_bool_exp!]
  amount: numeric_comparison_exp
  collection_data_id_hash: String_comparison_exp
  collection_id: String_comparison_exp
  collection_name: String_comparison_exp
  creator_address: String_comparison_exp
  current_collection_data: current_collection_datas_bool_exp
  current_collection_v2: current_collections_v2_bool_exp
  current_token_data: current_token_datas_bool_exp
  current_token_data_v2: current_token_datas_v2_bool_exp
  from_address: String_comparison_exp
  inserted_at: timestamp_comparison_exp
  last_transaction_timestamp: timestamp_comparison_exp
  last_transaction_version: bigint_comparison_exp
  name: String_comparison_exp
  property_version: numeric_comparison_exp
  table_handle: String_comparison_exp
  to_address: String_comparison_exp
  token: tokens_bool_exp
  token_data_id: String_comparison_exp
  token_data_id_hash: String_comparison_exp
}

"""
unique or primary key constraints on table "current_token_pending_claims"
"""
enum current_token_pending_claims_constraint {
  """
  unique or primary key constraint on columns "property_version", "from_address", "token_data_id_hash", "to_address"
  """
  current_token_pending_claims_pkey
}

"""
input type for incrementing numeric columns in table "current_token_pending_claims"
"""
input current_token_pending_claims_inc_input {
  amount: numeric
  last_transaction_version: bigint
  property_version: numeric
}

"""
input type for inserting data into table "current_token_pending_claims"
"""
input current_token_pending_claims_insert_input {
  amount: numeric
  collection_data_id_hash: String
  collection_id: String
  collection_name: String
  creator_address: String
  current_collection_data: current_collection_datas_obj_rel_insert_input
  current_collection_v2: current_collections_v2_obj_rel_insert_input
  current_token_data: current_token_datas_obj_rel_insert_input
  current_token_data_v2: current_token_datas_v2_obj_rel_insert_input
  from_address: String
  inserted_at: timestamp
  last_transaction_timestamp: timestamp
  last_transaction_version: bigint
  name: String
  property_version: numeric
  table_handle: String
  to_address: String
  token: tokens_obj_rel_insert_input
  token_data_id: String
  token_data_id_hash: String
}

"""aggregate max on columns"""
type current_token_pending_claims_max_fields {
  amount: numeric
  collection_data_id_hash: String
  collection_id: String
  collection_name: String
  creator_address: String
  from_address: String
  inserted_at: timestamp
  last_transaction_timestamp: timestamp
  last_transaction_version: bigint
  name: String
  property_version: numeric
  table_handle: String
  to_address: String
  token_data_id: String
  token_data_id_hash: String
}

"""aggregate min on columns"""
type current_token_pending_claims_min_fields {
  amount: numeric
  collection_data_id_hash: String
  collection_id: String
  collection_name: String
  creator_address: String
  from_address: String
  inserted_at: timestamp
  last_transaction_timestamp: timestamp
  last_transaction_version: bigint
  name: String
  property_version: numeric
  table_handle: String
  to_address: String
  token_data_id: String
  token_data_id_hash: String
}

"""
response of any mutation on the table "current_token_pending_claims"
"""
type current_token_pending_claims_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [current_token_pending_claims!]!
}

"""
on_conflict condition type for table "current_token_pending_claims"
"""
input current_token_pending_claims_on_conflict {
  constraint: current_token_pending_claims_constraint!
  update_columns: [current_token_pending_claims_update_column!]! = []
  where: current_token_pending_claims_bool_exp
}

"""
Ordering options when selecting data from "current_token_pending_claims".
"""
input current_token_pending_claims_order_by {
  amount: order_by
  collection_data_id_hash: order_by
  collection_id: order_by
  collection_name: order_by
  creator_address: order_by
  current_collection_data: current_collection_datas_order_by
  current_collection_v2: current_collections_v2_order_by
  current_token_data: current_token_datas_order_by
  current_token_data_v2: current_token_datas_v2_order_by
  from_address: order_by
  inserted_at: order_by
  last_transaction_timestamp: order_by
  last_transaction_version: order_by
  name: order_by
  property_version: order_by
  table_handle: order_by
  to_address: order_by
  token: tokens_order_by
  token_data_id: order_by
  token_data_id_hash: order_by
}

"""primary key columns input for table: current_token_pending_claims"""
input current_token_pending_claims_pk_columns_input {
  from_address: String!
  property_version: numeric!
  to_address: String!
  token_data_id_hash: String!
}

"""
select columns of table "current_token_pending_claims"
"""
enum current_token_pending_claims_select_column {
  """column name"""
  amount

  """column name"""
  collection_data_id_hash

  """column name"""
  collection_id

  """column name"""
  collection_name

  """column name"""
  creator_address

  """column name"""
  from_address

  """column name"""
  inserted_at

  """column name"""
  last_transaction_timestamp

  """column name"""
  last_transaction_version

  """column name"""
  name

  """column name"""
  property_version

  """column name"""
  table_handle

  """column name"""
  to_address

  """column name"""
  token_data_id

  """column name"""
  token_data_id_hash
}

"""
input type for updating data in table "current_token_pending_claims"
"""
input current_token_pending_claims_set_input {
  amount: numeric
  collection_data_id_hash: String
  collection_id: String
  collection_name: String
  creator_address: String
  from_address: String
  inserted_at: timestamp
  last_transaction_timestamp: timestamp
  last_transaction_version: bigint
  name: String
  property_version: numeric
  table_handle: String
  to_address: String
  token_data_id: String
  token_data_id_hash: String
}

"""aggregate stddev on columns"""
type current_token_pending_claims_stddev_fields {
  amount: Float
  last_transaction_version: Float
  property_version: Float
}

"""aggregate stddev_pop on columns"""
type current_token_pending_claims_stddev_pop_fields {
  amount: Float
  last_transaction_version: Float
  property_version: Float
}

"""aggregate stddev_samp on columns"""
type current_token_pending_claims_stddev_samp_fields {
  amount: Float
  last_transaction_version: Float
  property_version: Float
}

"""
Streaming cursor of the table "current_token_pending_claims"
"""
input current_token_pending_claims_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: current_token_pending_claims_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input current_token_pending_claims_stream_cursor_value_input {
  amount: numeric
  collection_data_id_hash: String
  collection_id: String
  collection_name: String
  creator_address: String
  from_address: String
  inserted_at: timestamp
  last_transaction_timestamp: timestamp
  last_transaction_version: bigint
  name: String
  property_version: numeric
  table_handle: String
  to_address: String
  token_data_id: String
  token_data_id_hash: String
}

"""aggregate sum on columns"""
type current_token_pending_claims_sum_fields {
  amount: numeric
  last_transaction_version: bigint
  property_version: numeric
}

"""
update columns of table "current_token_pending_claims"
"""
enum current_token_pending_claims_update_column {
  """column name"""
  amount

  """column name"""
  collection_data_id_hash

  """column name"""
  collection_id

  """column name"""
  collection_name

  """column name"""
  creator_address

  """column name"""
  from_address

  """column name"""
  inserted_at

  """column name"""
  last_transaction_timestamp

  """column name"""
  last_transaction_version

  """column name"""
  name

  """column name"""
  property_version

  """column name"""
  table_handle

  """column name"""
  to_address

  """column name"""
  token_data_id

  """column name"""
  token_data_id_hash
}

input current_token_pending_claims_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: current_token_pending_claims_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: current_token_pending_claims_set_input

  """filter the rows which have to be updated"""
  where: current_token_pending_claims_bool_exp!
}

"""aggregate var_pop on columns"""
type current_token_pending_claims_var_pop_fields {
  amount: Float
  last_transaction_version: Float
  property_version: Float
}

"""aggregate var_samp on columns"""
type current_token_pending_claims_var_samp_fields {
  amount: Float
  last_transaction_version: Float
  property_version: Float
}

"""aggregate variance on columns"""
type current_token_pending_claims_variance_fields {
  amount: Float
  last_transaction_version: Float
  property_version: Float
}

"""
columns and relationships of "current_token_royalty_v1"
"""
type current_token_royalty_v1 {
  inserted_at: timestamp!
  last_transaction_timestamp: timestamp!
  last_transaction_version: bigint!
  payee_address: String!
  royalty_points_denominator: numeric!
  royalty_points_numerator: numeric!
  token_data_id: String!
}

"""
aggregated selection of "current_token_royalty_v1"
"""
type current_token_royalty_v1_aggregate {
  aggregate: current_token_royalty_v1_aggregate_fields
  nodes: [current_token_royalty_v1!]!
}

"""
aggregate fields of "current_token_royalty_v1"
"""
type current_token_royalty_v1_aggregate_fields {
  avg: current_token_royalty_v1_avg_fields
  count(columns: [current_token_royalty_v1_select_column!], distinct: Boolean): Int!
  max: current_token_royalty_v1_max_fields
  min: current_token_royalty_v1_min_fields
  stddev: current_token_royalty_v1_stddev_fields
  stddev_pop: current_token_royalty_v1_stddev_pop_fields
  stddev_samp: current_token_royalty_v1_stddev_samp_fields
  sum: current_token_royalty_v1_sum_fields
  var_pop: current_token_royalty_v1_var_pop_fields
  var_samp: current_token_royalty_v1_var_samp_fields
  variance: current_token_royalty_v1_variance_fields
}

"""aggregate avg on columns"""
type current_token_royalty_v1_avg_fields {
  last_transaction_version: Float
  royalty_points_denominator: Float
  royalty_points_numerator: Float
}

"""
Boolean expression to filter rows from the table "current_token_royalty_v1". All fields are combined with a logical 'AND'.
"""
input current_token_royalty_v1_bool_exp {
  _and: [current_token_royalty_v1_bool_exp!]
  _not: current_token_royalty_v1_bool_exp
  _or: [current_token_royalty_v1_bool_exp!]
  inserted_at: timestamp_comparison_exp
  last_transaction_timestamp: timestamp_comparison_exp
  last_transaction_version: bigint_comparison_exp
  payee_address: String_comparison_exp
  royalty_points_denominator: numeric_comparison_exp
  royalty_points_numerator: numeric_comparison_exp
  token_data_id: String_comparison_exp
}

"""
unique or primary key constraints on table "current_token_royalty_v1"
"""
enum current_token_royalty_v1_constraint {
  """
  unique or primary key constraint on columns "token_data_id"
  """
  current_token_royalty_v1_pkey
}

"""
input type for incrementing numeric columns in table "current_token_royalty_v1"
"""
input current_token_royalty_v1_inc_input {
  last_transaction_version: bigint
  royalty_points_denominator: numeric
  royalty_points_numerator: numeric
}

"""
input type for inserting data into table "current_token_royalty_v1"
"""
input current_token_royalty_v1_insert_input {
  inserted_at: timestamp
  last_transaction_timestamp: timestamp
  last_transaction_version: bigint
  payee_address: String
  royalty_points_denominator: numeric
  royalty_points_numerator: numeric
  token_data_id: String
}

"""aggregate max on columns"""
type current_token_royalty_v1_max_fields {
  inserted_at: timestamp
  last_transaction_timestamp: timestamp
  last_transaction_version: bigint
  payee_address: String
  royalty_points_denominator: numeric
  royalty_points_numerator: numeric
  token_data_id: String
}

"""aggregate min on columns"""
type current_token_royalty_v1_min_fields {
  inserted_at: timestamp
  last_transaction_timestamp: timestamp
  last_transaction_version: bigint
  payee_address: String
  royalty_points_denominator: numeric
  royalty_points_numerator: numeric
  token_data_id: String
}

"""
response of any mutation on the table "current_token_royalty_v1"
"""
type current_token_royalty_v1_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [current_token_royalty_v1!]!
}

"""
input type for inserting object relation for remote table "current_token_royalty_v1"
"""
input current_token_royalty_v1_obj_rel_insert_input {
  data: current_token_royalty_v1_insert_input!

  """upsert condition"""
  on_conflict: current_token_royalty_v1_on_conflict
}

"""
on_conflict condition type for table "current_token_royalty_v1"
"""
input current_token_royalty_v1_on_conflict {
  constraint: current_token_royalty_v1_constraint!
  update_columns: [current_token_royalty_v1_update_column!]! = []
  where: current_token_royalty_v1_bool_exp
}

"""Ordering options when selecting data from "current_token_royalty_v1"."""
input current_token_royalty_v1_order_by {
  inserted_at: order_by
  last_transaction_timestamp: order_by
  last_transaction_version: order_by
  payee_address: order_by
  royalty_points_denominator: order_by
  royalty_points_numerator: order_by
  token_data_id: order_by
}

"""primary key columns input for table: current_token_royalty_v1"""
input current_token_royalty_v1_pk_columns_input {
  token_data_id: String!
}

"""
select columns of table "current_token_royalty_v1"
"""
enum current_token_royalty_v1_select_column {
  """column name"""
  inserted_at

  """column name"""
  last_transaction_timestamp

  """column name"""
  last_transaction_version

  """column name"""
  payee_address

  """column name"""
  royalty_points_denominator

  """column name"""
  royalty_points_numerator

  """column name"""
  token_data_id
}

"""
input type for updating data in table "current_token_royalty_v1"
"""
input current_token_royalty_v1_set_input {
  inserted_at: timestamp
  last_transaction_timestamp: timestamp
  last_transaction_version: bigint
  payee_address: String
  royalty_points_denominator: numeric
  royalty_points_numerator: numeric
  token_data_id: String
}

"""aggregate stddev on columns"""
type current_token_royalty_v1_stddev_fields {
  last_transaction_version: Float
  royalty_points_denominator: Float
  royalty_points_numerator: Float
}

"""aggregate stddev_pop on columns"""
type current_token_royalty_v1_stddev_pop_fields {
  last_transaction_version: Float
  royalty_points_denominator: Float
  royalty_points_numerator: Float
}

"""aggregate stddev_samp on columns"""
type current_token_royalty_v1_stddev_samp_fields {
  last_transaction_version: Float
  royalty_points_denominator: Float
  royalty_points_numerator: Float
}

"""
Streaming cursor of the table "current_token_royalty_v1"
"""
input current_token_royalty_v1_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: current_token_royalty_v1_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input current_token_royalty_v1_stream_cursor_value_input {
  inserted_at: timestamp
  last_transaction_timestamp: timestamp
  last_transaction_version: bigint
  payee_address: String
  royalty_points_denominator: numeric
  royalty_points_numerator: numeric
  token_data_id: String
}

"""aggregate sum on columns"""
type current_token_royalty_v1_sum_fields {
  last_transaction_version: bigint
  royalty_points_denominator: numeric
  royalty_points_numerator: numeric
}

"""
update columns of table "current_token_royalty_v1"
"""
enum current_token_royalty_v1_update_column {
  """column name"""
  inserted_at

  """column name"""
  last_transaction_timestamp

  """column name"""
  last_transaction_version

  """column name"""
  payee_address

  """column name"""
  royalty_points_denominator

  """column name"""
  royalty_points_numerator

  """column name"""
  token_data_id
}

input current_token_royalty_v1_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: current_token_royalty_v1_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: current_token_royalty_v1_set_input

  """filter the rows which have to be updated"""
  where: current_token_royalty_v1_bool_exp!
}

"""aggregate var_pop on columns"""
type current_token_royalty_v1_var_pop_fields {
  last_transaction_version: Float
  royalty_points_denominator: Float
  royalty_points_numerator: Float
}

"""aggregate var_samp on columns"""
type current_token_royalty_v1_var_samp_fields {
  last_transaction_version: Float
  royalty_points_denominator: Float
  royalty_points_numerator: Float
}

"""aggregate variance on columns"""
type current_token_royalty_v1_variance_fields {
  last_transaction_version: Float
  royalty_points_denominator: Float
  royalty_points_numerator: Float
}

"""ordering argument of a cursor"""
enum cursor_ordering {
  """ascending ordering of the cursor"""
  ASC

  """descending ordering of the cursor"""
  DESC
}

"""
columns and relationships of "delegated_staking_activities"
"""
type delegated_staking_activities {
  amount: numeric!
  delegator_address: String!
  event_index: bigint!
  event_type: String!
  inserted_at: timestamp!
  pool_address: String!
  transaction_version: bigint!
}

"""
aggregated selection of "delegated_staking_activities"
"""
type delegated_staking_activities_aggregate {
  aggregate: delegated_staking_activities_aggregate_fields
  nodes: [delegated_staking_activities!]!
}

input delegated_staking_activities_aggregate_bool_exp {
  count: delegated_staking_activities_aggregate_bool_exp_count
}

input delegated_staking_activities_aggregate_bool_exp_count {
  arguments: [delegated_staking_activities_select_column!]
  distinct: Boolean
  filter: delegated_staking_activities_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "delegated_staking_activities"
"""
type delegated_staking_activities_aggregate_fields {
  avg: delegated_staking_activities_avg_fields
  count(columns: [delegated_staking_activities_select_column!], distinct: Boolean): Int!
  max: delegated_staking_activities_max_fields
  min: delegated_staking_activities_min_fields
  stddev: delegated_staking_activities_stddev_fields
  stddev_pop: delegated_staking_activities_stddev_pop_fields
  stddev_samp: delegated_staking_activities_stddev_samp_fields
  sum: delegated_staking_activities_sum_fields
  var_pop: delegated_staking_activities_var_pop_fields
  var_samp: delegated_staking_activities_var_samp_fields
  variance: delegated_staking_activities_variance_fields
}

"""
order by aggregate values of table "delegated_staking_activities"
"""
input delegated_staking_activities_aggregate_order_by {
  avg: delegated_staking_activities_avg_order_by
  count: order_by
  max: delegated_staking_activities_max_order_by
  min: delegated_staking_activities_min_order_by
  stddev: delegated_staking_activities_stddev_order_by
  stddev_pop: delegated_staking_activities_stddev_pop_order_by
  stddev_samp: delegated_staking_activities_stddev_samp_order_by
  sum: delegated_staking_activities_sum_order_by
  var_pop: delegated_staking_activities_var_pop_order_by
  var_samp: delegated_staking_activities_var_samp_order_by
  variance: delegated_staking_activities_variance_order_by
}

"""
input type for inserting array relation for remote table "delegated_staking_activities"
"""
input delegated_staking_activities_arr_rel_insert_input {
  data: [delegated_staking_activities_insert_input!]!

  """upsert condition"""
  on_conflict: delegated_staking_activities_on_conflict
}

"""aggregate avg on columns"""
type delegated_staking_activities_avg_fields {
  amount: Float
  event_index: Float
  transaction_version: Float
}

"""
order by avg() on columns of table "delegated_staking_activities"
"""
input delegated_staking_activities_avg_order_by {
  amount: order_by
  event_index: order_by
  transaction_version: order_by
}

"""
Boolean expression to filter rows from the table "delegated_staking_activities". All fields are combined with a logical 'AND'.
"""
input delegated_staking_activities_bool_exp {
  _and: [delegated_staking_activities_bool_exp!]
  _not: delegated_staking_activities_bool_exp
  _or: [delegated_staking_activities_bool_exp!]
  amount: numeric_comparison_exp
  delegator_address: String_comparison_exp
  event_index: bigint_comparison_exp
  event_type: String_comparison_exp
  inserted_at: timestamp_comparison_exp
  pool_address: String_comparison_exp
  transaction_version: bigint_comparison_exp
}

"""
unique or primary key constraints on table "delegated_staking_activities"
"""
enum delegated_staking_activities_constraint {
  """
  unique or primary key constraint on columns "transaction_version", "event_index"
  """
  delegated_staking_activities_pkey
}

"""
input type for incrementing numeric columns in table "delegated_staking_activities"
"""
input delegated_staking_activities_inc_input {
  amount: numeric
  event_index: bigint
  transaction_version: bigint
}

"""
input type for inserting data into table "delegated_staking_activities"
"""
input delegated_staking_activities_insert_input {
  amount: numeric
  delegator_address: String
  event_index: bigint
  event_type: String
  inserted_at: timestamp
  pool_address: String
  transaction_version: bigint
}

"""aggregate max on columns"""
type delegated_staking_activities_max_fields {
  amount: numeric
  delegator_address: String
  event_index: bigint
  event_type: String
  inserted_at: timestamp
  pool_address: String
  transaction_version: bigint
}

"""
order by max() on columns of table "delegated_staking_activities"
"""
input delegated_staking_activities_max_order_by {
  amount: order_by
  delegator_address: order_by
  event_index: order_by
  event_type: order_by
  inserted_at: order_by
  pool_address: order_by
  transaction_version: order_by
}

"""aggregate min on columns"""
type delegated_staking_activities_min_fields {
  amount: numeric
  delegator_address: String
  event_index: bigint
  event_type: String
  inserted_at: timestamp
  pool_address: String
  transaction_version: bigint
}

"""
order by min() on columns of table "delegated_staking_activities"
"""
input delegated_staking_activities_min_order_by {
  amount: order_by
  delegator_address: order_by
  event_index: order_by
  event_type: order_by
  inserted_at: order_by
  pool_address: order_by
  transaction_version: order_by
}

"""
response of any mutation on the table "delegated_staking_activities"
"""
type delegated_staking_activities_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [delegated_staking_activities!]!
}

"""
on_conflict condition type for table "delegated_staking_activities"
"""
input delegated_staking_activities_on_conflict {
  constraint: delegated_staking_activities_constraint!
  update_columns: [delegated_staking_activities_update_column!]! = []
  where: delegated_staking_activities_bool_exp
}

"""
Ordering options when selecting data from "delegated_staking_activities".
"""
input delegated_staking_activities_order_by {
  amount: order_by
  delegator_address: order_by
  event_index: order_by
  event_type: order_by
  inserted_at: order_by
  pool_address: order_by
  transaction_version: order_by
}

"""primary key columns input for table: delegated_staking_activities"""
input delegated_staking_activities_pk_columns_input {
  event_index: bigint!
  transaction_version: bigint!
}

"""
select columns of table "delegated_staking_activities"
"""
enum delegated_staking_activities_select_column {
  """column name"""
  amount

  """column name"""
  delegator_address

  """column name"""
  event_index

  """column name"""
  event_type

  """column name"""
  inserted_at

  """column name"""
  pool_address

  """column name"""
  transaction_version
}

"""
input type for updating data in table "delegated_staking_activities"
"""
input delegated_staking_activities_set_input {
  amount: numeric
  delegator_address: String
  event_index: bigint
  event_type: String
  inserted_at: timestamp
  pool_address: String
  transaction_version: bigint
}

"""aggregate stddev on columns"""
type delegated_staking_activities_stddev_fields {
  amount: Float
  event_index: Float
  transaction_version: Float
}

"""
order by stddev() on columns of table "delegated_staking_activities"
"""
input delegated_staking_activities_stddev_order_by {
  amount: order_by
  event_index: order_by
  transaction_version: order_by
}

"""aggregate stddev_pop on columns"""
type delegated_staking_activities_stddev_pop_fields {
  amount: Float
  event_index: Float
  transaction_version: Float
}

"""
order by stddev_pop() on columns of table "delegated_staking_activities"
"""
input delegated_staking_activities_stddev_pop_order_by {
  amount: order_by
  event_index: order_by
  transaction_version: order_by
}

"""aggregate stddev_samp on columns"""
type delegated_staking_activities_stddev_samp_fields {
  amount: Float
  event_index: Float
  transaction_version: Float
}

"""
order by stddev_samp() on columns of table "delegated_staking_activities"
"""
input delegated_staking_activities_stddev_samp_order_by {
  amount: order_by
  event_index: order_by
  transaction_version: order_by
}

"""
Streaming cursor of the table "delegated_staking_activities"
"""
input delegated_staking_activities_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: delegated_staking_activities_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input delegated_staking_activities_stream_cursor_value_input {
  amount: numeric
  delegator_address: String
  event_index: bigint
  event_type: String
  inserted_at: timestamp
  pool_address: String
  transaction_version: bigint
}

"""aggregate sum on columns"""
type delegated_staking_activities_sum_fields {
  amount: numeric
  event_index: bigint
  transaction_version: bigint
}

"""
order by sum() on columns of table "delegated_staking_activities"
"""
input delegated_staking_activities_sum_order_by {
  amount: order_by
  event_index: order_by
  transaction_version: order_by
}

"""
update columns of table "delegated_staking_activities"
"""
enum delegated_staking_activities_update_column {
  """column name"""
  amount

  """column name"""
  delegator_address

  """column name"""
  event_index

  """column name"""
  event_type

  """column name"""
  inserted_at

  """column name"""
  pool_address

  """column name"""
  transaction_version
}

input delegated_staking_activities_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: delegated_staking_activities_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: delegated_staking_activities_set_input

  """filter the rows which have to be updated"""
  where: delegated_staking_activities_bool_exp!
}

"""aggregate var_pop on columns"""
type delegated_staking_activities_var_pop_fields {
  amount: Float
  event_index: Float
  transaction_version: Float
}

"""
order by var_pop() on columns of table "delegated_staking_activities"
"""
input delegated_staking_activities_var_pop_order_by {
  amount: order_by
  event_index: order_by
  transaction_version: order_by
}

"""aggregate var_samp on columns"""
type delegated_staking_activities_var_samp_fields {
  amount: Float
  event_index: Float
  transaction_version: Float
}

"""
order by var_samp() on columns of table "delegated_staking_activities"
"""
input delegated_staking_activities_var_samp_order_by {
  amount: order_by
  event_index: order_by
  transaction_version: order_by
}

"""aggregate variance on columns"""
type delegated_staking_activities_variance_fields {
  amount: Float
  event_index: Float
  transaction_version: Float
}

"""
order by variance() on columns of table "delegated_staking_activities"
"""
input delegated_staking_activities_variance_order_by {
  amount: order_by
  event_index: order_by
  transaction_version: order_by
}

"""
columns and relationships of "delegated_staking_pool_balances"
"""
type delegated_staking_pool_balances {
  active_table_handle: String!
  inactive_table_handle: String!
  inserted_at: timestamp!
  operator_commission_percentage: numeric!
  staking_pool_address: String!
  total_coins: numeric!
  total_shares: numeric!
  transaction_version: bigint!
}

"""
aggregated selection of "delegated_staking_pool_balances"
"""
type delegated_staking_pool_balances_aggregate {
  aggregate: delegated_staking_pool_balances_aggregate_fields
  nodes: [delegated_staking_pool_balances!]!
}

"""
aggregate fields of "delegated_staking_pool_balances"
"""
type delegated_staking_pool_balances_aggregate_fields {
  avg: delegated_staking_pool_balances_avg_fields
  count(columns: [delegated_staking_pool_balances_select_column!], distinct: Boolean): Int!
  max: delegated_staking_pool_balances_max_fields
  min: delegated_staking_pool_balances_min_fields
  stddev: delegated_staking_pool_balances_stddev_fields
  stddev_pop: delegated_staking_pool_balances_stddev_pop_fields
  stddev_samp: delegated_staking_pool_balances_stddev_samp_fields
  sum: delegated_staking_pool_balances_sum_fields
  var_pop: delegated_staking_pool_balances_var_pop_fields
  var_samp: delegated_staking_pool_balances_var_samp_fields
  variance: delegated_staking_pool_balances_variance_fields
}

"""aggregate avg on columns"""
type delegated_staking_pool_balances_avg_fields {
  operator_commission_percentage: Float
  total_coins: Float
  total_shares: Float
  transaction_version: Float
}

"""
Boolean expression to filter rows from the table "delegated_staking_pool_balances". All fields are combined with a logical 'AND'.
"""
input delegated_staking_pool_balances_bool_exp {
  _and: [delegated_staking_pool_balances_bool_exp!]
  _not: delegated_staking_pool_balances_bool_exp
  _or: [delegated_staking_pool_balances_bool_exp!]
  active_table_handle: String_comparison_exp
  inactive_table_handle: String_comparison_exp
  inserted_at: timestamp_comparison_exp
  operator_commission_percentage: numeric_comparison_exp
  staking_pool_address: String_comparison_exp
  total_coins: numeric_comparison_exp
  total_shares: numeric_comparison_exp
  transaction_version: bigint_comparison_exp
}

"""
unique or primary key constraints on table "delegated_staking_pool_balances"
"""
enum delegated_staking_pool_balances_constraint {
  """
  unique or primary key constraint on columns "transaction_version", "staking_pool_address"
  """
  delegated_staking_pool_balances_pkey
}

"""
input type for incrementing numeric columns in table "delegated_staking_pool_balances"
"""
input delegated_staking_pool_balances_inc_input {
  operator_commission_percentage: numeric
  total_coins: numeric
  total_shares: numeric
  transaction_version: bigint
}

"""
input type for inserting data into table "delegated_staking_pool_balances"
"""
input delegated_staking_pool_balances_insert_input {
  active_table_handle: String
  inactive_table_handle: String
  inserted_at: timestamp
  operator_commission_percentage: numeric
  staking_pool_address: String
  total_coins: numeric
  total_shares: numeric
  transaction_version: bigint
}

"""aggregate max on columns"""
type delegated_staking_pool_balances_max_fields {
  active_table_handle: String
  inactive_table_handle: String
  inserted_at: timestamp
  operator_commission_percentage: numeric
  staking_pool_address: String
  total_coins: numeric
  total_shares: numeric
  transaction_version: bigint
}

"""aggregate min on columns"""
type delegated_staking_pool_balances_min_fields {
  active_table_handle: String
  inactive_table_handle: String
  inserted_at: timestamp
  operator_commission_percentage: numeric
  staking_pool_address: String
  total_coins: numeric
  total_shares: numeric
  transaction_version: bigint
}

"""
response of any mutation on the table "delegated_staking_pool_balances"
"""
type delegated_staking_pool_balances_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [delegated_staking_pool_balances!]!
}

"""
on_conflict condition type for table "delegated_staking_pool_balances"
"""
input delegated_staking_pool_balances_on_conflict {
  constraint: delegated_staking_pool_balances_constraint!
  update_columns: [delegated_staking_pool_balances_update_column!]! = []
  where: delegated_staking_pool_balances_bool_exp
}

"""
Ordering options when selecting data from "delegated_staking_pool_balances".
"""
input delegated_staking_pool_balances_order_by {
  active_table_handle: order_by
  inactive_table_handle: order_by
  inserted_at: order_by
  operator_commission_percentage: order_by
  staking_pool_address: order_by
  total_coins: order_by
  total_shares: order_by
  transaction_version: order_by
}

"""primary key columns input for table: delegated_staking_pool_balances"""
input delegated_staking_pool_balances_pk_columns_input {
  staking_pool_address: String!
  transaction_version: bigint!
}

"""
select columns of table "delegated_staking_pool_balances"
"""
enum delegated_staking_pool_balances_select_column {
  """column name"""
  active_table_handle

  """column name"""
  inactive_table_handle

  """column name"""
  inserted_at

  """column name"""
  operator_commission_percentage

  """column name"""
  staking_pool_address

  """column name"""
  total_coins

  """column name"""
  total_shares

  """column name"""
  transaction_version
}

"""
input type for updating data in table "delegated_staking_pool_balances"
"""
input delegated_staking_pool_balances_set_input {
  active_table_handle: String
  inactive_table_handle: String
  inserted_at: timestamp
  operator_commission_percentage: numeric
  staking_pool_address: String
  total_coins: numeric
  total_shares: numeric
  transaction_version: bigint
}

"""aggregate stddev on columns"""
type delegated_staking_pool_balances_stddev_fields {
  operator_commission_percentage: Float
  total_coins: Float
  total_shares: Float
  transaction_version: Float
}

"""aggregate stddev_pop on columns"""
type delegated_staking_pool_balances_stddev_pop_fields {
  operator_commission_percentage: Float
  total_coins: Float
  total_shares: Float
  transaction_version: Float
}

"""aggregate stddev_samp on columns"""
type delegated_staking_pool_balances_stddev_samp_fields {
  operator_commission_percentage: Float
  total_coins: Float
  total_shares: Float
  transaction_version: Float
}

"""
Streaming cursor of the table "delegated_staking_pool_balances"
"""
input delegated_staking_pool_balances_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: delegated_staking_pool_balances_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input delegated_staking_pool_balances_stream_cursor_value_input {
  active_table_handle: String
  inactive_table_handle: String
  inserted_at: timestamp
  operator_commission_percentage: numeric
  staking_pool_address: String
  total_coins: numeric
  total_shares: numeric
  transaction_version: bigint
}

"""aggregate sum on columns"""
type delegated_staking_pool_balances_sum_fields {
  operator_commission_percentage: numeric
  total_coins: numeric
  total_shares: numeric
  transaction_version: bigint
}

"""
update columns of table "delegated_staking_pool_balances"
"""
enum delegated_staking_pool_balances_update_column {
  """column name"""
  active_table_handle

  """column name"""
  inactive_table_handle

  """column name"""
  inserted_at

  """column name"""
  operator_commission_percentage

  """column name"""
  staking_pool_address

  """column name"""
  total_coins

  """column name"""
  total_shares

  """column name"""
  transaction_version
}

input delegated_staking_pool_balances_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: delegated_staking_pool_balances_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: delegated_staking_pool_balances_set_input

  """filter the rows which have to be updated"""
  where: delegated_staking_pool_balances_bool_exp!
}

"""aggregate var_pop on columns"""
type delegated_staking_pool_balances_var_pop_fields {
  operator_commission_percentage: Float
  total_coins: Float
  total_shares: Float
  transaction_version: Float
}

"""aggregate var_samp on columns"""
type delegated_staking_pool_balances_var_samp_fields {
  operator_commission_percentage: Float
  total_coins: Float
  total_shares: Float
  transaction_version: Float
}

"""aggregate variance on columns"""
type delegated_staking_pool_balances_variance_fields {
  operator_commission_percentage: Float
  total_coins: Float
  total_shares: Float
  transaction_version: Float
}

"""
columns and relationships of "delegated_staking_pools"
"""
type delegated_staking_pools {
  """An object relationship"""
  current_staking_pool: current_staking_pool_voter
  first_transaction_version: bigint!
  inserted_at: timestamp!
  staking_pool_address: String!
}

"""
aggregated selection of "delegated_staking_pools"
"""
type delegated_staking_pools_aggregate {
  aggregate: delegated_staking_pools_aggregate_fields
  nodes: [delegated_staking_pools!]!
}

"""
aggregate fields of "delegated_staking_pools"
"""
type delegated_staking_pools_aggregate_fields {
  avg: delegated_staking_pools_avg_fields
  count(columns: [delegated_staking_pools_select_column!], distinct: Boolean): Int!
  max: delegated_staking_pools_max_fields
  min: delegated_staking_pools_min_fields
  stddev: delegated_staking_pools_stddev_fields
  stddev_pop: delegated_staking_pools_stddev_pop_fields
  stddev_samp: delegated_staking_pools_stddev_samp_fields
  sum: delegated_staking_pools_sum_fields
  var_pop: delegated_staking_pools_var_pop_fields
  var_samp: delegated_staking_pools_var_samp_fields
  variance: delegated_staking_pools_variance_fields
}

"""aggregate avg on columns"""
type delegated_staking_pools_avg_fields {
  first_transaction_version: Float
}

"""
Boolean expression to filter rows from the table "delegated_staking_pools". All fields are combined with a logical 'AND'.
"""
input delegated_staking_pools_bool_exp {
  _and: [delegated_staking_pools_bool_exp!]
  _not: delegated_staking_pools_bool_exp
  _or: [delegated_staking_pools_bool_exp!]
  current_staking_pool: current_staking_pool_voter_bool_exp
  first_transaction_version: bigint_comparison_exp
  inserted_at: timestamp_comparison_exp
  staking_pool_address: String_comparison_exp
}

"""
unique or primary key constraints on table "delegated_staking_pools"
"""
enum delegated_staking_pools_constraint {
  """
  unique or primary key constraint on columns "staking_pool_address"
  """
  delegated_staking_pools_pkey
}

"""
input type for incrementing numeric columns in table "delegated_staking_pools"
"""
input delegated_staking_pools_inc_input {
  first_transaction_version: bigint
}

"""
input type for inserting data into table "delegated_staking_pools"
"""
input delegated_staking_pools_insert_input {
  current_staking_pool: current_staking_pool_voter_obj_rel_insert_input
  first_transaction_version: bigint
  inserted_at: timestamp
  staking_pool_address: String
}

"""aggregate max on columns"""
type delegated_staking_pools_max_fields {
  first_transaction_version: bigint
  inserted_at: timestamp
  staking_pool_address: String
}

"""aggregate min on columns"""
type delegated_staking_pools_min_fields {
  first_transaction_version: bigint
  inserted_at: timestamp
  staking_pool_address: String
}

"""
response of any mutation on the table "delegated_staking_pools"
"""
type delegated_staking_pools_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [delegated_staking_pools!]!
}

"""
on_conflict condition type for table "delegated_staking_pools"
"""
input delegated_staking_pools_on_conflict {
  constraint: delegated_staking_pools_constraint!
  update_columns: [delegated_staking_pools_update_column!]! = []
  where: delegated_staking_pools_bool_exp
}

"""Ordering options when selecting data from "delegated_staking_pools"."""
input delegated_staking_pools_order_by {
  current_staking_pool: current_staking_pool_voter_order_by
  first_transaction_version: order_by
  inserted_at: order_by
  staking_pool_address: order_by
}

"""primary key columns input for table: delegated_staking_pools"""
input delegated_staking_pools_pk_columns_input {
  staking_pool_address: String!
}

"""
select columns of table "delegated_staking_pools"
"""
enum delegated_staking_pools_select_column {
  """column name"""
  first_transaction_version

  """column name"""
  inserted_at

  """column name"""
  staking_pool_address
}

"""
input type for updating data in table "delegated_staking_pools"
"""
input delegated_staking_pools_set_input {
  first_transaction_version: bigint
  inserted_at: timestamp
  staking_pool_address: String
}

"""aggregate stddev on columns"""
type delegated_staking_pools_stddev_fields {
  first_transaction_version: Float
}

"""aggregate stddev_pop on columns"""
type delegated_staking_pools_stddev_pop_fields {
  first_transaction_version: Float
}

"""aggregate stddev_samp on columns"""
type delegated_staking_pools_stddev_samp_fields {
  first_transaction_version: Float
}

"""
Streaming cursor of the table "delegated_staking_pools"
"""
input delegated_staking_pools_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: delegated_staking_pools_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input delegated_staking_pools_stream_cursor_value_input {
  first_transaction_version: bigint
  inserted_at: timestamp
  staking_pool_address: String
}

"""aggregate sum on columns"""
type delegated_staking_pools_sum_fields {
  first_transaction_version: bigint
}

"""
update columns of table "delegated_staking_pools"
"""
enum delegated_staking_pools_update_column {
  """column name"""
  first_transaction_version

  """column name"""
  inserted_at

  """column name"""
  staking_pool_address
}

input delegated_staking_pools_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: delegated_staking_pools_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: delegated_staking_pools_set_input

  """filter the rows which have to be updated"""
  where: delegated_staking_pools_bool_exp!
}

"""aggregate var_pop on columns"""
type delegated_staking_pools_var_pop_fields {
  first_transaction_version: Float
}

"""aggregate var_samp on columns"""
type delegated_staking_pools_var_samp_fields {
  first_transaction_version: Float
}

"""aggregate variance on columns"""
type delegated_staking_pools_variance_fields {
  first_transaction_version: Float
}

"""
columns and relationships of "delegator_distinct_pool"
"""
type delegator_distinct_pool {
  """An object relationship"""
  current_pool_balance: current_delegated_staking_pool_balances
  delegator_address: String
  pool_address: String

  """An object relationship"""
  staking_pool_metadata: current_staking_pool_voter
}

"""
aggregated selection of "delegator_distinct_pool"
"""
type delegator_distinct_pool_aggregate {
  aggregate: delegator_distinct_pool_aggregate_fields
  nodes: [delegator_distinct_pool!]!
}

"""
aggregate fields of "delegator_distinct_pool"
"""
type delegator_distinct_pool_aggregate_fields {
  count(columns: [delegator_distinct_pool_select_column!], distinct: Boolean): Int!
  max: delegator_distinct_pool_max_fields
  min: delegator_distinct_pool_min_fields
}

"""
Boolean expression to filter rows from the table "delegator_distinct_pool". All fields are combined with a logical 'AND'.
"""
input delegator_distinct_pool_bool_exp {
  _and: [delegator_distinct_pool_bool_exp!]
  _not: delegator_distinct_pool_bool_exp
  _or: [delegator_distinct_pool_bool_exp!]
  current_pool_balance: current_delegated_staking_pool_balances_bool_exp
  delegator_address: String_comparison_exp
  pool_address: String_comparison_exp
  staking_pool_metadata: current_staking_pool_voter_bool_exp
}

"""aggregate max on columns"""
type delegator_distinct_pool_max_fields {
  delegator_address: String
  pool_address: String
}

"""aggregate min on columns"""
type delegator_distinct_pool_min_fields {
  delegator_address: String
  pool_address: String
}

"""Ordering options when selecting data from "delegator_distinct_pool"."""
input delegator_distinct_pool_order_by {
  current_pool_balance: current_delegated_staking_pool_balances_order_by
  delegator_address: order_by
  pool_address: order_by
  staking_pool_metadata: current_staking_pool_voter_order_by
}

"""
select columns of table "delegator_distinct_pool"
"""
enum delegator_distinct_pool_select_column {
  """column name"""
  delegator_address

  """column name"""
  pool_address
}

"""
Streaming cursor of the table "delegator_distinct_pool"
"""
input delegator_distinct_pool_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: delegator_distinct_pool_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input delegator_distinct_pool_stream_cursor_value_input {
  delegator_address: String
  pool_address: String
}

"""
columns and relationships of "events"
"""
type events {
  account_address: String!
  creation_number: bigint!
  data(
    """JSON select path"""
    path: String
  ): jsonb!
  event_index: bigint!
  indexed_type: String!
  inserted_at: timestamp!
  sequence_number: bigint!
  transaction_block_height: bigint!
  transaction_version: bigint!
  type: String!
}

"""
aggregated selection of "events"
"""
type events_aggregate {
  aggregate: events_aggregate_fields
  nodes: [events!]!
}

"""
aggregate fields of "events"
"""
type events_aggregate_fields {
  avg: events_avg_fields
  count(columns: [events_select_column!], distinct: Boolean): Int!
  max: events_max_fields
  min: events_min_fields
  stddev: events_stddev_fields
  stddev_pop: events_stddev_pop_fields
  stddev_samp: events_stddev_samp_fields
  sum: events_sum_fields
  var_pop: events_var_pop_fields
  var_samp: events_var_samp_fields
  variance: events_variance_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input events_append_input {
  data: jsonb
}

"""aggregate avg on columns"""
type events_avg_fields {
  creation_number: Float
  event_index: Float
  sequence_number: Float
  transaction_block_height: Float
  transaction_version: Float
}

"""
Boolean expression to filter rows from the table "events". All fields are combined with a logical 'AND'.
"""
input events_bool_exp {
  _and: [events_bool_exp!]
  _not: events_bool_exp
  _or: [events_bool_exp!]
  account_address: String_comparison_exp
  creation_number: bigint_comparison_exp
  data: jsonb_comparison_exp
  event_index: bigint_comparison_exp
  indexed_type: String_comparison_exp
  inserted_at: timestamp_comparison_exp
  sequence_number: bigint_comparison_exp
  transaction_block_height: bigint_comparison_exp
  transaction_version: bigint_comparison_exp
  type: String_comparison_exp
}

"""
unique or primary key constraints on table "events"
"""
enum events_constraint {
  """
  unique or primary key constraint on columns "transaction_version", "event_index"
  """
  events_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input events_delete_at_path_input {
  data: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input events_delete_elem_input {
  data: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input events_delete_key_input {
  data: String
}

"""
input type for incrementing numeric columns in table "events"
"""
input events_inc_input {
  creation_number: bigint
  event_index: bigint
  sequence_number: bigint
  transaction_block_height: bigint
  transaction_version: bigint
}

"""
input type for inserting data into table "events"
"""
input events_insert_input {
  account_address: String
  creation_number: bigint
  data: jsonb
  event_index: bigint
  indexed_type: String
  inserted_at: timestamp
  sequence_number: bigint
  transaction_block_height: bigint
  transaction_version: bigint
  type: String
}

"""aggregate max on columns"""
type events_max_fields {
  account_address: String
  creation_number: bigint
  event_index: bigint
  indexed_type: String
  inserted_at: timestamp
  sequence_number: bigint
  transaction_block_height: bigint
  transaction_version: bigint
  type: String
}

"""aggregate min on columns"""
type events_min_fields {
  account_address: String
  creation_number: bigint
  event_index: bigint
  indexed_type: String
  inserted_at: timestamp
  sequence_number: bigint
  transaction_block_height: bigint
  transaction_version: bigint
  type: String
}

"""
response of any mutation on the table "events"
"""
type events_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [events!]!
}

"""
on_conflict condition type for table "events"
"""
input events_on_conflict {
  constraint: events_constraint!
  update_columns: [events_update_column!]! = []
  where: events_bool_exp
}

"""Ordering options when selecting data from "events"."""
input events_order_by {
  account_address: order_by
  creation_number: order_by
  data: order_by
  event_index: order_by
  indexed_type: order_by
  inserted_at: order_by
  sequence_number: order_by
  transaction_block_height: order_by
  transaction_version: order_by
  type: order_by
}

"""primary key columns input for table: events"""
input events_pk_columns_input {
  event_index: bigint!
  transaction_version: bigint!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input events_prepend_input {
  data: jsonb
}

"""
select columns of table "events"
"""
enum events_select_column {
  """column name"""
  account_address

  """column name"""
  creation_number

  """column name"""
  data

  """column name"""
  event_index

  """column name"""
  indexed_type

  """column name"""
  inserted_at

  """column name"""
  sequence_number

  """column name"""
  transaction_block_height

  """column name"""
  transaction_version

  """column name"""
  type
}

"""
input type for updating data in table "events"
"""
input events_set_input {
  account_address: String
  creation_number: bigint
  data: jsonb
  event_index: bigint
  indexed_type: String
  inserted_at: timestamp
  sequence_number: bigint
  transaction_block_height: bigint
  transaction_version: bigint
  type: String
}

"""aggregate stddev on columns"""
type events_stddev_fields {
  creation_number: Float
  event_index: Float
  sequence_number: Float
  transaction_block_height: Float
  transaction_version: Float
}

"""aggregate stddev_pop on columns"""
type events_stddev_pop_fields {
  creation_number: Float
  event_index: Float
  sequence_number: Float
  transaction_block_height: Float
  transaction_version: Float
}

"""aggregate stddev_samp on columns"""
type events_stddev_samp_fields {
  creation_number: Float
  event_index: Float
  sequence_number: Float
  transaction_block_height: Float
  transaction_version: Float
}

"""
Streaming cursor of the table "events"
"""
input events_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: events_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input events_stream_cursor_value_input {
  account_address: String
  creation_number: bigint
  data: jsonb
  event_index: bigint
  indexed_type: String
  inserted_at: timestamp
  sequence_number: bigint
  transaction_block_height: bigint
  transaction_version: bigint
  type: String
}

"""aggregate sum on columns"""
type events_sum_fields {
  creation_number: bigint
  event_index: bigint
  sequence_number: bigint
  transaction_block_height: bigint
  transaction_version: bigint
}

"""
update columns of table "events"
"""
enum events_update_column {
  """column name"""
  account_address

  """column name"""
  creation_number

  """column name"""
  data

  """column name"""
  event_index

  """column name"""
  indexed_type

  """column name"""
  inserted_at

  """column name"""
  sequence_number

  """column name"""
  transaction_block_height

  """column name"""
  transaction_version

  """column name"""
  type
}

input events_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: events_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: events_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: events_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: events_delete_key_input

  """increments the numeric columns with given value of the filtered values"""
  _inc: events_inc_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: events_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: events_set_input

  """filter the rows which have to be updated"""
  where: events_bool_exp!
}

"""aggregate var_pop on columns"""
type events_var_pop_fields {
  creation_number: Float
  event_index: Float
  sequence_number: Float
  transaction_block_height: Float
  transaction_version: Float
}

"""aggregate var_samp on columns"""
type events_var_samp_fields {
  creation_number: Float
  event_index: Float
  sequence_number: Float
  transaction_block_height: Float
  transaction_version: Float
}

"""aggregate variance on columns"""
type events_variance_fields {
  creation_number: Float
  event_index: Float
  sequence_number: Float
  transaction_block_height: Float
  transaction_version: Float
}

"""
columns and relationships of "fungible_asset_activities"
"""
type fungible_asset_activities {
  amount: numeric
  asset_type: String
  block_height: bigint!
  entry_function_id_str: String
  event_index: bigint!
  gas_fee_payer_address: String
  inserted_at: timestamp!
  is_frozen: Boolean
  is_gas_fee: Boolean!
  is_transaction_success: Boolean!

  """An object relationship"""
  metadata: fungible_asset_metadata
  owner_address: String

  """An array relationship"""
  owner_aptos_names(
    """distinct select on columns"""
    distinct_on: [current_aptos_names_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_aptos_names_order_by!]

    """filter the rows returned"""
    where: current_aptos_names_bool_exp
  ): [current_aptos_names!]!

  """An aggregate relationship"""
  owner_aptos_names_aggregate(
    """distinct select on columns"""
    distinct_on: [current_aptos_names_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_aptos_names_order_by!]

    """filter the rows returned"""
    where: current_aptos_names_bool_exp
  ): current_aptos_names_aggregate!
  storage_id: String!
  storage_refund_amount: numeric!
  token_standard: String!
  transaction_timestamp: timestamp!
  transaction_version: bigint!
  type: String!
}

"""
aggregated selection of "fungible_asset_activities"
"""
type fungible_asset_activities_aggregate {
  aggregate: fungible_asset_activities_aggregate_fields
  nodes: [fungible_asset_activities!]!
}

input fungible_asset_activities_aggregate_bool_exp {
  bool_and: fungible_asset_activities_aggregate_bool_exp_bool_and
  bool_or: fungible_asset_activities_aggregate_bool_exp_bool_or
  count: fungible_asset_activities_aggregate_bool_exp_count
}

input fungible_asset_activities_aggregate_bool_exp_bool_and {
  arguments: fungible_asset_activities_select_column_fungible_asset_activities_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: fungible_asset_activities_bool_exp
  predicate: Boolean_comparison_exp!
}

input fungible_asset_activities_aggregate_bool_exp_bool_or {
  arguments: fungible_asset_activities_select_column_fungible_asset_activities_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: fungible_asset_activities_bool_exp
  predicate: Boolean_comparison_exp!
}

input fungible_asset_activities_aggregate_bool_exp_count {
  arguments: [fungible_asset_activities_select_column!]
  distinct: Boolean
  filter: fungible_asset_activities_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "fungible_asset_activities"
"""
type fungible_asset_activities_aggregate_fields {
  avg: fungible_asset_activities_avg_fields
  count(columns: [fungible_asset_activities_select_column!], distinct: Boolean): Int!
  max: fungible_asset_activities_max_fields
  min: fungible_asset_activities_min_fields
  stddev: fungible_asset_activities_stddev_fields
  stddev_pop: fungible_asset_activities_stddev_pop_fields
  stddev_samp: fungible_asset_activities_stddev_samp_fields
  sum: fungible_asset_activities_sum_fields
  var_pop: fungible_asset_activities_var_pop_fields
  var_samp: fungible_asset_activities_var_samp_fields
  variance: fungible_asset_activities_variance_fields
}

"""
order by aggregate values of table "fungible_asset_activities"
"""
input fungible_asset_activities_aggregate_order_by {
  avg: fungible_asset_activities_avg_order_by
  count: order_by
  max: fungible_asset_activities_max_order_by
  min: fungible_asset_activities_min_order_by
  stddev: fungible_asset_activities_stddev_order_by
  stddev_pop: fungible_asset_activities_stddev_pop_order_by
  stddev_samp: fungible_asset_activities_stddev_samp_order_by
  sum: fungible_asset_activities_sum_order_by
  var_pop: fungible_asset_activities_var_pop_order_by
  var_samp: fungible_asset_activities_var_samp_order_by
  variance: fungible_asset_activities_variance_order_by
}

"""
input type for inserting array relation for remote table "fungible_asset_activities"
"""
input fungible_asset_activities_arr_rel_insert_input {
  data: [fungible_asset_activities_insert_input!]!

  """upsert condition"""
  on_conflict: fungible_asset_activities_on_conflict
}

"""aggregate avg on columns"""
type fungible_asset_activities_avg_fields {
  amount: Float
  block_height: Float
  event_index: Float
  storage_refund_amount: Float
  transaction_version: Float
}

"""
order by avg() on columns of table "fungible_asset_activities"
"""
input fungible_asset_activities_avg_order_by {
  amount: order_by
  block_height: order_by
  event_index: order_by
  storage_refund_amount: order_by
  transaction_version: order_by
}

"""
Boolean expression to filter rows from the table "fungible_asset_activities". All fields are combined with a logical 'AND'.
"""
input fungible_asset_activities_bool_exp {
  _and: [fungible_asset_activities_bool_exp!]
  _not: fungible_asset_activities_bool_exp
  _or: [fungible_asset_activities_bool_exp!]
  amount: numeric_comparison_exp
  asset_type: String_comparison_exp
  block_height: bigint_comparison_exp
  entry_function_id_str: String_comparison_exp
  event_index: bigint_comparison_exp
  gas_fee_payer_address: String_comparison_exp
  inserted_at: timestamp_comparison_exp
  is_frozen: Boolean_comparison_exp
  is_gas_fee: Boolean_comparison_exp
  is_transaction_success: Boolean_comparison_exp
  metadata: fungible_asset_metadata_bool_exp
  owner_address: String_comparison_exp
  owner_aptos_names: current_aptos_names_bool_exp
  owner_aptos_names_aggregate: current_aptos_names_aggregate_bool_exp
  storage_id: String_comparison_exp
  storage_refund_amount: numeric_comparison_exp
  token_standard: String_comparison_exp
  transaction_timestamp: timestamp_comparison_exp
  transaction_version: bigint_comparison_exp
  type: String_comparison_exp
}

"""
unique or primary key constraints on table "fungible_asset_activities"
"""
enum fungible_asset_activities_constraint {
  """
  unique or primary key constraint on columns "transaction_version", "event_index"
  """
  fungible_asset_activities_pkey
}

"""
input type for incrementing numeric columns in table "fungible_asset_activities"
"""
input fungible_asset_activities_inc_input {
  amount: numeric
  block_height: bigint
  event_index: bigint
  storage_refund_amount: numeric
  transaction_version: bigint
}

"""
input type for inserting data into table "fungible_asset_activities"
"""
input fungible_asset_activities_insert_input {
  amount: numeric
  asset_type: String
  block_height: bigint
  entry_function_id_str: String
  event_index: bigint
  gas_fee_payer_address: String
  inserted_at: timestamp
  is_frozen: Boolean
  is_gas_fee: Boolean
  is_transaction_success: Boolean
  metadata: fungible_asset_metadata_obj_rel_insert_input
  owner_address: String
  owner_aptos_names: current_aptos_names_arr_rel_insert_input
  storage_id: String
  storage_refund_amount: numeric
  token_standard: String
  transaction_timestamp: timestamp
  transaction_version: bigint
  type: String
}

"""aggregate max on columns"""
type fungible_asset_activities_max_fields {
  amount: numeric
  asset_type: String
  block_height: bigint
  entry_function_id_str: String
  event_index: bigint
  gas_fee_payer_address: String
  inserted_at: timestamp
  owner_address: String
  storage_id: String
  storage_refund_amount: numeric
  token_standard: String
  transaction_timestamp: timestamp
  transaction_version: bigint
  type: String
}

"""
order by max() on columns of table "fungible_asset_activities"
"""
input fungible_asset_activities_max_order_by {
  amount: order_by
  asset_type: order_by
  block_height: order_by
  entry_function_id_str: order_by
  event_index: order_by
  gas_fee_payer_address: order_by
  inserted_at: order_by
  owner_address: order_by
  storage_id: order_by
  storage_refund_amount: order_by
  token_standard: order_by
  transaction_timestamp: order_by
  transaction_version: order_by
  type: order_by
}

"""aggregate min on columns"""
type fungible_asset_activities_min_fields {
  amount: numeric
  asset_type: String
  block_height: bigint
  entry_function_id_str: String
  event_index: bigint
  gas_fee_payer_address: String
  inserted_at: timestamp
  owner_address: String
  storage_id: String
  storage_refund_amount: numeric
  token_standard: String
  transaction_timestamp: timestamp
  transaction_version: bigint
  type: String
}

"""
order by min() on columns of table "fungible_asset_activities"
"""
input fungible_asset_activities_min_order_by {
  amount: order_by
  asset_type: order_by
  block_height: order_by
  entry_function_id_str: order_by
  event_index: order_by
  gas_fee_payer_address: order_by
  inserted_at: order_by
  owner_address: order_by
  storage_id: order_by
  storage_refund_amount: order_by
  token_standard: order_by
  transaction_timestamp: order_by
  transaction_version: order_by
  type: order_by
}

"""
response of any mutation on the table "fungible_asset_activities"
"""
type fungible_asset_activities_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [fungible_asset_activities!]!
}

"""
on_conflict condition type for table "fungible_asset_activities"
"""
input fungible_asset_activities_on_conflict {
  constraint: fungible_asset_activities_constraint!
  update_columns: [fungible_asset_activities_update_column!]! = []
  where: fungible_asset_activities_bool_exp
}

"""Ordering options when selecting data from "fungible_asset_activities"."""
input fungible_asset_activities_order_by {
  amount: order_by
  asset_type: order_by
  block_height: order_by
  entry_function_id_str: order_by
  event_index: order_by
  gas_fee_payer_address: order_by
  inserted_at: order_by
  is_frozen: order_by
  is_gas_fee: order_by
  is_transaction_success: order_by
  metadata: fungible_asset_metadata_order_by
  owner_address: order_by
  owner_aptos_names_aggregate: current_aptos_names_aggregate_order_by
  storage_id: order_by
  storage_refund_amount: order_by
  token_standard: order_by
  transaction_timestamp: order_by
  transaction_version: order_by
  type: order_by
}

"""primary key columns input for table: fungible_asset_activities"""
input fungible_asset_activities_pk_columns_input {
  event_index: bigint!
  transaction_version: bigint!
}

"""
select columns of table "fungible_asset_activities"
"""
enum fungible_asset_activities_select_column {
  """column name"""
  amount

  """column name"""
  asset_type

  """column name"""
  block_height

  """column name"""
  entry_function_id_str

  """column name"""
  event_index

  """column name"""
  gas_fee_payer_address

  """column name"""
  inserted_at

  """column name"""
  is_frozen

  """column name"""
  is_gas_fee

  """column name"""
  is_transaction_success

  """column name"""
  owner_address

  """column name"""
  storage_id

  """column name"""
  storage_refund_amount

  """column name"""
  token_standard

  """column name"""
  transaction_timestamp

  """column name"""
  transaction_version

  """column name"""
  type
}

"""
select "fungible_asset_activities_aggregate_bool_exp_bool_and_arguments_columns" columns of table "fungible_asset_activities"
"""
enum fungible_asset_activities_select_column_fungible_asset_activities_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  is_frozen

  """column name"""
  is_gas_fee

  """column name"""
  is_transaction_success
}

"""
select "fungible_asset_activities_aggregate_bool_exp_bool_or_arguments_columns" columns of table "fungible_asset_activities"
"""
enum fungible_asset_activities_select_column_fungible_asset_activities_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  is_frozen

  """column name"""
  is_gas_fee

  """column name"""
  is_transaction_success
}

"""
input type for updating data in table "fungible_asset_activities"
"""
input fungible_asset_activities_set_input {
  amount: numeric
  asset_type: String
  block_height: bigint
  entry_function_id_str: String
  event_index: bigint
  gas_fee_payer_address: String
  inserted_at: timestamp
  is_frozen: Boolean
  is_gas_fee: Boolean
  is_transaction_success: Boolean
  owner_address: String
  storage_id: String
  storage_refund_amount: numeric
  token_standard: String
  transaction_timestamp: timestamp
  transaction_version: bigint
  type: String
}

"""aggregate stddev on columns"""
type fungible_asset_activities_stddev_fields {
  amount: Float
  block_height: Float
  event_index: Float
  storage_refund_amount: Float
  transaction_version: Float
}

"""
order by stddev() on columns of table "fungible_asset_activities"
"""
input fungible_asset_activities_stddev_order_by {
  amount: order_by
  block_height: order_by
  event_index: order_by
  storage_refund_amount: order_by
  transaction_version: order_by
}

"""aggregate stddev_pop on columns"""
type fungible_asset_activities_stddev_pop_fields {
  amount: Float
  block_height: Float
  event_index: Float
  storage_refund_amount: Float
  transaction_version: Float
}

"""
order by stddev_pop() on columns of table "fungible_asset_activities"
"""
input fungible_asset_activities_stddev_pop_order_by {
  amount: order_by
  block_height: order_by
  event_index: order_by
  storage_refund_amount: order_by
  transaction_version: order_by
}

"""aggregate stddev_samp on columns"""
type fungible_asset_activities_stddev_samp_fields {
  amount: Float
  block_height: Float
  event_index: Float
  storage_refund_amount: Float
  transaction_version: Float
}

"""
order by stddev_samp() on columns of table "fungible_asset_activities"
"""
input fungible_asset_activities_stddev_samp_order_by {
  amount: order_by
  block_height: order_by
  event_index: order_by
  storage_refund_amount: order_by
  transaction_version: order_by
}

"""
Streaming cursor of the table "fungible_asset_activities"
"""
input fungible_asset_activities_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: fungible_asset_activities_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input fungible_asset_activities_stream_cursor_value_input {
  amount: numeric
  asset_type: String
  block_height: bigint
  entry_function_id_str: String
  event_index: bigint
  gas_fee_payer_address: String
  inserted_at: timestamp
  is_frozen: Boolean
  is_gas_fee: Boolean
  is_transaction_success: Boolean
  owner_address: String
  storage_id: String
  storage_refund_amount: numeric
  token_standard: String
  transaction_timestamp: timestamp
  transaction_version: bigint
  type: String
}

"""aggregate sum on columns"""
type fungible_asset_activities_sum_fields {
  amount: numeric
  block_height: bigint
  event_index: bigint
  storage_refund_amount: numeric
  transaction_version: bigint
}

"""
order by sum() on columns of table "fungible_asset_activities"
"""
input fungible_asset_activities_sum_order_by {
  amount: order_by
  block_height: order_by
  event_index: order_by
  storage_refund_amount: order_by
  transaction_version: order_by
}

"""
update columns of table "fungible_asset_activities"
"""
enum fungible_asset_activities_update_column {
  """column name"""
  amount

  """column name"""
  asset_type

  """column name"""
  block_height

  """column name"""
  entry_function_id_str

  """column name"""
  event_index

  """column name"""
  gas_fee_payer_address

  """column name"""
  inserted_at

  """column name"""
  is_frozen

  """column name"""
  is_gas_fee

  """column name"""
  is_transaction_success

  """column name"""
  owner_address

  """column name"""
  storage_id

  """column name"""
  storage_refund_amount

  """column name"""
  token_standard

  """column name"""
  transaction_timestamp

  """column name"""
  transaction_version

  """column name"""
  type
}

input fungible_asset_activities_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: fungible_asset_activities_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: fungible_asset_activities_set_input

  """filter the rows which have to be updated"""
  where: fungible_asset_activities_bool_exp!
}

"""aggregate var_pop on columns"""
type fungible_asset_activities_var_pop_fields {
  amount: Float
  block_height: Float
  event_index: Float
  storage_refund_amount: Float
  transaction_version: Float
}

"""
order by var_pop() on columns of table "fungible_asset_activities"
"""
input fungible_asset_activities_var_pop_order_by {
  amount: order_by
  block_height: order_by
  event_index: order_by
  storage_refund_amount: order_by
  transaction_version: order_by
}

"""aggregate var_samp on columns"""
type fungible_asset_activities_var_samp_fields {
  amount: Float
  block_height: Float
  event_index: Float
  storage_refund_amount: Float
  transaction_version: Float
}

"""
order by var_samp() on columns of table "fungible_asset_activities"
"""
input fungible_asset_activities_var_samp_order_by {
  amount: order_by
  block_height: order_by
  event_index: order_by
  storage_refund_amount: order_by
  transaction_version: order_by
}

"""aggregate variance on columns"""
type fungible_asset_activities_variance_fields {
  amount: Float
  block_height: Float
  event_index: Float
  storage_refund_amount: Float
  transaction_version: Float
}

"""
order by variance() on columns of table "fungible_asset_activities"
"""
input fungible_asset_activities_variance_order_by {
  amount: order_by
  block_height: order_by
  event_index: order_by
  storage_refund_amount: order_by
  transaction_version: order_by
}

"""
columns and relationships of "fungible_asset_metadata"
"""
type fungible_asset_metadata {
  asset_type: String!
  creator_address: String!
  decimals: Int!
  icon_uri: String
  inserted_at: timestamp!
  is_token_v2: Boolean
  last_transaction_timestamp: timestamp!
  last_transaction_version: bigint!
  maximum_v2: numeric
  name: String!
  project_uri: String
  supply_aggregator_table_handle_v1: String
  supply_aggregator_table_key_v1: String
  supply_v2: numeric
  symbol: String!
  token_standard: String!
}

"""
aggregated selection of "fungible_asset_metadata"
"""
type fungible_asset_metadata_aggregate {
  aggregate: fungible_asset_metadata_aggregate_fields
  nodes: [fungible_asset_metadata!]!
}

"""
aggregate fields of "fungible_asset_metadata"
"""
type fungible_asset_metadata_aggregate_fields {
  avg: fungible_asset_metadata_avg_fields
  count(columns: [fungible_asset_metadata_select_column!], distinct: Boolean): Int!
  max: fungible_asset_metadata_max_fields
  min: fungible_asset_metadata_min_fields
  stddev: fungible_asset_metadata_stddev_fields
  stddev_pop: fungible_asset_metadata_stddev_pop_fields
  stddev_samp: fungible_asset_metadata_stddev_samp_fields
  sum: fungible_asset_metadata_sum_fields
  var_pop: fungible_asset_metadata_var_pop_fields
  var_samp: fungible_asset_metadata_var_samp_fields
  variance: fungible_asset_metadata_variance_fields
}

"""aggregate avg on columns"""
type fungible_asset_metadata_avg_fields {
  decimals: Float
  last_transaction_version: Float
  maximum_v2: Float
  supply_v2: Float
}

"""
Boolean expression to filter rows from the table "fungible_asset_metadata". All fields are combined with a logical 'AND'.
"""
input fungible_asset_metadata_bool_exp {
  _and: [fungible_asset_metadata_bool_exp!]
  _not: fungible_asset_metadata_bool_exp
  _or: [fungible_asset_metadata_bool_exp!]
  asset_type: String_comparison_exp
  creator_address: String_comparison_exp
  decimals: Int_comparison_exp
  icon_uri: String_comparison_exp
  inserted_at: timestamp_comparison_exp
  is_token_v2: Boolean_comparison_exp
  last_transaction_timestamp: timestamp_comparison_exp
  last_transaction_version: bigint_comparison_exp
  maximum_v2: numeric_comparison_exp
  name: String_comparison_exp
  project_uri: String_comparison_exp
  supply_aggregator_table_handle_v1: String_comparison_exp
  supply_aggregator_table_key_v1: String_comparison_exp
  supply_v2: numeric_comparison_exp
  symbol: String_comparison_exp
  token_standard: String_comparison_exp
}

"""
unique or primary key constraints on table "fungible_asset_metadata"
"""
enum fungible_asset_metadata_constraint {
  """
  unique or primary key constraint on columns "asset_type"
  """
  fungible_asset_metadata_pkey
}

"""
input type for incrementing numeric columns in table "fungible_asset_metadata"
"""
input fungible_asset_metadata_inc_input {
  decimals: Int
  last_transaction_version: bigint
  maximum_v2: numeric
  supply_v2: numeric
}

"""
input type for inserting data into table "fungible_asset_metadata"
"""
input fungible_asset_metadata_insert_input {
  asset_type: String
  creator_address: String
  decimals: Int
  icon_uri: String
  inserted_at: timestamp
  is_token_v2: Boolean
  last_transaction_timestamp: timestamp
  last_transaction_version: bigint
  maximum_v2: numeric
  name: String
  project_uri: String
  supply_aggregator_table_handle_v1: String
  supply_aggregator_table_key_v1: String
  supply_v2: numeric
  symbol: String
  token_standard: String
}

"""aggregate max on columns"""
type fungible_asset_metadata_max_fields {
  asset_type: String
  creator_address: String
  decimals: Int
  icon_uri: String
  inserted_at: timestamp
  last_transaction_timestamp: timestamp
  last_transaction_version: bigint
  maximum_v2: numeric
  name: String
  project_uri: String
  supply_aggregator_table_handle_v1: String
  supply_aggregator_table_key_v1: String
  supply_v2: numeric
  symbol: String
  token_standard: String
}

"""aggregate min on columns"""
type fungible_asset_metadata_min_fields {
  asset_type: String
  creator_address: String
  decimals: Int
  icon_uri: String
  inserted_at: timestamp
  last_transaction_timestamp: timestamp
  last_transaction_version: bigint
  maximum_v2: numeric
  name: String
  project_uri: String
  supply_aggregator_table_handle_v1: String
  supply_aggregator_table_key_v1: String
  supply_v2: numeric
  symbol: String
  token_standard: String
}

"""
response of any mutation on the table "fungible_asset_metadata"
"""
type fungible_asset_metadata_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [fungible_asset_metadata!]!
}

"""
input type for inserting object relation for remote table "fungible_asset_metadata"
"""
input fungible_asset_metadata_obj_rel_insert_input {
  data: fungible_asset_metadata_insert_input!

  """upsert condition"""
  on_conflict: fungible_asset_metadata_on_conflict
}

"""
on_conflict condition type for table "fungible_asset_metadata"
"""
input fungible_asset_metadata_on_conflict {
  constraint: fungible_asset_metadata_constraint!
  update_columns: [fungible_asset_metadata_update_column!]! = []
  where: fungible_asset_metadata_bool_exp
}

"""Ordering options when selecting data from "fungible_asset_metadata"."""
input fungible_asset_metadata_order_by {
  asset_type: order_by
  creator_address: order_by
  decimals: order_by
  icon_uri: order_by
  inserted_at: order_by
  is_token_v2: order_by
  last_transaction_timestamp: order_by
  last_transaction_version: order_by
  maximum_v2: order_by
  name: order_by
  project_uri: order_by
  supply_aggregator_table_handle_v1: order_by
  supply_aggregator_table_key_v1: order_by
  supply_v2: order_by
  symbol: order_by
  token_standard: order_by
}

"""primary key columns input for table: fungible_asset_metadata"""
input fungible_asset_metadata_pk_columns_input {
  asset_type: String!
}

"""
select columns of table "fungible_asset_metadata"
"""
enum fungible_asset_metadata_select_column {
  """column name"""
  asset_type

  """column name"""
  creator_address

  """column name"""
  decimals

  """column name"""
  icon_uri

  """column name"""
  inserted_at

  """column name"""
  is_token_v2

  """column name"""
  last_transaction_timestamp

  """column name"""
  last_transaction_version

  """column name"""
  maximum_v2

  """column name"""
  name

  """column name"""
  project_uri

  """column name"""
  supply_aggregator_table_handle_v1

  """column name"""
  supply_aggregator_table_key_v1

  """column name"""
  supply_v2

  """column name"""
  symbol

  """column name"""
  token_standard
}

"""
input type for updating data in table "fungible_asset_metadata"
"""
input fungible_asset_metadata_set_input {
  asset_type: String
  creator_address: String
  decimals: Int
  icon_uri: String
  inserted_at: timestamp
  is_token_v2: Boolean
  last_transaction_timestamp: timestamp
  last_transaction_version: bigint
  maximum_v2: numeric
  name: String
  project_uri: String
  supply_aggregator_table_handle_v1: String
  supply_aggregator_table_key_v1: String
  supply_v2: numeric
  symbol: String
  token_standard: String
}

"""aggregate stddev on columns"""
type fungible_asset_metadata_stddev_fields {
  decimals: Float
  last_transaction_version: Float
  maximum_v2: Float
  supply_v2: Float
}

"""aggregate stddev_pop on columns"""
type fungible_asset_metadata_stddev_pop_fields {
  decimals: Float
  last_transaction_version: Float
  maximum_v2: Float
  supply_v2: Float
}

"""aggregate stddev_samp on columns"""
type fungible_asset_metadata_stddev_samp_fields {
  decimals: Float
  last_transaction_version: Float
  maximum_v2: Float
  supply_v2: Float
}

"""
Streaming cursor of the table "fungible_asset_metadata"
"""
input fungible_asset_metadata_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: fungible_asset_metadata_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input fungible_asset_metadata_stream_cursor_value_input {
  asset_type: String
  creator_address: String
  decimals: Int
  icon_uri: String
  inserted_at: timestamp
  is_token_v2: Boolean
  last_transaction_timestamp: timestamp
  last_transaction_version: bigint
  maximum_v2: numeric
  name: String
  project_uri: String
  supply_aggregator_table_handle_v1: String
  supply_aggregator_table_key_v1: String
  supply_v2: numeric
  symbol: String
  token_standard: String
}

"""aggregate sum on columns"""
type fungible_asset_metadata_sum_fields {
  decimals: Int
  last_transaction_version: bigint
  maximum_v2: numeric
  supply_v2: numeric
}

"""
update columns of table "fungible_asset_metadata"
"""
enum fungible_asset_metadata_update_column {
  """column name"""
  asset_type

  """column name"""
  creator_address

  """column name"""
  decimals

  """column name"""
  icon_uri

  """column name"""
  inserted_at

  """column name"""
  is_token_v2

  """column name"""
  last_transaction_timestamp

  """column name"""
  last_transaction_version

  """column name"""
  maximum_v2

  """column name"""
  name

  """column name"""
  project_uri

  """column name"""
  supply_aggregator_table_handle_v1

  """column name"""
  supply_aggregator_table_key_v1

  """column name"""
  supply_v2

  """column name"""
  symbol

  """column name"""
  token_standard
}

input fungible_asset_metadata_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: fungible_asset_metadata_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: fungible_asset_metadata_set_input

  """filter the rows which have to be updated"""
  where: fungible_asset_metadata_bool_exp!
}

"""aggregate var_pop on columns"""
type fungible_asset_metadata_var_pop_fields {
  decimals: Float
  last_transaction_version: Float
  maximum_v2: Float
  supply_v2: Float
}

"""aggregate var_samp on columns"""
type fungible_asset_metadata_var_samp_fields {
  decimals: Float
  last_transaction_version: Float
  maximum_v2: Float
  supply_v2: Float
}

"""aggregate variance on columns"""
type fungible_asset_metadata_variance_fields {
  decimals: Float
  last_transaction_version: Float
  maximum_v2: Float
  supply_v2: Float
}

"""
columns and relationships of "indexer_status"
"""
type indexer_status {
  db: String!
  inserted_at: timestamp!
  is_indexer_up: Boolean!
}

"""
aggregated selection of "indexer_status"
"""
type indexer_status_aggregate {
  aggregate: indexer_status_aggregate_fields
  nodes: [indexer_status!]!
}

"""
aggregate fields of "indexer_status"
"""
type indexer_status_aggregate_fields {
  count(columns: [indexer_status_select_column!], distinct: Boolean): Int!
  max: indexer_status_max_fields
  min: indexer_status_min_fields
}

"""
Boolean expression to filter rows from the table "indexer_status". All fields are combined with a logical 'AND'.
"""
input indexer_status_bool_exp {
  _and: [indexer_status_bool_exp!]
  _not: indexer_status_bool_exp
  _or: [indexer_status_bool_exp!]
  db: String_comparison_exp
  inserted_at: timestamp_comparison_exp
  is_indexer_up: Boolean_comparison_exp
}

"""
unique or primary key constraints on table "indexer_status"
"""
enum indexer_status_constraint {
  """
  unique or primary key constraint on columns "db"
  """
  indexer_status_pkey
}

"""
input type for inserting data into table "indexer_status"
"""
input indexer_status_insert_input {
  db: String
  inserted_at: timestamp
  is_indexer_up: Boolean
}

"""aggregate max on columns"""
type indexer_status_max_fields {
  db: String
  inserted_at: timestamp
}

"""aggregate min on columns"""
type indexer_status_min_fields {
  db: String
  inserted_at: timestamp
}

"""
response of any mutation on the table "indexer_status"
"""
type indexer_status_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [indexer_status!]!
}

"""
on_conflict condition type for table "indexer_status"
"""
input indexer_status_on_conflict {
  constraint: indexer_status_constraint!
  update_columns: [indexer_status_update_column!]! = []
  where: indexer_status_bool_exp
}

"""Ordering options when selecting data from "indexer_status"."""
input indexer_status_order_by {
  db: order_by
  inserted_at: order_by
  is_indexer_up: order_by
}

"""primary key columns input for table: indexer_status"""
input indexer_status_pk_columns_input {
  db: String!
}

"""
select columns of table "indexer_status"
"""
enum indexer_status_select_column {
  """column name"""
  db

  """column name"""
  inserted_at

  """column name"""
  is_indexer_up
}

"""
input type for updating data in table "indexer_status"
"""
input indexer_status_set_input {
  db: String
  inserted_at: timestamp
  is_indexer_up: Boolean
}

"""
Streaming cursor of the table "indexer_status"
"""
input indexer_status_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: indexer_status_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input indexer_status_stream_cursor_value_input {
  db: String
  inserted_at: timestamp
  is_indexer_up: Boolean
}

"""
update columns of table "indexer_status"
"""
enum indexer_status_update_column {
  """column name"""
  db

  """column name"""
  inserted_at

  """column name"""
  is_indexer_up
}

input indexer_status_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: indexer_status_set_input

  """filter the rows which have to be updated"""
  where: indexer_status_bool_exp!
}

scalar jsonb

input jsonb_cast_exp {
  String: String_comparison_exp
}

"""
Boolean expression to compare columns of type "jsonb". All fields are combined with logical 'AND'.
"""
input jsonb_comparison_exp {
  _cast: jsonb_cast_exp

  """is the column contained in the given json value"""
  _contained_in: jsonb

  """does the column contain the given json value at the top level"""
  _contains: jsonb
  _eq: jsonb
  _gt: jsonb
  _gte: jsonb

  """does the string exist as a top-level key in the column"""
  _has_key: String

  """do all of these strings exist as top-level keys in the column"""
  _has_keys_all: [String!]

  """do any of these strings exist as top-level keys in the column"""
  _has_keys_any: [String!]
  _in: [jsonb!]
  _is_null: Boolean
  _lt: jsonb
  _lte: jsonb
  _neq: jsonb
  _nin: [jsonb!]
}

"""
columns and relationships of "ledger_infos"
"""
type ledger_infos {
  chain_id: bigint!
}

"""
aggregated selection of "ledger_infos"
"""
type ledger_infos_aggregate {
  aggregate: ledger_infos_aggregate_fields
  nodes: [ledger_infos!]!
}

"""
aggregate fields of "ledger_infos"
"""
type ledger_infos_aggregate_fields {
  avg: ledger_infos_avg_fields
  count(columns: [ledger_infos_select_column!], distinct: Boolean): Int!
  max: ledger_infos_max_fields
  min: ledger_infos_min_fields
  stddev: ledger_infos_stddev_fields
  stddev_pop: ledger_infos_stddev_pop_fields
  stddev_samp: ledger_infos_stddev_samp_fields
  sum: ledger_infos_sum_fields
  var_pop: ledger_infos_var_pop_fields
  var_samp: ledger_infos_var_samp_fields
  variance: ledger_infos_variance_fields
}

"""aggregate avg on columns"""
type ledger_infos_avg_fields {
  chain_id: Float
}

"""
Boolean expression to filter rows from the table "ledger_infos". All fields are combined with a logical 'AND'.
"""
input ledger_infos_bool_exp {
  _and: [ledger_infos_bool_exp!]
  _not: ledger_infos_bool_exp
  _or: [ledger_infos_bool_exp!]
  chain_id: bigint_comparison_exp
}

"""
unique or primary key constraints on table "ledger_infos"
"""
enum ledger_infos_constraint {
  """
  unique or primary key constraint on columns "chain_id"
  """
  ledger_infos_pkey
}

"""
input type for incrementing numeric columns in table "ledger_infos"
"""
input ledger_infos_inc_input {
  chain_id: bigint
}

"""
input type for inserting data into table "ledger_infos"
"""
input ledger_infos_insert_input {
  chain_id: bigint
}

"""aggregate max on columns"""
type ledger_infos_max_fields {
  chain_id: bigint
}

"""aggregate min on columns"""
type ledger_infos_min_fields {
  chain_id: bigint
}

"""
response of any mutation on the table "ledger_infos"
"""
type ledger_infos_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [ledger_infos!]!
}

"""
on_conflict condition type for table "ledger_infos"
"""
input ledger_infos_on_conflict {
  constraint: ledger_infos_constraint!
  update_columns: [ledger_infos_update_column!]! = []
  where: ledger_infos_bool_exp
}

"""Ordering options when selecting data from "ledger_infos"."""
input ledger_infos_order_by {
  chain_id: order_by
}

"""primary key columns input for table: ledger_infos"""
input ledger_infos_pk_columns_input {
  chain_id: bigint!
}

"""
select columns of table "ledger_infos"
"""
enum ledger_infos_select_column {
  """column name"""
  chain_id
}

"""
input type for updating data in table "ledger_infos"
"""
input ledger_infos_set_input {
  chain_id: bigint
}

"""aggregate stddev on columns"""
type ledger_infos_stddev_fields {
  chain_id: Float
}

"""aggregate stddev_pop on columns"""
type ledger_infos_stddev_pop_fields {
  chain_id: Float
}

"""aggregate stddev_samp on columns"""
type ledger_infos_stddev_samp_fields {
  chain_id: Float
}

"""
Streaming cursor of the table "ledger_infos"
"""
input ledger_infos_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: ledger_infos_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input ledger_infos_stream_cursor_value_input {
  chain_id: bigint
}

"""aggregate sum on columns"""
type ledger_infos_sum_fields {
  chain_id: bigint
}

"""
update columns of table "ledger_infos"
"""
enum ledger_infos_update_column {
  """column name"""
  chain_id
}

input ledger_infos_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: ledger_infos_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: ledger_infos_set_input

  """filter the rows which have to be updated"""
  where: ledger_infos_bool_exp!
}

"""aggregate var_pop on columns"""
type ledger_infos_var_pop_fields {
  chain_id: Float
}

"""aggregate var_samp on columns"""
type ledger_infos_var_samp_fields {
  chain_id: Float
}

"""aggregate variance on columns"""
type ledger_infos_variance_fields {
  chain_id: Float
}

"""
columns and relationships of "legacy_migration_v1.move_resources"
"""
type move_resources {
  address: String
  transaction_version: bigint
}

"""
aggregated selection of "legacy_migration_v1.move_resources"
"""
type move_resources_aggregate {
  aggregate: move_resources_aggregate_fields
  nodes: [move_resources!]!
}

"""
aggregate fields of "legacy_migration_v1.move_resources"
"""
type move_resources_aggregate_fields {
  avg: move_resources_avg_fields
  count(columns: [move_resources_select_column!], distinct: Boolean): Int!
  max: move_resources_max_fields
  min: move_resources_min_fields
  stddev: move_resources_stddev_fields
  stddev_pop: move_resources_stddev_pop_fields
  stddev_samp: move_resources_stddev_samp_fields
  sum: move_resources_sum_fields
  var_pop: move_resources_var_pop_fields
  var_samp: move_resources_var_samp_fields
  variance: move_resources_variance_fields
}

"""aggregate avg on columns"""
type move_resources_avg_fields {
  transaction_version: Float
}

"""
Boolean expression to filter rows from the table "legacy_migration_v1.move_resources". All fields are combined with a logical 'AND'.
"""
input move_resources_bool_exp {
  _and: [move_resources_bool_exp!]
  _not: move_resources_bool_exp
  _or: [move_resources_bool_exp!]
  address: String_comparison_exp
  transaction_version: bigint_comparison_exp
}

"""
input type for incrementing numeric columns in table "legacy_migration_v1.move_resources"
"""
input move_resources_inc_input {
  transaction_version: bigint
}

"""
input type for inserting data into table "legacy_migration_v1.move_resources"
"""
input move_resources_insert_input {
  address: String
  transaction_version: bigint
}

"""aggregate max on columns"""
type move_resources_max_fields {
  address: String
  transaction_version: bigint
}

"""aggregate min on columns"""
type move_resources_min_fields {
  address: String
  transaction_version: bigint
}

"""
response of any mutation on the table "legacy_migration_v1.move_resources"
"""
type move_resources_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [move_resources!]!
}

"""
Ordering options when selecting data from "legacy_migration_v1.move_resources".
"""
input move_resources_order_by {
  address: order_by
  transaction_version: order_by
}

"""
select columns of table "legacy_migration_v1.move_resources"
"""
enum move_resources_select_column {
  """column name"""
  address

  """column name"""
  transaction_version
}

"""
input type for updating data in table "legacy_migration_v1.move_resources"
"""
input move_resources_set_input {
  address: String
  transaction_version: bigint
}

"""aggregate stddev on columns"""
type move_resources_stddev_fields {
  transaction_version: Float
}

"""aggregate stddev_pop on columns"""
type move_resources_stddev_pop_fields {
  transaction_version: Float
}

"""aggregate stddev_samp on columns"""
type move_resources_stddev_samp_fields {
  transaction_version: Float
}

"""
Streaming cursor of the table "move_resources"
"""
input move_resources_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: move_resources_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input move_resources_stream_cursor_value_input {
  address: String
  transaction_version: bigint
}

"""aggregate sum on columns"""
type move_resources_sum_fields {
  transaction_version: bigint
}

input move_resources_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: move_resources_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: move_resources_set_input

  """filter the rows which have to be updated"""
  where: move_resources_bool_exp!
}

"""aggregate var_pop on columns"""
type move_resources_var_pop_fields {
  transaction_version: Float
}

"""aggregate var_samp on columns"""
type move_resources_var_samp_fields {
  transaction_version: Float
}

"""aggregate variance on columns"""
type move_resources_variance_fields {
  transaction_version: Float
}

"""mutation root"""
type mutation_root {
  """
  delete data from the table: "account_transactions"
  """
  delete_account_transactions(
    """filter the rows which have to be deleted"""
    where: account_transactions_bool_exp!
  ): account_transactions_mutation_response

  """
  delete single row from the table: "account_transactions"
  """
  delete_account_transactions_by_pk(account_address: String!, transaction_version: bigint!): account_transactions

  """
  delete data from the table: "legacy_migration_v1.address_version_from_move_resources"
  """
  delete_address_version_from_move_resources(
    """filter the rows which have to be deleted"""
    where: address_version_from_move_resources_bool_exp!
  ): address_version_from_move_resources_mutation_response

  """
  delete data from the table: "block_metadata_transactions"
  """
  delete_block_metadata_transactions(
    """filter the rows which have to be deleted"""
    where: block_metadata_transactions_bool_exp!
  ): block_metadata_transactions_mutation_response

  """
  delete single row from the table: "block_metadata_transactions"
  """
  delete_block_metadata_transactions_by_pk(version: bigint!): block_metadata_transactions

  """
  delete data from the table: "legacy_migration_v1.coin_activities"
  """
  delete_coin_activities(
    """filter the rows which have to be deleted"""
    where: coin_activities_bool_exp!
  ): coin_activities_mutation_response

  """
  delete data from the table: "legacy_migration_v1.coin_balances"
  """
  delete_coin_balances(
    """filter the rows which have to be deleted"""
    where: coin_balances_bool_exp!
  ): coin_balances_mutation_response

  """
  delete data from the table: "legacy_migration_v1.coin_infos"
  """
  delete_coin_infos(
    """filter the rows which have to be deleted"""
    where: coin_infos_bool_exp!
  ): coin_infos_mutation_response

  """
  delete data from the table: "coin_supply"
  """
  delete_coin_supply(
    """filter the rows which have to be deleted"""
    where: coin_supply_bool_exp!
  ): coin_supply_mutation_response

  """
  delete single row from the table: "coin_supply"
  """
  delete_coin_supply_by_pk(coin_type_hash: String!, transaction_version: bigint!): coin_supply

  """
  delete data from the table: "legacy_migration_v1.collection_datas"
  """
  delete_collection_datas(
    """filter the rows which have to be deleted"""
    where: collection_datas_bool_exp!
  ): collection_datas_mutation_response

  """
  delete data from the table: "legacy_migration_v1.current_ans_lookup"
  """
  delete_current_ans_lookup(
    """filter the rows which have to be deleted"""
    where: current_ans_lookup_bool_exp!
  ): current_ans_lookup_mutation_response

  """
  delete data from the table: "current_ans_lookup_v2"
  """
  delete_current_ans_lookup_v2(
    """filter the rows which have to be deleted"""
    where: current_ans_lookup_v2_bool_exp!
  ): current_ans_lookup_v2_mutation_response

  """
  delete single row from the table: "current_ans_lookup_v2"
  """
  delete_current_ans_lookup_v2_by_pk(domain: String!, subdomain: String!, token_standard: String!): current_ans_lookup_v2

  """
  delete data from the table: "legacy_migration_v1.current_coin_balances"
  """
  delete_current_coin_balances(
    """filter the rows which have to be deleted"""
    where: current_coin_balances_bool_exp!
  ): current_coin_balances_mutation_response

  """
  delete data from the table: "legacy_migration_v1.current_collection_datas"
  """
  delete_current_collection_datas(
    """filter the rows which have to be deleted"""
    where: current_collection_datas_bool_exp!
  ): current_collection_datas_mutation_response

  """
  delete data from the table: "current_collections_v2"
  """
  delete_current_collections_v2(
    """filter the rows which have to be deleted"""
    where: current_collections_v2_bool_exp!
  ): current_collections_v2_mutation_response

  """
  delete single row from the table: "current_collections_v2"
  """
  delete_current_collections_v2_by_pk(collection_id: String!): current_collections_v2

  """
  delete data from the table: "current_delegated_staking_pool_balances"
  """
  delete_current_delegated_staking_pool_balances(
    """filter the rows which have to be deleted"""
    where: current_delegated_staking_pool_balances_bool_exp!
  ): current_delegated_staking_pool_balances_mutation_response

  """
  delete single row from the table: "current_delegated_staking_pool_balances"
  """
  delete_current_delegated_staking_pool_balances_by_pk(staking_pool_address: String!): current_delegated_staking_pool_balances

  """
  delete data from the table: "current_delegated_voter"
  """
  delete_current_delegated_voter(
    """filter the rows which have to be deleted"""
    where: current_delegated_voter_bool_exp!
  ): current_delegated_voter_mutation_response

  """
  delete single row from the table: "current_delegated_voter"
  """
  delete_current_delegated_voter_by_pk(delegation_pool_address: String!, delegator_address: String!): current_delegated_voter

  """
  delete data from the table: "current_delegator_balances"
  """
  delete_current_delegator_balances(
    """filter the rows which have to be deleted"""
    where: current_delegator_balances_bool_exp!
  ): current_delegator_balances_mutation_response

  """
  delete single row from the table: "current_delegator_balances"
  """
  delete_current_delegator_balances_by_pk(delegator_address: String!, pool_address: String!, pool_type: String!, table_handle: String!): current_delegator_balances

  """
  delete data from the table: "current_fungible_asset_balances"
  """
  delete_current_fungible_asset_balances(
    """filter the rows which have to be deleted"""
    where: current_fungible_asset_balances_bool_exp!
  ): current_fungible_asset_balances_mutation_response

  """
  delete single row from the table: "current_fungible_asset_balances"
  """
  delete_current_fungible_asset_balances_by_pk(storage_id: String!): current_fungible_asset_balances

  """
  delete data from the table: "current_objects"
  """
  delete_current_objects(
    """filter the rows which have to be deleted"""
    where: current_objects_bool_exp!
  ): current_objects_mutation_response

  """
  delete single row from the table: "current_objects"
  """
  delete_current_objects_by_pk(object_address: String!): current_objects

  """
  delete data from the table: "current_staking_pool_voter"
  """
  delete_current_staking_pool_voter(
    """filter the rows which have to be deleted"""
    where: current_staking_pool_voter_bool_exp!
  ): current_staking_pool_voter_mutation_response

  """
  delete single row from the table: "current_staking_pool_voter"
  """
  delete_current_staking_pool_voter_by_pk(staking_pool_address: String!): current_staking_pool_voter

  """
  delete data from the table: "current_table_items"
  """
  delete_current_table_items(
    """filter the rows which have to be deleted"""
    where: current_table_items_bool_exp!
  ): current_table_items_mutation_response

  """
  delete single row from the table: "current_table_items"
  """
  delete_current_table_items_by_pk(key_hash: String!, table_handle: String!): current_table_items

  """
  delete data from the table: "current_token_datas_v2"
  """
  delete_current_token_datas_v2(
    """filter the rows which have to be deleted"""
    where: current_token_datas_v2_bool_exp!
  ): current_token_datas_v2_mutation_response

  """
  delete single row from the table: "current_token_datas_v2"
  """
  delete_current_token_datas_v2_by_pk(token_data_id: String!): current_token_datas_v2

  """
  delete data from the table: "current_token_ownerships_v2"
  """
  delete_current_token_ownerships_v2(
    """filter the rows which have to be deleted"""
    where: current_token_ownerships_v2_bool_exp!
  ): current_token_ownerships_v2_mutation_response

  """
  delete single row from the table: "current_token_ownerships_v2"
  """
  delete_current_token_ownerships_v2_by_pk(owner_address: String!, property_version_v1: numeric!, storage_id: String!, token_data_id: String!): current_token_ownerships_v2

  """
  delete data from the table: "current_token_pending_claims"
  """
  delete_current_token_pending_claims(
    """filter the rows which have to be deleted"""
    where: current_token_pending_claims_bool_exp!
  ): current_token_pending_claims_mutation_response

  """
  delete single row from the table: "current_token_pending_claims"
  """
  delete_current_token_pending_claims_by_pk(from_address: String!, property_version: numeric!, to_address: String!, token_data_id_hash: String!): current_token_pending_claims

  """
  delete data from the table: "current_token_royalty_v1"
  """
  delete_current_token_royalty_v1(
    """filter the rows which have to be deleted"""
    where: current_token_royalty_v1_bool_exp!
  ): current_token_royalty_v1_mutation_response

  """
  delete single row from the table: "current_token_royalty_v1"
  """
  delete_current_token_royalty_v1_by_pk(token_data_id: String!): current_token_royalty_v1

  """
  delete data from the table: "delegated_staking_activities"
  """
  delete_delegated_staking_activities(
    """filter the rows which have to be deleted"""
    where: delegated_staking_activities_bool_exp!
  ): delegated_staking_activities_mutation_response

  """
  delete single row from the table: "delegated_staking_activities"
  """
  delete_delegated_staking_activities_by_pk(event_index: bigint!, transaction_version: bigint!): delegated_staking_activities

  """
  delete data from the table: "delegated_staking_pool_balances"
  """
  delete_delegated_staking_pool_balances(
    """filter the rows which have to be deleted"""
    where: delegated_staking_pool_balances_bool_exp!
  ): delegated_staking_pool_balances_mutation_response

  """
  delete single row from the table: "delegated_staking_pool_balances"
  """
  delete_delegated_staking_pool_balances_by_pk(staking_pool_address: String!, transaction_version: bigint!): delegated_staking_pool_balances

  """
  delete data from the table: "delegated_staking_pools"
  """
  delete_delegated_staking_pools(
    """filter the rows which have to be deleted"""
    where: delegated_staking_pools_bool_exp!
  ): delegated_staking_pools_mutation_response

  """
  delete single row from the table: "delegated_staking_pools"
  """
  delete_delegated_staking_pools_by_pk(staking_pool_address: String!): delegated_staking_pools

  """
  delete data from the table: "events"
  """
  delete_events(
    """filter the rows which have to be deleted"""
    where: events_bool_exp!
  ): events_mutation_response

  """
  delete single row from the table: "events"
  """
  delete_events_by_pk(event_index: bigint!, transaction_version: bigint!): events

  """
  delete data from the table: "fungible_asset_activities"
  """
  delete_fungible_asset_activities(
    """filter the rows which have to be deleted"""
    where: fungible_asset_activities_bool_exp!
  ): fungible_asset_activities_mutation_response

  """
  delete single row from the table: "fungible_asset_activities"
  """
  delete_fungible_asset_activities_by_pk(event_index: bigint!, transaction_version: bigint!): fungible_asset_activities

  """
  delete data from the table: "fungible_asset_metadata"
  """
  delete_fungible_asset_metadata(
    """filter the rows which have to be deleted"""
    where: fungible_asset_metadata_bool_exp!
  ): fungible_asset_metadata_mutation_response

  """
  delete single row from the table: "fungible_asset_metadata"
  """
  delete_fungible_asset_metadata_by_pk(asset_type: String!): fungible_asset_metadata

  """
  delete data from the table: "indexer_status"
  """
  delete_indexer_status(
    """filter the rows which have to be deleted"""
    where: indexer_status_bool_exp!
  ): indexer_status_mutation_response

  """
  delete single row from the table: "indexer_status"
  """
  delete_indexer_status_by_pk(db: String!): indexer_status

  """
  delete data from the table: "ledger_infos"
  """
  delete_ledger_infos(
    """filter the rows which have to be deleted"""
    where: ledger_infos_bool_exp!
  ): ledger_infos_mutation_response

  """
  delete single row from the table: "ledger_infos"
  """
  delete_ledger_infos_by_pk(chain_id: bigint!): ledger_infos

  """
  delete data from the table: "legacy_migration_v1.move_resources"
  """
  delete_move_resources(
    """filter the rows which have to be deleted"""
    where: move_resources_bool_exp!
  ): move_resources_mutation_response

  """
  delete data from the table: "nft_metadata_crawler.parsed_asset_uris"
  """
  delete_nft_metadata_crawler_parsed_asset_uris(
    """filter the rows which have to be deleted"""
    where: nft_metadata_crawler_parsed_asset_uris_bool_exp!
  ): nft_metadata_crawler_parsed_asset_uris_mutation_response

  """
  delete single row from the table: "nft_metadata_crawler.parsed_asset_uris"
  """
  delete_nft_metadata_crawler_parsed_asset_uris_by_pk(asset_uri: String!): nft_metadata_crawler_parsed_asset_uris

  """
  delete data from the table: "processor_status"
  """
  delete_processor_status(
    """filter the rows which have to be deleted"""
    where: processor_status_bool_exp!
  ): processor_status_mutation_response

  """
  delete single row from the table: "processor_status"
  """
  delete_processor_status_by_pk(processor: String!): processor_status

  """
  delete data from the table: "proposal_votes"
  """
  delete_proposal_votes(
    """filter the rows which have to be deleted"""
    where: proposal_votes_bool_exp!
  ): proposal_votes_mutation_response

  """
  delete single row from the table: "proposal_votes"
  """
  delete_proposal_votes_by_pk(proposal_id: bigint!, transaction_version: bigint!, voter_address: String!): proposal_votes

  """
  delete data from the table: "signatures"
  """
  delete_signatures(
    """filter the rows which have to be deleted"""
    where: signatures_bool_exp!
  ): signatures_mutation_response

  """
  delete single row from the table: "signatures"
  """
  delete_signatures_by_pk(is_sender_primary: Boolean!, multi_agent_index: bigint!, multi_sig_index: bigint!, transaction_version: bigint!): signatures

  """
  delete data from the table: "table_items"
  """
  delete_table_items(
    """filter the rows which have to be deleted"""
    where: table_items_bool_exp!
  ): table_items_mutation_response

  """
  delete single row from the table: "table_items"
  """
  delete_table_items_by_pk(transaction_version: bigint!, write_set_change_index: bigint!): table_items

  """
  delete data from the table: "table_metadatas"
  """
  delete_table_metadatas(
    """filter the rows which have to be deleted"""
    where: table_metadatas_bool_exp!
  ): table_metadatas_mutation_response

  """
  delete single row from the table: "table_metadatas"
  """
  delete_table_metadatas_by_pk(handle: String!): table_metadatas

  """
  delete data from the table: "token_activities_v2"
  """
  delete_token_activities_v2(
    """filter the rows which have to be deleted"""
    where: token_activities_v2_bool_exp!
  ): token_activities_v2_mutation_response

  """
  delete single row from the table: "token_activities_v2"
  """
  delete_token_activities_v2_by_pk(event_index: bigint!, transaction_version: bigint!): token_activities_v2

  """
  delete data from the table: "user_transactions"
  """
  delete_user_transactions(
    """filter the rows which have to be deleted"""
    where: user_transactions_bool_exp!
  ): user_transactions_mutation_response

  """
  delete single row from the table: "user_transactions"
  """
  delete_user_transactions_by_pk(version: bigint!): user_transactions

  """
  insert data into the table: "account_transactions"
  """
  insert_account_transactions(
    """the rows to be inserted"""
    objects: [account_transactions_insert_input!]!

    """upsert condition"""
    on_conflict: account_transactions_on_conflict
  ): account_transactions_mutation_response

  """
  insert a single row into the table: "account_transactions"
  """
  insert_account_transactions_one(
    """the row to be inserted"""
    object: account_transactions_insert_input!

    """upsert condition"""
    on_conflict: account_transactions_on_conflict
  ): account_transactions

  """
  insert data into the table: "legacy_migration_v1.address_version_from_move_resources"
  """
  insert_address_version_from_move_resources(
    """the rows to be inserted"""
    objects: [address_version_from_move_resources_insert_input!]!
  ): address_version_from_move_resources_mutation_response

  """
  insert a single row into the table: "legacy_migration_v1.address_version_from_move_resources"
  """
  insert_address_version_from_move_resources_one(
    """the row to be inserted"""
    object: address_version_from_move_resources_insert_input!
  ): address_version_from_move_resources

  """
  insert data into the table: "block_metadata_transactions"
  """
  insert_block_metadata_transactions(
    """the rows to be inserted"""
    objects: [block_metadata_transactions_insert_input!]!

    """upsert condition"""
    on_conflict: block_metadata_transactions_on_conflict
  ): block_metadata_transactions_mutation_response

  """
  insert a single row into the table: "block_metadata_transactions"
  """
  insert_block_metadata_transactions_one(
    """the row to be inserted"""
    object: block_metadata_transactions_insert_input!

    """upsert condition"""
    on_conflict: block_metadata_transactions_on_conflict
  ): block_metadata_transactions

  """
  insert data into the table: "legacy_migration_v1.coin_activities"
  """
  insert_coin_activities(
    """the rows to be inserted"""
    objects: [coin_activities_insert_input!]!
  ): coin_activities_mutation_response

  """
  insert a single row into the table: "legacy_migration_v1.coin_activities"
  """
  insert_coin_activities_one(
    """the row to be inserted"""
    object: coin_activities_insert_input!
  ): coin_activities

  """
  insert data into the table: "legacy_migration_v1.coin_balances"
  """
  insert_coin_balances(
    """the rows to be inserted"""
    objects: [coin_balances_insert_input!]!
  ): coin_balances_mutation_response

  """
  insert a single row into the table: "legacy_migration_v1.coin_balances"
  """
  insert_coin_balances_one(
    """the row to be inserted"""
    object: coin_balances_insert_input!
  ): coin_balances

  """
  insert data into the table: "legacy_migration_v1.coin_infos"
  """
  insert_coin_infos(
    """the rows to be inserted"""
    objects: [coin_infos_insert_input!]!
  ): coin_infos_mutation_response

  """
  insert a single row into the table: "legacy_migration_v1.coin_infos"
  """
  insert_coin_infos_one(
    """the row to be inserted"""
    object: coin_infos_insert_input!
  ): coin_infos

  """
  insert data into the table: "coin_supply"
  """
  insert_coin_supply(
    """the rows to be inserted"""
    objects: [coin_supply_insert_input!]!

    """upsert condition"""
    on_conflict: coin_supply_on_conflict
  ): coin_supply_mutation_response

  """
  insert a single row into the table: "coin_supply"
  """
  insert_coin_supply_one(
    """the row to be inserted"""
    object: coin_supply_insert_input!

    """upsert condition"""
    on_conflict: coin_supply_on_conflict
  ): coin_supply

  """
  insert data into the table: "legacy_migration_v1.collection_datas"
  """
  insert_collection_datas(
    """the rows to be inserted"""
    objects: [collection_datas_insert_input!]!
  ): collection_datas_mutation_response

  """
  insert a single row into the table: "legacy_migration_v1.collection_datas"
  """
  insert_collection_datas_one(
    """the row to be inserted"""
    object: collection_datas_insert_input!
  ): collection_datas

  """
  insert data into the table: "legacy_migration_v1.current_ans_lookup"
  """
  insert_current_ans_lookup(
    """the rows to be inserted"""
    objects: [current_ans_lookup_insert_input!]!
  ): current_ans_lookup_mutation_response

  """
  insert a single row into the table: "legacy_migration_v1.current_ans_lookup"
  """
  insert_current_ans_lookup_one(
    """the row to be inserted"""
    object: current_ans_lookup_insert_input!
  ): current_ans_lookup

  """
  insert data into the table: "current_ans_lookup_v2"
  """
  insert_current_ans_lookup_v2(
    """the rows to be inserted"""
    objects: [current_ans_lookup_v2_insert_input!]!

    """upsert condition"""
    on_conflict: current_ans_lookup_v2_on_conflict
  ): current_ans_lookup_v2_mutation_response

  """
  insert a single row into the table: "current_ans_lookup_v2"
  """
  insert_current_ans_lookup_v2_one(
    """the row to be inserted"""
    object: current_ans_lookup_v2_insert_input!

    """upsert condition"""
    on_conflict: current_ans_lookup_v2_on_conflict
  ): current_ans_lookup_v2

  """
  insert data into the table: "legacy_migration_v1.current_coin_balances"
  """
  insert_current_coin_balances(
    """the rows to be inserted"""
    objects: [current_coin_balances_insert_input!]!
  ): current_coin_balances_mutation_response

  """
  insert a single row into the table: "legacy_migration_v1.current_coin_balances"
  """
  insert_current_coin_balances_one(
    """the row to be inserted"""
    object: current_coin_balances_insert_input!
  ): current_coin_balances

  """
  insert data into the table: "legacy_migration_v1.current_collection_datas"
  """
  insert_current_collection_datas(
    """the rows to be inserted"""
    objects: [current_collection_datas_insert_input!]!
  ): current_collection_datas_mutation_response

  """
  insert a single row into the table: "legacy_migration_v1.current_collection_datas"
  """
  insert_current_collection_datas_one(
    """the row to be inserted"""
    object: current_collection_datas_insert_input!
  ): current_collection_datas

  """
  insert data into the table: "current_collections_v2"
  """
  insert_current_collections_v2(
    """the rows to be inserted"""
    objects: [current_collections_v2_insert_input!]!

    """upsert condition"""
    on_conflict: current_collections_v2_on_conflict
  ): current_collections_v2_mutation_response

  """
  insert a single row into the table: "current_collections_v2"
  """
  insert_current_collections_v2_one(
    """the row to be inserted"""
    object: current_collections_v2_insert_input!

    """upsert condition"""
    on_conflict: current_collections_v2_on_conflict
  ): current_collections_v2

  """
  insert data into the table: "current_delegated_staking_pool_balances"
  """
  insert_current_delegated_staking_pool_balances(
    """the rows to be inserted"""
    objects: [current_delegated_staking_pool_balances_insert_input!]!

    """upsert condition"""
    on_conflict: current_delegated_staking_pool_balances_on_conflict
  ): current_delegated_staking_pool_balances_mutation_response

  """
  insert a single row into the table: "current_delegated_staking_pool_balances"
  """
  insert_current_delegated_staking_pool_balances_one(
    """the row to be inserted"""
    object: current_delegated_staking_pool_balances_insert_input!

    """upsert condition"""
    on_conflict: current_delegated_staking_pool_balances_on_conflict
  ): current_delegated_staking_pool_balances

  """
  insert data into the table: "current_delegated_voter"
  """
  insert_current_delegated_voter(
    """the rows to be inserted"""
    objects: [current_delegated_voter_insert_input!]!

    """upsert condition"""
    on_conflict: current_delegated_voter_on_conflict
  ): current_delegated_voter_mutation_response

  """
  insert a single row into the table: "current_delegated_voter"
  """
  insert_current_delegated_voter_one(
    """the row to be inserted"""
    object: current_delegated_voter_insert_input!

    """upsert condition"""
    on_conflict: current_delegated_voter_on_conflict
  ): current_delegated_voter

  """
  insert data into the table: "current_delegator_balances"
  """
  insert_current_delegator_balances(
    """the rows to be inserted"""
    objects: [current_delegator_balances_insert_input!]!

    """upsert condition"""
    on_conflict: current_delegator_balances_on_conflict
  ): current_delegator_balances_mutation_response

  """
  insert a single row into the table: "current_delegator_balances"
  """
  insert_current_delegator_balances_one(
    """the row to be inserted"""
    object: current_delegator_balances_insert_input!

    """upsert condition"""
    on_conflict: current_delegator_balances_on_conflict
  ): current_delegator_balances

  """
  insert data into the table: "current_fungible_asset_balances"
  """
  insert_current_fungible_asset_balances(
    """the rows to be inserted"""
    objects: [current_fungible_asset_balances_insert_input!]!

    """upsert condition"""
    on_conflict: current_fungible_asset_balances_on_conflict
  ): current_fungible_asset_balances_mutation_response

  """
  insert a single row into the table: "current_fungible_asset_balances"
  """
  insert_current_fungible_asset_balances_one(
    """the row to be inserted"""
    object: current_fungible_asset_balances_insert_input!

    """upsert condition"""
    on_conflict: current_fungible_asset_balances_on_conflict
  ): current_fungible_asset_balances

  """
  insert data into the table: "current_objects"
  """
  insert_current_objects(
    """the rows to be inserted"""
    objects: [current_objects_insert_input!]!

    """upsert condition"""
    on_conflict: current_objects_on_conflict
  ): current_objects_mutation_response

  """
  insert a single row into the table: "current_objects"
  """
  insert_current_objects_one(
    """the row to be inserted"""
    object: current_objects_insert_input!

    """upsert condition"""
    on_conflict: current_objects_on_conflict
  ): current_objects

  """
  insert data into the table: "current_staking_pool_voter"
  """
  insert_current_staking_pool_voter(
    """the rows to be inserted"""
    objects: [current_staking_pool_voter_insert_input!]!

    """upsert condition"""
    on_conflict: current_staking_pool_voter_on_conflict
  ): current_staking_pool_voter_mutation_response

  """
  insert a single row into the table: "current_staking_pool_voter"
  """
  insert_current_staking_pool_voter_one(
    """the row to be inserted"""
    object: current_staking_pool_voter_insert_input!

    """upsert condition"""
    on_conflict: current_staking_pool_voter_on_conflict
  ): current_staking_pool_voter

  """
  insert data into the table: "current_table_items"
  """
  insert_current_table_items(
    """the rows to be inserted"""
    objects: [current_table_items_insert_input!]!

    """upsert condition"""
    on_conflict: current_table_items_on_conflict
  ): current_table_items_mutation_response

  """
  insert a single row into the table: "current_table_items"
  """
  insert_current_table_items_one(
    """the row to be inserted"""
    object: current_table_items_insert_input!

    """upsert condition"""
    on_conflict: current_table_items_on_conflict
  ): current_table_items

  """
  insert data into the table: "current_token_datas_v2"
  """
  insert_current_token_datas_v2(
    """the rows to be inserted"""
    objects: [current_token_datas_v2_insert_input!]!

    """upsert condition"""
    on_conflict: current_token_datas_v2_on_conflict
  ): current_token_datas_v2_mutation_response

  """
  insert a single row into the table: "current_token_datas_v2"
  """
  insert_current_token_datas_v2_one(
    """the row to be inserted"""
    object: current_token_datas_v2_insert_input!

    """upsert condition"""
    on_conflict: current_token_datas_v2_on_conflict
  ): current_token_datas_v2

  """
  insert data into the table: "current_token_ownerships_v2"
  """
  insert_current_token_ownerships_v2(
    """the rows to be inserted"""
    objects: [current_token_ownerships_v2_insert_input!]!

    """upsert condition"""
    on_conflict: current_token_ownerships_v2_on_conflict
  ): current_token_ownerships_v2_mutation_response

  """
  insert a single row into the table: "current_token_ownerships_v2"
  """
  insert_current_token_ownerships_v2_one(
    """the row to be inserted"""
    object: current_token_ownerships_v2_insert_input!

    """upsert condition"""
    on_conflict: current_token_ownerships_v2_on_conflict
  ): current_token_ownerships_v2

  """
  insert data into the table: "current_token_pending_claims"
  """
  insert_current_token_pending_claims(
    """the rows to be inserted"""
    objects: [current_token_pending_claims_insert_input!]!

    """upsert condition"""
    on_conflict: current_token_pending_claims_on_conflict
  ): current_token_pending_claims_mutation_response

  """
  insert a single row into the table: "current_token_pending_claims"
  """
  insert_current_token_pending_claims_one(
    """the row to be inserted"""
    object: current_token_pending_claims_insert_input!

    """upsert condition"""
    on_conflict: current_token_pending_claims_on_conflict
  ): current_token_pending_claims

  """
  insert data into the table: "current_token_royalty_v1"
  """
  insert_current_token_royalty_v1(
    """the rows to be inserted"""
    objects: [current_token_royalty_v1_insert_input!]!

    """upsert condition"""
    on_conflict: current_token_royalty_v1_on_conflict
  ): current_token_royalty_v1_mutation_response

  """
  insert a single row into the table: "current_token_royalty_v1"
  """
  insert_current_token_royalty_v1_one(
    """the row to be inserted"""
    object: current_token_royalty_v1_insert_input!

    """upsert condition"""
    on_conflict: current_token_royalty_v1_on_conflict
  ): current_token_royalty_v1

  """
  insert data into the table: "delegated_staking_activities"
  """
  insert_delegated_staking_activities(
    """the rows to be inserted"""
    objects: [delegated_staking_activities_insert_input!]!

    """upsert condition"""
    on_conflict: delegated_staking_activities_on_conflict
  ): delegated_staking_activities_mutation_response

  """
  insert a single row into the table: "delegated_staking_activities"
  """
  insert_delegated_staking_activities_one(
    """the row to be inserted"""
    object: delegated_staking_activities_insert_input!

    """upsert condition"""
    on_conflict: delegated_staking_activities_on_conflict
  ): delegated_staking_activities

  """
  insert data into the table: "delegated_staking_pool_balances"
  """
  insert_delegated_staking_pool_balances(
    """the rows to be inserted"""
    objects: [delegated_staking_pool_balances_insert_input!]!

    """upsert condition"""
    on_conflict: delegated_staking_pool_balances_on_conflict
  ): delegated_staking_pool_balances_mutation_response

  """
  insert a single row into the table: "delegated_staking_pool_balances"
  """
  insert_delegated_staking_pool_balances_one(
    """the row to be inserted"""
    object: delegated_staking_pool_balances_insert_input!

    """upsert condition"""
    on_conflict: delegated_staking_pool_balances_on_conflict
  ): delegated_staking_pool_balances

  """
  insert data into the table: "delegated_staking_pools"
  """
  insert_delegated_staking_pools(
    """the rows to be inserted"""
    objects: [delegated_staking_pools_insert_input!]!

    """upsert condition"""
    on_conflict: delegated_staking_pools_on_conflict
  ): delegated_staking_pools_mutation_response

  """
  insert a single row into the table: "delegated_staking_pools"
  """
  insert_delegated_staking_pools_one(
    """the row to be inserted"""
    object: delegated_staking_pools_insert_input!

    """upsert condition"""
    on_conflict: delegated_staking_pools_on_conflict
  ): delegated_staking_pools

  """
  insert data into the table: "events"
  """
  insert_events(
    """the rows to be inserted"""
    objects: [events_insert_input!]!

    """upsert condition"""
    on_conflict: events_on_conflict
  ): events_mutation_response

  """
  insert a single row into the table: "events"
  """
  insert_events_one(
    """the row to be inserted"""
    object: events_insert_input!

    """upsert condition"""
    on_conflict: events_on_conflict
  ): events

  """
  insert data into the table: "fungible_asset_activities"
  """
  insert_fungible_asset_activities(
    """the rows to be inserted"""
    objects: [fungible_asset_activities_insert_input!]!

    """upsert condition"""
    on_conflict: fungible_asset_activities_on_conflict
  ): fungible_asset_activities_mutation_response

  """
  insert a single row into the table: "fungible_asset_activities"
  """
  insert_fungible_asset_activities_one(
    """the row to be inserted"""
    object: fungible_asset_activities_insert_input!

    """upsert condition"""
    on_conflict: fungible_asset_activities_on_conflict
  ): fungible_asset_activities

  """
  insert data into the table: "fungible_asset_metadata"
  """
  insert_fungible_asset_metadata(
    """the rows to be inserted"""
    objects: [fungible_asset_metadata_insert_input!]!

    """upsert condition"""
    on_conflict: fungible_asset_metadata_on_conflict
  ): fungible_asset_metadata_mutation_response

  """
  insert a single row into the table: "fungible_asset_metadata"
  """
  insert_fungible_asset_metadata_one(
    """the row to be inserted"""
    object: fungible_asset_metadata_insert_input!

    """upsert condition"""
    on_conflict: fungible_asset_metadata_on_conflict
  ): fungible_asset_metadata

  """
  insert data into the table: "indexer_status"
  """
  insert_indexer_status(
    """the rows to be inserted"""
    objects: [indexer_status_insert_input!]!

    """upsert condition"""
    on_conflict: indexer_status_on_conflict
  ): indexer_status_mutation_response

  """
  insert a single row into the table: "indexer_status"
  """
  insert_indexer_status_one(
    """the row to be inserted"""
    object: indexer_status_insert_input!

    """upsert condition"""
    on_conflict: indexer_status_on_conflict
  ): indexer_status

  """
  insert data into the table: "ledger_infos"
  """
  insert_ledger_infos(
    """the rows to be inserted"""
    objects: [ledger_infos_insert_input!]!

    """upsert condition"""
    on_conflict: ledger_infos_on_conflict
  ): ledger_infos_mutation_response

  """
  insert a single row into the table: "ledger_infos"
  """
  insert_ledger_infos_one(
    """the row to be inserted"""
    object: ledger_infos_insert_input!

    """upsert condition"""
    on_conflict: ledger_infos_on_conflict
  ): ledger_infos

  """
  insert data into the table: "legacy_migration_v1.move_resources"
  """
  insert_move_resources(
    """the rows to be inserted"""
    objects: [move_resources_insert_input!]!
  ): move_resources_mutation_response

  """
  insert a single row into the table: "legacy_migration_v1.move_resources"
  """
  insert_move_resources_one(
    """the row to be inserted"""
    object: move_resources_insert_input!
  ): move_resources

  """
  insert data into the table: "nft_metadata_crawler.parsed_asset_uris"
  """
  insert_nft_metadata_crawler_parsed_asset_uris(
    """the rows to be inserted"""
    objects: [nft_metadata_crawler_parsed_asset_uris_insert_input!]!

    """upsert condition"""
    on_conflict: nft_metadata_crawler_parsed_asset_uris_on_conflict
  ): nft_metadata_crawler_parsed_asset_uris_mutation_response

  """
  insert a single row into the table: "nft_metadata_crawler.parsed_asset_uris"
  """
  insert_nft_metadata_crawler_parsed_asset_uris_one(
    """the row to be inserted"""
    object: nft_metadata_crawler_parsed_asset_uris_insert_input!

    """upsert condition"""
    on_conflict: nft_metadata_crawler_parsed_asset_uris_on_conflict
  ): nft_metadata_crawler_parsed_asset_uris

  """
  insert data into the table: "processor_status"
  """
  insert_processor_status(
    """the rows to be inserted"""
    objects: [processor_status_insert_input!]!

    """upsert condition"""
    on_conflict: processor_status_on_conflict
  ): processor_status_mutation_response

  """
  insert a single row into the table: "processor_status"
  """
  insert_processor_status_one(
    """the row to be inserted"""
    object: processor_status_insert_input!

    """upsert condition"""
    on_conflict: processor_status_on_conflict
  ): processor_status

  """
  insert data into the table: "proposal_votes"
  """
  insert_proposal_votes(
    """the rows to be inserted"""
    objects: [proposal_votes_insert_input!]!

    """upsert condition"""
    on_conflict: proposal_votes_on_conflict
  ): proposal_votes_mutation_response

  """
  insert a single row into the table: "proposal_votes"
  """
  insert_proposal_votes_one(
    """the row to be inserted"""
    object: proposal_votes_insert_input!

    """upsert condition"""
    on_conflict: proposal_votes_on_conflict
  ): proposal_votes

  """
  insert data into the table: "signatures"
  """
  insert_signatures(
    """the rows to be inserted"""
    objects: [signatures_insert_input!]!

    """upsert condition"""
    on_conflict: signatures_on_conflict
  ): signatures_mutation_response

  """
  insert a single row into the table: "signatures"
  """
  insert_signatures_one(
    """the row to be inserted"""
    object: signatures_insert_input!

    """upsert condition"""
    on_conflict: signatures_on_conflict
  ): signatures

  """
  insert data into the table: "table_items"
  """
  insert_table_items(
    """the rows to be inserted"""
    objects: [table_items_insert_input!]!

    """upsert condition"""
    on_conflict: table_items_on_conflict
  ): table_items_mutation_response

  """
  insert a single row into the table: "table_items"
  """
  insert_table_items_one(
    """the row to be inserted"""
    object: table_items_insert_input!

    """upsert condition"""
    on_conflict: table_items_on_conflict
  ): table_items

  """
  insert data into the table: "table_metadatas"
  """
  insert_table_metadatas(
    """the rows to be inserted"""
    objects: [table_metadatas_insert_input!]!

    """upsert condition"""
    on_conflict: table_metadatas_on_conflict
  ): table_metadatas_mutation_response

  """
  insert a single row into the table: "table_metadatas"
  """
  insert_table_metadatas_one(
    """the row to be inserted"""
    object: table_metadatas_insert_input!

    """upsert condition"""
    on_conflict: table_metadatas_on_conflict
  ): table_metadatas

  """
  insert data into the table: "token_activities_v2"
  """
  insert_token_activities_v2(
    """the rows to be inserted"""
    objects: [token_activities_v2_insert_input!]!

    """upsert condition"""
    on_conflict: token_activities_v2_on_conflict
  ): token_activities_v2_mutation_response

  """
  insert a single row into the table: "token_activities_v2"
  """
  insert_token_activities_v2_one(
    """the row to be inserted"""
    object: token_activities_v2_insert_input!

    """upsert condition"""
    on_conflict: token_activities_v2_on_conflict
  ): token_activities_v2

  """
  insert data into the table: "user_transactions"
  """
  insert_user_transactions(
    """the rows to be inserted"""
    objects: [user_transactions_insert_input!]!

    """upsert condition"""
    on_conflict: user_transactions_on_conflict
  ): user_transactions_mutation_response

  """
  insert a single row into the table: "user_transactions"
  """
  insert_user_transactions_one(
    """the row to be inserted"""
    object: user_transactions_insert_input!

    """upsert condition"""
    on_conflict: user_transactions_on_conflict
  ): user_transactions

  """
  update data of the table: "account_transactions"
  """
  update_account_transactions(
    """increments the numeric columns with given value of the filtered values"""
    _inc: account_transactions_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: account_transactions_set_input

    """filter the rows which have to be updated"""
    where: account_transactions_bool_exp!
  ): account_transactions_mutation_response

  """
  update single row of the table: "account_transactions"
  """
  update_account_transactions_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: account_transactions_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: account_transactions_set_input
    pk_columns: account_transactions_pk_columns_input!
  ): account_transactions

  """
  update multiples rows of table: "account_transactions"
  """
  update_account_transactions_many(
    """updates to execute, in order"""
    updates: [account_transactions_updates!]!
  ): [account_transactions_mutation_response]

  """
  update data of the table: "legacy_migration_v1.address_version_from_move_resources"
  """
  update_address_version_from_move_resources(
    """increments the numeric columns with given value of the filtered values"""
    _inc: address_version_from_move_resources_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: address_version_from_move_resources_set_input

    """filter the rows which have to be updated"""
    where: address_version_from_move_resources_bool_exp!
  ): address_version_from_move_resources_mutation_response

  """
  update multiples rows of table: "legacy_migration_v1.address_version_from_move_resources"
  """
  update_address_version_from_move_resources_many(
    """updates to execute, in order"""
    updates: [address_version_from_move_resources_updates!]!
  ): [address_version_from_move_resources_mutation_response]

  """
  update data of the table: "block_metadata_transactions"
  """
  update_block_metadata_transactions(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: block_metadata_transactions_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: block_metadata_transactions_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: block_metadata_transactions_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: block_metadata_transactions_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: block_metadata_transactions_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: block_metadata_transactions_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: block_metadata_transactions_set_input

    """filter the rows which have to be updated"""
    where: block_metadata_transactions_bool_exp!
  ): block_metadata_transactions_mutation_response

  """
  update single row of the table: "block_metadata_transactions"
  """
  update_block_metadata_transactions_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: block_metadata_transactions_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: block_metadata_transactions_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: block_metadata_transactions_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: block_metadata_transactions_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: block_metadata_transactions_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: block_metadata_transactions_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: block_metadata_transactions_set_input
    pk_columns: block_metadata_transactions_pk_columns_input!
  ): block_metadata_transactions

  """
  update multiples rows of table: "block_metadata_transactions"
  """
  update_block_metadata_transactions_many(
    """updates to execute, in order"""
    updates: [block_metadata_transactions_updates!]!
  ): [block_metadata_transactions_mutation_response]

  """
  update data of the table: "legacy_migration_v1.coin_activities"
  """
  update_coin_activities(
    """increments the numeric columns with given value of the filtered values"""
    _inc: coin_activities_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: coin_activities_set_input

    """filter the rows which have to be updated"""
    where: coin_activities_bool_exp!
  ): coin_activities_mutation_response

  """
  update multiples rows of table: "legacy_migration_v1.coin_activities"
  """
  update_coin_activities_many(
    """updates to execute, in order"""
    updates: [coin_activities_updates!]!
  ): [coin_activities_mutation_response]

  """
  update data of the table: "legacy_migration_v1.coin_balances"
  """
  update_coin_balances(
    """increments the numeric columns with given value of the filtered values"""
    _inc: coin_balances_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: coin_balances_set_input

    """filter the rows which have to be updated"""
    where: coin_balances_bool_exp!
  ): coin_balances_mutation_response

  """
  update multiples rows of table: "legacy_migration_v1.coin_balances"
  """
  update_coin_balances_many(
    """updates to execute, in order"""
    updates: [coin_balances_updates!]!
  ): [coin_balances_mutation_response]

  """
  update data of the table: "legacy_migration_v1.coin_infos"
  """
  update_coin_infos(
    """increments the numeric columns with given value of the filtered values"""
    _inc: coin_infos_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: coin_infos_set_input

    """filter the rows which have to be updated"""
    where: coin_infos_bool_exp!
  ): coin_infos_mutation_response

  """
  update multiples rows of table: "legacy_migration_v1.coin_infos"
  """
  update_coin_infos_many(
    """updates to execute, in order"""
    updates: [coin_infos_updates!]!
  ): [coin_infos_mutation_response]

  """
  update data of the table: "coin_supply"
  """
  update_coin_supply(
    """increments the numeric columns with given value of the filtered values"""
    _inc: coin_supply_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: coin_supply_set_input

    """filter the rows which have to be updated"""
    where: coin_supply_bool_exp!
  ): coin_supply_mutation_response

  """
  update single row of the table: "coin_supply"
  """
  update_coin_supply_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: coin_supply_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: coin_supply_set_input
    pk_columns: coin_supply_pk_columns_input!
  ): coin_supply

  """
  update multiples rows of table: "coin_supply"
  """
  update_coin_supply_many(
    """updates to execute, in order"""
    updates: [coin_supply_updates!]!
  ): [coin_supply_mutation_response]

  """
  update data of the table: "legacy_migration_v1.collection_datas"
  """
  update_collection_datas(
    """increments the numeric columns with given value of the filtered values"""
    _inc: collection_datas_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: collection_datas_set_input

    """filter the rows which have to be updated"""
    where: collection_datas_bool_exp!
  ): collection_datas_mutation_response

  """
  update multiples rows of table: "legacy_migration_v1.collection_datas"
  """
  update_collection_datas_many(
    """updates to execute, in order"""
    updates: [collection_datas_updates!]!
  ): [collection_datas_mutation_response]

  """
  update data of the table: "legacy_migration_v1.current_ans_lookup"
  """
  update_current_ans_lookup(
    """increments the numeric columns with given value of the filtered values"""
    _inc: current_ans_lookup_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: current_ans_lookup_set_input

    """filter the rows which have to be updated"""
    where: current_ans_lookup_bool_exp!
  ): current_ans_lookup_mutation_response

  """
  update multiples rows of table: "legacy_migration_v1.current_ans_lookup"
  """
  update_current_ans_lookup_many(
    """updates to execute, in order"""
    updates: [current_ans_lookup_updates!]!
  ): [current_ans_lookup_mutation_response]

  """
  update data of the table: "current_ans_lookup_v2"
  """
  update_current_ans_lookup_v2(
    """increments the numeric columns with given value of the filtered values"""
    _inc: current_ans_lookup_v2_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: current_ans_lookup_v2_set_input

    """filter the rows which have to be updated"""
    where: current_ans_lookup_v2_bool_exp!
  ): current_ans_lookup_v2_mutation_response

  """
  update single row of the table: "current_ans_lookup_v2"
  """
  update_current_ans_lookup_v2_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: current_ans_lookup_v2_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: current_ans_lookup_v2_set_input
    pk_columns: current_ans_lookup_v2_pk_columns_input!
  ): current_ans_lookup_v2

  """
  update multiples rows of table: "current_ans_lookup_v2"
  """
  update_current_ans_lookup_v2_many(
    """updates to execute, in order"""
    updates: [current_ans_lookup_v2_updates!]!
  ): [current_ans_lookup_v2_mutation_response]

  """
  update data of the table: "legacy_migration_v1.current_coin_balances"
  """
  update_current_coin_balances(
    """increments the numeric columns with given value of the filtered values"""
    _inc: current_coin_balances_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: current_coin_balances_set_input

    """filter the rows which have to be updated"""
    where: current_coin_balances_bool_exp!
  ): current_coin_balances_mutation_response

  """
  update multiples rows of table: "legacy_migration_v1.current_coin_balances"
  """
  update_current_coin_balances_many(
    """updates to execute, in order"""
    updates: [current_coin_balances_updates!]!
  ): [current_coin_balances_mutation_response]

  """
  update data of the table: "legacy_migration_v1.current_collection_datas"
  """
  update_current_collection_datas(
    """increments the numeric columns with given value of the filtered values"""
    _inc: current_collection_datas_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: current_collection_datas_set_input

    """filter the rows which have to be updated"""
    where: current_collection_datas_bool_exp!
  ): current_collection_datas_mutation_response

  """
  update multiples rows of table: "legacy_migration_v1.current_collection_datas"
  """
  update_current_collection_datas_many(
    """updates to execute, in order"""
    updates: [current_collection_datas_updates!]!
  ): [current_collection_datas_mutation_response]

  """
  update data of the table: "current_collections_v2"
  """
  update_current_collections_v2(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: current_collections_v2_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: current_collections_v2_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: current_collections_v2_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: current_collections_v2_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: current_collections_v2_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: current_collections_v2_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: current_collections_v2_set_input

    """filter the rows which have to be updated"""
    where: current_collections_v2_bool_exp!
  ): current_collections_v2_mutation_response

  """
  update single row of the table: "current_collections_v2"
  """
  update_current_collections_v2_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: current_collections_v2_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: current_collections_v2_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: current_collections_v2_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: current_collections_v2_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: current_collections_v2_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: current_collections_v2_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: current_collections_v2_set_input
    pk_columns: current_collections_v2_pk_columns_input!
  ): current_collections_v2

  """
  update multiples rows of table: "current_collections_v2"
  """
  update_current_collections_v2_many(
    """updates to execute, in order"""
    updates: [current_collections_v2_updates!]!
  ): [current_collections_v2_mutation_response]

  """
  update data of the table: "current_delegated_staking_pool_balances"
  """
  update_current_delegated_staking_pool_balances(
    """increments the numeric columns with given value of the filtered values"""
    _inc: current_delegated_staking_pool_balances_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: current_delegated_staking_pool_balances_set_input

    """filter the rows which have to be updated"""
    where: current_delegated_staking_pool_balances_bool_exp!
  ): current_delegated_staking_pool_balances_mutation_response

  """
  update single row of the table: "current_delegated_staking_pool_balances"
  """
  update_current_delegated_staking_pool_balances_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: current_delegated_staking_pool_balances_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: current_delegated_staking_pool_balances_set_input
    pk_columns: current_delegated_staking_pool_balances_pk_columns_input!
  ): current_delegated_staking_pool_balances

  """
  update multiples rows of table: "current_delegated_staking_pool_balances"
  """
  update_current_delegated_staking_pool_balances_many(
    """updates to execute, in order"""
    updates: [current_delegated_staking_pool_balances_updates!]!
  ): [current_delegated_staking_pool_balances_mutation_response]

  """
  update data of the table: "current_delegated_voter"
  """
  update_current_delegated_voter(
    """increments the numeric columns with given value of the filtered values"""
    _inc: current_delegated_voter_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: current_delegated_voter_set_input

    """filter the rows which have to be updated"""
    where: current_delegated_voter_bool_exp!
  ): current_delegated_voter_mutation_response

  """
  update single row of the table: "current_delegated_voter"
  """
  update_current_delegated_voter_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: current_delegated_voter_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: current_delegated_voter_set_input
    pk_columns: current_delegated_voter_pk_columns_input!
  ): current_delegated_voter

  """
  update multiples rows of table: "current_delegated_voter"
  """
  update_current_delegated_voter_many(
    """updates to execute, in order"""
    updates: [current_delegated_voter_updates!]!
  ): [current_delegated_voter_mutation_response]

  """
  update data of the table: "current_delegator_balances"
  """
  update_current_delegator_balances(
    """increments the numeric columns with given value of the filtered values"""
    _inc: current_delegator_balances_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: current_delegator_balances_set_input

    """filter the rows which have to be updated"""
    where: current_delegator_balances_bool_exp!
  ): current_delegator_balances_mutation_response

  """
  update single row of the table: "current_delegator_balances"
  """
  update_current_delegator_balances_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: current_delegator_balances_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: current_delegator_balances_set_input
    pk_columns: current_delegator_balances_pk_columns_input!
  ): current_delegator_balances

  """
  update multiples rows of table: "current_delegator_balances"
  """
  update_current_delegator_balances_many(
    """updates to execute, in order"""
    updates: [current_delegator_balances_updates!]!
  ): [current_delegator_balances_mutation_response]

  """
  update data of the table: "current_fungible_asset_balances"
  """
  update_current_fungible_asset_balances(
    """increments the numeric columns with given value of the filtered values"""
    _inc: current_fungible_asset_balances_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: current_fungible_asset_balances_set_input

    """filter the rows which have to be updated"""
    where: current_fungible_asset_balances_bool_exp!
  ): current_fungible_asset_balances_mutation_response

  """
  update single row of the table: "current_fungible_asset_balances"
  """
  update_current_fungible_asset_balances_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: current_fungible_asset_balances_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: current_fungible_asset_balances_set_input
    pk_columns: current_fungible_asset_balances_pk_columns_input!
  ): current_fungible_asset_balances

  """
  update multiples rows of table: "current_fungible_asset_balances"
  """
  update_current_fungible_asset_balances_many(
    """updates to execute, in order"""
    updates: [current_fungible_asset_balances_updates!]!
  ): [current_fungible_asset_balances_mutation_response]

  """
  update data of the table: "current_objects"
  """
  update_current_objects(
    """increments the numeric columns with given value of the filtered values"""
    _inc: current_objects_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: current_objects_set_input

    """filter the rows which have to be updated"""
    where: current_objects_bool_exp!
  ): current_objects_mutation_response

  """
  update single row of the table: "current_objects"
  """
  update_current_objects_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: current_objects_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: current_objects_set_input
    pk_columns: current_objects_pk_columns_input!
  ): current_objects

  """
  update multiples rows of table: "current_objects"
  """
  update_current_objects_many(
    """updates to execute, in order"""
    updates: [current_objects_updates!]!
  ): [current_objects_mutation_response]

  """
  update data of the table: "current_staking_pool_voter"
  """
  update_current_staking_pool_voter(
    """increments the numeric columns with given value of the filtered values"""
    _inc: current_staking_pool_voter_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: current_staking_pool_voter_set_input

    """filter the rows which have to be updated"""
    where: current_staking_pool_voter_bool_exp!
  ): current_staking_pool_voter_mutation_response

  """
  update single row of the table: "current_staking_pool_voter"
  """
  update_current_staking_pool_voter_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: current_staking_pool_voter_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: current_staking_pool_voter_set_input
    pk_columns: current_staking_pool_voter_pk_columns_input!
  ): current_staking_pool_voter

  """
  update multiples rows of table: "current_staking_pool_voter"
  """
  update_current_staking_pool_voter_many(
    """updates to execute, in order"""
    updates: [current_staking_pool_voter_updates!]!
  ): [current_staking_pool_voter_mutation_response]

  """
  update data of the table: "current_table_items"
  """
  update_current_table_items(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: current_table_items_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: current_table_items_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: current_table_items_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: current_table_items_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: current_table_items_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: current_table_items_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: current_table_items_set_input

    """filter the rows which have to be updated"""
    where: current_table_items_bool_exp!
  ): current_table_items_mutation_response

  """
  update single row of the table: "current_table_items"
  """
  update_current_table_items_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: current_table_items_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: current_table_items_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: current_table_items_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: current_table_items_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: current_table_items_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: current_table_items_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: current_table_items_set_input
    pk_columns: current_table_items_pk_columns_input!
  ): current_table_items

  """
  update multiples rows of table: "current_table_items"
  """
  update_current_table_items_many(
    """updates to execute, in order"""
    updates: [current_table_items_updates!]!
  ): [current_table_items_mutation_response]

  """
  update data of the table: "current_token_datas_v2"
  """
  update_current_token_datas_v2(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: current_token_datas_v2_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: current_token_datas_v2_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: current_token_datas_v2_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: current_token_datas_v2_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: current_token_datas_v2_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: current_token_datas_v2_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: current_token_datas_v2_set_input

    """filter the rows which have to be updated"""
    where: current_token_datas_v2_bool_exp!
  ): current_token_datas_v2_mutation_response

  """
  update single row of the table: "current_token_datas_v2"
  """
  update_current_token_datas_v2_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: current_token_datas_v2_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: current_token_datas_v2_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: current_token_datas_v2_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: current_token_datas_v2_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: current_token_datas_v2_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: current_token_datas_v2_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: current_token_datas_v2_set_input
    pk_columns: current_token_datas_v2_pk_columns_input!
  ): current_token_datas_v2

  """
  update multiples rows of table: "current_token_datas_v2"
  """
  update_current_token_datas_v2_many(
    """updates to execute, in order"""
    updates: [current_token_datas_v2_updates!]!
  ): [current_token_datas_v2_mutation_response]

  """
  update data of the table: "current_token_ownerships_v2"
  """
  update_current_token_ownerships_v2(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: current_token_ownerships_v2_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: current_token_ownerships_v2_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: current_token_ownerships_v2_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: current_token_ownerships_v2_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: current_token_ownerships_v2_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: current_token_ownerships_v2_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: current_token_ownerships_v2_set_input

    """filter the rows which have to be updated"""
    where: current_token_ownerships_v2_bool_exp!
  ): current_token_ownerships_v2_mutation_response

  """
  update single row of the table: "current_token_ownerships_v2"
  """
  update_current_token_ownerships_v2_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: current_token_ownerships_v2_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: current_token_ownerships_v2_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: current_token_ownerships_v2_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: current_token_ownerships_v2_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: current_token_ownerships_v2_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: current_token_ownerships_v2_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: current_token_ownerships_v2_set_input
    pk_columns: current_token_ownerships_v2_pk_columns_input!
  ): current_token_ownerships_v2

  """
  update multiples rows of table: "current_token_ownerships_v2"
  """
  update_current_token_ownerships_v2_many(
    """updates to execute, in order"""
    updates: [current_token_ownerships_v2_updates!]!
  ): [current_token_ownerships_v2_mutation_response]

  """
  update data of the table: "current_token_pending_claims"
  """
  update_current_token_pending_claims(
    """increments the numeric columns with given value of the filtered values"""
    _inc: current_token_pending_claims_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: current_token_pending_claims_set_input

    """filter the rows which have to be updated"""
    where: current_token_pending_claims_bool_exp!
  ): current_token_pending_claims_mutation_response

  """
  update single row of the table: "current_token_pending_claims"
  """
  update_current_token_pending_claims_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: current_token_pending_claims_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: current_token_pending_claims_set_input
    pk_columns: current_token_pending_claims_pk_columns_input!
  ): current_token_pending_claims

  """
  update multiples rows of table: "current_token_pending_claims"
  """
  update_current_token_pending_claims_many(
    """updates to execute, in order"""
    updates: [current_token_pending_claims_updates!]!
  ): [current_token_pending_claims_mutation_response]

  """
  update data of the table: "current_token_royalty_v1"
  """
  update_current_token_royalty_v1(
    """increments the numeric columns with given value of the filtered values"""
    _inc: current_token_royalty_v1_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: current_token_royalty_v1_set_input

    """filter the rows which have to be updated"""
    where: current_token_royalty_v1_bool_exp!
  ): current_token_royalty_v1_mutation_response

  """
  update single row of the table: "current_token_royalty_v1"
  """
  update_current_token_royalty_v1_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: current_token_royalty_v1_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: current_token_royalty_v1_set_input
    pk_columns: current_token_royalty_v1_pk_columns_input!
  ): current_token_royalty_v1

  """
  update multiples rows of table: "current_token_royalty_v1"
  """
  update_current_token_royalty_v1_many(
    """updates to execute, in order"""
    updates: [current_token_royalty_v1_updates!]!
  ): [current_token_royalty_v1_mutation_response]

  """
  update data of the table: "delegated_staking_activities"
  """
  update_delegated_staking_activities(
    """increments the numeric columns with given value of the filtered values"""
    _inc: delegated_staking_activities_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: delegated_staking_activities_set_input

    """filter the rows which have to be updated"""
    where: delegated_staking_activities_bool_exp!
  ): delegated_staking_activities_mutation_response

  """
  update single row of the table: "delegated_staking_activities"
  """
  update_delegated_staking_activities_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: delegated_staking_activities_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: delegated_staking_activities_set_input
    pk_columns: delegated_staking_activities_pk_columns_input!
  ): delegated_staking_activities

  """
  update multiples rows of table: "delegated_staking_activities"
  """
  update_delegated_staking_activities_many(
    """updates to execute, in order"""
    updates: [delegated_staking_activities_updates!]!
  ): [delegated_staking_activities_mutation_response]

  """
  update data of the table: "delegated_staking_pool_balances"
  """
  update_delegated_staking_pool_balances(
    """increments the numeric columns with given value of the filtered values"""
    _inc: delegated_staking_pool_balances_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: delegated_staking_pool_balances_set_input

    """filter the rows which have to be updated"""
    where: delegated_staking_pool_balances_bool_exp!
  ): delegated_staking_pool_balances_mutation_response

  """
  update single row of the table: "delegated_staking_pool_balances"
  """
  update_delegated_staking_pool_balances_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: delegated_staking_pool_balances_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: delegated_staking_pool_balances_set_input
    pk_columns: delegated_staking_pool_balances_pk_columns_input!
  ): delegated_staking_pool_balances

  """
  update multiples rows of table: "delegated_staking_pool_balances"
  """
  update_delegated_staking_pool_balances_many(
    """updates to execute, in order"""
    updates: [delegated_staking_pool_balances_updates!]!
  ): [delegated_staking_pool_balances_mutation_response]

  """
  update data of the table: "delegated_staking_pools"
  """
  update_delegated_staking_pools(
    """increments the numeric columns with given value of the filtered values"""
    _inc: delegated_staking_pools_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: delegated_staking_pools_set_input

    """filter the rows which have to be updated"""
    where: delegated_staking_pools_bool_exp!
  ): delegated_staking_pools_mutation_response

  """
  update single row of the table: "delegated_staking_pools"
  """
  update_delegated_staking_pools_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: delegated_staking_pools_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: delegated_staking_pools_set_input
    pk_columns: delegated_staking_pools_pk_columns_input!
  ): delegated_staking_pools

  """
  update multiples rows of table: "delegated_staking_pools"
  """
  update_delegated_staking_pools_many(
    """updates to execute, in order"""
    updates: [delegated_staking_pools_updates!]!
  ): [delegated_staking_pools_mutation_response]

  """
  update data of the table: "events"
  """
  update_events(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: events_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: events_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: events_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: events_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: events_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: events_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: events_set_input

    """filter the rows which have to be updated"""
    where: events_bool_exp!
  ): events_mutation_response

  """
  update single row of the table: "events"
  """
  update_events_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: events_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: events_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: events_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: events_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: events_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: events_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: events_set_input
    pk_columns: events_pk_columns_input!
  ): events

  """
  update multiples rows of table: "events"
  """
  update_events_many(
    """updates to execute, in order"""
    updates: [events_updates!]!
  ): [events_mutation_response]

  """
  update data of the table: "fungible_asset_activities"
  """
  update_fungible_asset_activities(
    """increments the numeric columns with given value of the filtered values"""
    _inc: fungible_asset_activities_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: fungible_asset_activities_set_input

    """filter the rows which have to be updated"""
    where: fungible_asset_activities_bool_exp!
  ): fungible_asset_activities_mutation_response

  """
  update single row of the table: "fungible_asset_activities"
  """
  update_fungible_asset_activities_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: fungible_asset_activities_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: fungible_asset_activities_set_input
    pk_columns: fungible_asset_activities_pk_columns_input!
  ): fungible_asset_activities

  """
  update multiples rows of table: "fungible_asset_activities"
  """
  update_fungible_asset_activities_many(
    """updates to execute, in order"""
    updates: [fungible_asset_activities_updates!]!
  ): [fungible_asset_activities_mutation_response]

  """
  update data of the table: "fungible_asset_metadata"
  """
  update_fungible_asset_metadata(
    """increments the numeric columns with given value of the filtered values"""
    _inc: fungible_asset_metadata_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: fungible_asset_metadata_set_input

    """filter the rows which have to be updated"""
    where: fungible_asset_metadata_bool_exp!
  ): fungible_asset_metadata_mutation_response

  """
  update single row of the table: "fungible_asset_metadata"
  """
  update_fungible_asset_metadata_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: fungible_asset_metadata_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: fungible_asset_metadata_set_input
    pk_columns: fungible_asset_metadata_pk_columns_input!
  ): fungible_asset_metadata

  """
  update multiples rows of table: "fungible_asset_metadata"
  """
  update_fungible_asset_metadata_many(
    """updates to execute, in order"""
    updates: [fungible_asset_metadata_updates!]!
  ): [fungible_asset_metadata_mutation_response]

  """
  update data of the table: "indexer_status"
  """
  update_indexer_status(
    """sets the columns of the filtered rows to the given values"""
    _set: indexer_status_set_input

    """filter the rows which have to be updated"""
    where: indexer_status_bool_exp!
  ): indexer_status_mutation_response

  """
  update single row of the table: "indexer_status"
  """
  update_indexer_status_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: indexer_status_set_input
    pk_columns: indexer_status_pk_columns_input!
  ): indexer_status

  """
  update multiples rows of table: "indexer_status"
  """
  update_indexer_status_many(
    """updates to execute, in order"""
    updates: [indexer_status_updates!]!
  ): [indexer_status_mutation_response]

  """
  update data of the table: "ledger_infos"
  """
  update_ledger_infos(
    """increments the numeric columns with given value of the filtered values"""
    _inc: ledger_infos_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: ledger_infos_set_input

    """filter the rows which have to be updated"""
    where: ledger_infos_bool_exp!
  ): ledger_infos_mutation_response

  """
  update single row of the table: "ledger_infos"
  """
  update_ledger_infos_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: ledger_infos_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: ledger_infos_set_input
    pk_columns: ledger_infos_pk_columns_input!
  ): ledger_infos

  """
  update multiples rows of table: "ledger_infos"
  """
  update_ledger_infos_many(
    """updates to execute, in order"""
    updates: [ledger_infos_updates!]!
  ): [ledger_infos_mutation_response]

  """
  update data of the table: "legacy_migration_v1.move_resources"
  """
  update_move_resources(
    """increments the numeric columns with given value of the filtered values"""
    _inc: move_resources_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: move_resources_set_input

    """filter the rows which have to be updated"""
    where: move_resources_bool_exp!
  ): move_resources_mutation_response

  """
  update multiples rows of table: "legacy_migration_v1.move_resources"
  """
  update_move_resources_many(
    """updates to execute, in order"""
    updates: [move_resources_updates!]!
  ): [move_resources_mutation_response]

  """
  update data of the table: "nft_metadata_crawler.parsed_asset_uris"
  """
  update_nft_metadata_crawler_parsed_asset_uris(
    """increments the numeric columns with given value of the filtered values"""
    _inc: nft_metadata_crawler_parsed_asset_uris_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: nft_metadata_crawler_parsed_asset_uris_set_input

    """filter the rows which have to be updated"""
    where: nft_metadata_crawler_parsed_asset_uris_bool_exp!
  ): nft_metadata_crawler_parsed_asset_uris_mutation_response

  """
  update single row of the table: "nft_metadata_crawler.parsed_asset_uris"
  """
  update_nft_metadata_crawler_parsed_asset_uris_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: nft_metadata_crawler_parsed_asset_uris_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: nft_metadata_crawler_parsed_asset_uris_set_input
    pk_columns: nft_metadata_crawler_parsed_asset_uris_pk_columns_input!
  ): nft_metadata_crawler_parsed_asset_uris

  """
  update multiples rows of table: "nft_metadata_crawler.parsed_asset_uris"
  """
  update_nft_metadata_crawler_parsed_asset_uris_many(
    """updates to execute, in order"""
    updates: [nft_metadata_crawler_parsed_asset_uris_updates!]!
  ): [nft_metadata_crawler_parsed_asset_uris_mutation_response]

  """
  update data of the table: "processor_status"
  """
  update_processor_status(
    """increments the numeric columns with given value of the filtered values"""
    _inc: processor_status_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: processor_status_set_input

    """filter the rows which have to be updated"""
    where: processor_status_bool_exp!
  ): processor_status_mutation_response

  """
  update single row of the table: "processor_status"
  """
  update_processor_status_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: processor_status_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: processor_status_set_input
    pk_columns: processor_status_pk_columns_input!
  ): processor_status

  """
  update multiples rows of table: "processor_status"
  """
  update_processor_status_many(
    """updates to execute, in order"""
    updates: [processor_status_updates!]!
  ): [processor_status_mutation_response]

  """
  update data of the table: "proposal_votes"
  """
  update_proposal_votes(
    """increments the numeric columns with given value of the filtered values"""
    _inc: proposal_votes_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: proposal_votes_set_input

    """filter the rows which have to be updated"""
    where: proposal_votes_bool_exp!
  ): proposal_votes_mutation_response

  """
  update single row of the table: "proposal_votes"
  """
  update_proposal_votes_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: proposal_votes_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: proposal_votes_set_input
    pk_columns: proposal_votes_pk_columns_input!
  ): proposal_votes

  """
  update multiples rows of table: "proposal_votes"
  """
  update_proposal_votes_many(
    """updates to execute, in order"""
    updates: [proposal_votes_updates!]!
  ): [proposal_votes_mutation_response]

  """
  update data of the table: "signatures"
  """
  update_signatures(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: signatures_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: signatures_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: signatures_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: signatures_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: signatures_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: signatures_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: signatures_set_input

    """filter the rows which have to be updated"""
    where: signatures_bool_exp!
  ): signatures_mutation_response

  """
  update single row of the table: "signatures"
  """
  update_signatures_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: signatures_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: signatures_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: signatures_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: signatures_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: signatures_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: signatures_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: signatures_set_input
    pk_columns: signatures_pk_columns_input!
  ): signatures

  """
  update multiples rows of table: "signatures"
  """
  update_signatures_many(
    """updates to execute, in order"""
    updates: [signatures_updates!]!
  ): [signatures_mutation_response]

  """
  update data of the table: "table_items"
  """
  update_table_items(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: table_items_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: table_items_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: table_items_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: table_items_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: table_items_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: table_items_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: table_items_set_input

    """filter the rows which have to be updated"""
    where: table_items_bool_exp!
  ): table_items_mutation_response

  """
  update single row of the table: "table_items"
  """
  update_table_items_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: table_items_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: table_items_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: table_items_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: table_items_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: table_items_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: table_items_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: table_items_set_input
    pk_columns: table_items_pk_columns_input!
  ): table_items

  """
  update multiples rows of table: "table_items"
  """
  update_table_items_many(
    """updates to execute, in order"""
    updates: [table_items_updates!]!
  ): [table_items_mutation_response]

  """
  update data of the table: "table_metadatas"
  """
  update_table_metadatas(
    """sets the columns of the filtered rows to the given values"""
    _set: table_metadatas_set_input

    """filter the rows which have to be updated"""
    where: table_metadatas_bool_exp!
  ): table_metadatas_mutation_response

  """
  update single row of the table: "table_metadatas"
  """
  update_table_metadatas_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: table_metadatas_set_input
    pk_columns: table_metadatas_pk_columns_input!
  ): table_metadatas

  """
  update multiples rows of table: "table_metadatas"
  """
  update_table_metadatas_many(
    """updates to execute, in order"""
    updates: [table_metadatas_updates!]!
  ): [table_metadatas_mutation_response]

  """
  update data of the table: "token_activities_v2"
  """
  update_token_activities_v2(
    """increments the numeric columns with given value of the filtered values"""
    _inc: token_activities_v2_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: token_activities_v2_set_input

    """filter the rows which have to be updated"""
    where: token_activities_v2_bool_exp!
  ): token_activities_v2_mutation_response

  """
  update single row of the table: "token_activities_v2"
  """
  update_token_activities_v2_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: token_activities_v2_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: token_activities_v2_set_input
    pk_columns: token_activities_v2_pk_columns_input!
  ): token_activities_v2

  """
  update multiples rows of table: "token_activities_v2"
  """
  update_token_activities_v2_many(
    """updates to execute, in order"""
    updates: [token_activities_v2_updates!]!
  ): [token_activities_v2_mutation_response]

  """
  update data of the table: "user_transactions"
  """
  update_user_transactions(
    """increments the numeric columns with given value of the filtered values"""
    _inc: user_transactions_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: user_transactions_set_input

    """filter the rows which have to be updated"""
    where: user_transactions_bool_exp!
  ): user_transactions_mutation_response

  """
  update single row of the table: "user_transactions"
  """
  update_user_transactions_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: user_transactions_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: user_transactions_set_input
    pk_columns: user_transactions_pk_columns_input!
  ): user_transactions

  """
  update multiples rows of table: "user_transactions"
  """
  update_user_transactions_many(
    """updates to execute, in order"""
    updates: [user_transactions_updates!]!
  ): [user_transactions_mutation_response]
}

"""
columns and relationships of "nft_metadata_crawler.parsed_asset_uris"
"""
type nft_metadata_crawler_parsed_asset_uris {
  animation_optimizer_retry_count: Int!
  asset_uri: String!
  cdn_animation_uri: String
  cdn_image_uri: String
  cdn_json_uri: String
  image_optimizer_retry_count: Int!
  inserted_at: timestamp!
  json_parser_retry_count: Int!
  raw_animation_uri: String
  raw_image_uri: String
}

"""
aggregated selection of "nft_metadata_crawler.parsed_asset_uris"
"""
type nft_metadata_crawler_parsed_asset_uris_aggregate {
  aggregate: nft_metadata_crawler_parsed_asset_uris_aggregate_fields
  nodes: [nft_metadata_crawler_parsed_asset_uris!]!
}

"""
aggregate fields of "nft_metadata_crawler.parsed_asset_uris"
"""
type nft_metadata_crawler_parsed_asset_uris_aggregate_fields {
  avg: nft_metadata_crawler_parsed_asset_uris_avg_fields
  count(columns: [nft_metadata_crawler_parsed_asset_uris_select_column!], distinct: Boolean): Int!
  max: nft_metadata_crawler_parsed_asset_uris_max_fields
  min: nft_metadata_crawler_parsed_asset_uris_min_fields
  stddev: nft_metadata_crawler_parsed_asset_uris_stddev_fields
  stddev_pop: nft_metadata_crawler_parsed_asset_uris_stddev_pop_fields
  stddev_samp: nft_metadata_crawler_parsed_asset_uris_stddev_samp_fields
  sum: nft_metadata_crawler_parsed_asset_uris_sum_fields
  var_pop: nft_metadata_crawler_parsed_asset_uris_var_pop_fields
  var_samp: nft_metadata_crawler_parsed_asset_uris_var_samp_fields
  variance: nft_metadata_crawler_parsed_asset_uris_variance_fields
}

"""aggregate avg on columns"""
type nft_metadata_crawler_parsed_asset_uris_avg_fields {
  animation_optimizer_retry_count: Float
  image_optimizer_retry_count: Float
  json_parser_retry_count: Float
}

"""
Boolean expression to filter rows from the table "nft_metadata_crawler.parsed_asset_uris". All fields are combined with a logical 'AND'.
"""
input nft_metadata_crawler_parsed_asset_uris_bool_exp {
  _and: [nft_metadata_crawler_parsed_asset_uris_bool_exp!]
  _not: nft_metadata_crawler_parsed_asset_uris_bool_exp
  _or: [nft_metadata_crawler_parsed_asset_uris_bool_exp!]
  animation_optimizer_retry_count: Int_comparison_exp
  asset_uri: String_comparison_exp
  cdn_animation_uri: String_comparison_exp
  cdn_image_uri: String_comparison_exp
  cdn_json_uri: String_comparison_exp
  image_optimizer_retry_count: Int_comparison_exp
  inserted_at: timestamp_comparison_exp
  json_parser_retry_count: Int_comparison_exp
  raw_animation_uri: String_comparison_exp
  raw_image_uri: String_comparison_exp
}

"""
unique or primary key constraints on table "nft_metadata_crawler.parsed_asset_uris"
"""
enum nft_metadata_crawler_parsed_asset_uris_constraint {
  """
  unique or primary key constraint on columns "asset_uri"
  """
  parsed_asset_uris_pkey
}

"""
input type for incrementing numeric columns in table "nft_metadata_crawler.parsed_asset_uris"
"""
input nft_metadata_crawler_parsed_asset_uris_inc_input {
  animation_optimizer_retry_count: Int
  image_optimizer_retry_count: Int
  json_parser_retry_count: Int
}

"""
input type for inserting data into table "nft_metadata_crawler.parsed_asset_uris"
"""
input nft_metadata_crawler_parsed_asset_uris_insert_input {
  animation_optimizer_retry_count: Int
  asset_uri: String
  cdn_animation_uri: String
  cdn_image_uri: String
  cdn_json_uri: String
  image_optimizer_retry_count: Int
  inserted_at: timestamp
  json_parser_retry_count: Int
  raw_animation_uri: String
  raw_image_uri: String
}

"""aggregate max on columns"""
type nft_metadata_crawler_parsed_asset_uris_max_fields {
  animation_optimizer_retry_count: Int
  asset_uri: String
  cdn_animation_uri: String
  cdn_image_uri: String
  cdn_json_uri: String
  image_optimizer_retry_count: Int
  inserted_at: timestamp
  json_parser_retry_count: Int
  raw_animation_uri: String
  raw_image_uri: String
}

"""aggregate min on columns"""
type nft_metadata_crawler_parsed_asset_uris_min_fields {
  animation_optimizer_retry_count: Int
  asset_uri: String
  cdn_animation_uri: String
  cdn_image_uri: String
  cdn_json_uri: String
  image_optimizer_retry_count: Int
  inserted_at: timestamp
  json_parser_retry_count: Int
  raw_animation_uri: String
  raw_image_uri: String
}

"""
response of any mutation on the table "nft_metadata_crawler.parsed_asset_uris"
"""
type nft_metadata_crawler_parsed_asset_uris_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [nft_metadata_crawler_parsed_asset_uris!]!
}

"""
input type for inserting object relation for remote table "nft_metadata_crawler.parsed_asset_uris"
"""
input nft_metadata_crawler_parsed_asset_uris_obj_rel_insert_input {
  data: nft_metadata_crawler_parsed_asset_uris_insert_input!

  """upsert condition"""
  on_conflict: nft_metadata_crawler_parsed_asset_uris_on_conflict
}

"""
on_conflict condition type for table "nft_metadata_crawler.parsed_asset_uris"
"""
input nft_metadata_crawler_parsed_asset_uris_on_conflict {
  constraint: nft_metadata_crawler_parsed_asset_uris_constraint!
  update_columns: [nft_metadata_crawler_parsed_asset_uris_update_column!]! = []
  where: nft_metadata_crawler_parsed_asset_uris_bool_exp
}

"""
Ordering options when selecting data from "nft_metadata_crawler.parsed_asset_uris".
"""
input nft_metadata_crawler_parsed_asset_uris_order_by {
  animation_optimizer_retry_count: order_by
  asset_uri: order_by
  cdn_animation_uri: order_by
  cdn_image_uri: order_by
  cdn_json_uri: order_by
  image_optimizer_retry_count: order_by
  inserted_at: order_by
  json_parser_retry_count: order_by
  raw_animation_uri: order_by
  raw_image_uri: order_by
}

"""
primary key columns input for table: nft_metadata_crawler.parsed_asset_uris
"""
input nft_metadata_crawler_parsed_asset_uris_pk_columns_input {
  asset_uri: String!
}

"""
select columns of table "nft_metadata_crawler.parsed_asset_uris"
"""
enum nft_metadata_crawler_parsed_asset_uris_select_column {
  """column name"""
  animation_optimizer_retry_count

  """column name"""
  asset_uri

  """column name"""
  cdn_animation_uri

  """column name"""
  cdn_image_uri

  """column name"""
  cdn_json_uri

  """column name"""
  image_optimizer_retry_count

  """column name"""
  inserted_at

  """column name"""
  json_parser_retry_count

  """column name"""
  raw_animation_uri

  """column name"""
  raw_image_uri
}

"""
input type for updating data in table "nft_metadata_crawler.parsed_asset_uris"
"""
input nft_metadata_crawler_parsed_asset_uris_set_input {
  animation_optimizer_retry_count: Int
  asset_uri: String
  cdn_animation_uri: String
  cdn_image_uri: String
  cdn_json_uri: String
  image_optimizer_retry_count: Int
  inserted_at: timestamp
  json_parser_retry_count: Int
  raw_animation_uri: String
  raw_image_uri: String
}

"""aggregate stddev on columns"""
type nft_metadata_crawler_parsed_asset_uris_stddev_fields {
  animation_optimizer_retry_count: Float
  image_optimizer_retry_count: Float
  json_parser_retry_count: Float
}

"""aggregate stddev_pop on columns"""
type nft_metadata_crawler_parsed_asset_uris_stddev_pop_fields {
  animation_optimizer_retry_count: Float
  image_optimizer_retry_count: Float
  json_parser_retry_count: Float
}

"""aggregate stddev_samp on columns"""
type nft_metadata_crawler_parsed_asset_uris_stddev_samp_fields {
  animation_optimizer_retry_count: Float
  image_optimizer_retry_count: Float
  json_parser_retry_count: Float
}

"""
Streaming cursor of the table "nft_metadata_crawler_parsed_asset_uris"
"""
input nft_metadata_crawler_parsed_asset_uris_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: nft_metadata_crawler_parsed_asset_uris_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input nft_metadata_crawler_parsed_asset_uris_stream_cursor_value_input {
  animation_optimizer_retry_count: Int
  asset_uri: String
  cdn_animation_uri: String
  cdn_image_uri: String
  cdn_json_uri: String
  image_optimizer_retry_count: Int
  inserted_at: timestamp
  json_parser_retry_count: Int
  raw_animation_uri: String
  raw_image_uri: String
}

"""aggregate sum on columns"""
type nft_metadata_crawler_parsed_asset_uris_sum_fields {
  animation_optimizer_retry_count: Int
  image_optimizer_retry_count: Int
  json_parser_retry_count: Int
}

"""
update columns of table "nft_metadata_crawler.parsed_asset_uris"
"""
enum nft_metadata_crawler_parsed_asset_uris_update_column {
  """column name"""
  animation_optimizer_retry_count

  """column name"""
  asset_uri

  """column name"""
  cdn_animation_uri

  """column name"""
  cdn_image_uri

  """column name"""
  cdn_json_uri

  """column name"""
  image_optimizer_retry_count

  """column name"""
  inserted_at

  """column name"""
  json_parser_retry_count

  """column name"""
  raw_animation_uri

  """column name"""
  raw_image_uri
}

input nft_metadata_crawler_parsed_asset_uris_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: nft_metadata_crawler_parsed_asset_uris_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: nft_metadata_crawler_parsed_asset_uris_set_input

  """filter the rows which have to be updated"""
  where: nft_metadata_crawler_parsed_asset_uris_bool_exp!
}

"""aggregate var_pop on columns"""
type nft_metadata_crawler_parsed_asset_uris_var_pop_fields {
  animation_optimizer_retry_count: Float
  image_optimizer_retry_count: Float
  json_parser_retry_count: Float
}

"""aggregate var_samp on columns"""
type nft_metadata_crawler_parsed_asset_uris_var_samp_fields {
  animation_optimizer_retry_count: Float
  image_optimizer_retry_count: Float
  json_parser_retry_count: Float
}

"""aggregate variance on columns"""
type nft_metadata_crawler_parsed_asset_uris_variance_fields {
  animation_optimizer_retry_count: Float
  image_optimizer_retry_count: Float
  json_parser_retry_count: Float
}

"""
columns and relationships of "num_active_delegator_per_pool"
"""
type num_active_delegator_per_pool {
  num_active_delegator: bigint
  pool_address: String
}

"""
aggregated selection of "num_active_delegator_per_pool"
"""
type num_active_delegator_per_pool_aggregate {
  aggregate: num_active_delegator_per_pool_aggregate_fields
  nodes: [num_active_delegator_per_pool!]!
}

"""
aggregate fields of "num_active_delegator_per_pool"
"""
type num_active_delegator_per_pool_aggregate_fields {
  avg: num_active_delegator_per_pool_avg_fields
  count(columns: [num_active_delegator_per_pool_select_column!], distinct: Boolean): Int!
  max: num_active_delegator_per_pool_max_fields
  min: num_active_delegator_per_pool_min_fields
  stddev: num_active_delegator_per_pool_stddev_fields
  stddev_pop: num_active_delegator_per_pool_stddev_pop_fields
  stddev_samp: num_active_delegator_per_pool_stddev_samp_fields
  sum: num_active_delegator_per_pool_sum_fields
  var_pop: num_active_delegator_per_pool_var_pop_fields
  var_samp: num_active_delegator_per_pool_var_samp_fields
  variance: num_active_delegator_per_pool_variance_fields
}

"""aggregate avg on columns"""
type num_active_delegator_per_pool_avg_fields {
  num_active_delegator: Float
}

"""
Boolean expression to filter rows from the table "num_active_delegator_per_pool". All fields are combined with a logical 'AND'.
"""
input num_active_delegator_per_pool_bool_exp {
  _and: [num_active_delegator_per_pool_bool_exp!]
  _not: num_active_delegator_per_pool_bool_exp
  _or: [num_active_delegator_per_pool_bool_exp!]
  num_active_delegator: bigint_comparison_exp
  pool_address: String_comparison_exp
}

"""aggregate max on columns"""
type num_active_delegator_per_pool_max_fields {
  num_active_delegator: bigint
  pool_address: String
}

"""aggregate min on columns"""
type num_active_delegator_per_pool_min_fields {
  num_active_delegator: bigint
  pool_address: String
}

"""
Ordering options when selecting data from "num_active_delegator_per_pool".
"""
input num_active_delegator_per_pool_order_by {
  num_active_delegator: order_by
  pool_address: order_by
}

"""
select columns of table "num_active_delegator_per_pool"
"""
enum num_active_delegator_per_pool_select_column {
  """column name"""
  num_active_delegator

  """column name"""
  pool_address
}

"""aggregate stddev on columns"""
type num_active_delegator_per_pool_stddev_fields {
  num_active_delegator: Float
}

"""aggregate stddev_pop on columns"""
type num_active_delegator_per_pool_stddev_pop_fields {
  num_active_delegator: Float
}

"""aggregate stddev_samp on columns"""
type num_active_delegator_per_pool_stddev_samp_fields {
  num_active_delegator: Float
}

"""
Streaming cursor of the table "num_active_delegator_per_pool"
"""
input num_active_delegator_per_pool_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: num_active_delegator_per_pool_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input num_active_delegator_per_pool_stream_cursor_value_input {
  num_active_delegator: bigint
  pool_address: String
}

"""aggregate sum on columns"""
type num_active_delegator_per_pool_sum_fields {
  num_active_delegator: bigint
}

"""aggregate var_pop on columns"""
type num_active_delegator_per_pool_var_pop_fields {
  num_active_delegator: Float
}

"""aggregate var_samp on columns"""
type num_active_delegator_per_pool_var_samp_fields {
  num_active_delegator: Float
}

"""aggregate variance on columns"""
type num_active_delegator_per_pool_variance_fields {
  num_active_delegator: Float
}

scalar numeric

"""
Boolean expression to compare columns of type "numeric". All fields are combined with logical 'AND'.
"""
input numeric_comparison_exp {
  _eq: numeric
  _gt: numeric
  _gte: numeric
  _in: [numeric!]
  _is_null: Boolean
  _lt: numeric
  _lte: numeric
  _neq: numeric
  _nin: [numeric!]
}

"""column ordering options"""
enum order_by {
  """in ascending order, nulls last"""
  asc

  """in ascending order, nulls first"""
  asc_nulls_first

  """in ascending order, nulls last"""
  asc_nulls_last

  """in descending order, nulls first"""
  desc

  """in descending order, nulls first"""
  desc_nulls_first

  """in descending order, nulls last"""
  desc_nulls_last
}

"""
columns and relationships of "processor_status"
"""
type processor_status {
  last_success_version: bigint!
  last_transaction_timestamp: timestamp
  last_updated: timestamp!
  processor: String!
}

"""
aggregated selection of "processor_status"
"""
type processor_status_aggregate {
  aggregate: processor_status_aggregate_fields
  nodes: [processor_status!]!
}

"""
aggregate fields of "processor_status"
"""
type processor_status_aggregate_fields {
  avg: processor_status_avg_fields
  count(columns: [processor_status_select_column!], distinct: Boolean): Int!
  max: processor_status_max_fields
  min: processor_status_min_fields
  stddev: processor_status_stddev_fields
  stddev_pop: processor_status_stddev_pop_fields
  stddev_samp: processor_status_stddev_samp_fields
  sum: processor_status_sum_fields
  var_pop: processor_status_var_pop_fields
  var_samp: processor_status_var_samp_fields
  variance: processor_status_variance_fields
}

"""aggregate avg on columns"""
type processor_status_avg_fields {
  last_success_version: Float
}

"""
Boolean expression to filter rows from the table "processor_status". All fields are combined with a logical 'AND'.
"""
input processor_status_bool_exp {
  _and: [processor_status_bool_exp!]
  _not: processor_status_bool_exp
  _or: [processor_status_bool_exp!]
  last_success_version: bigint_comparison_exp
  last_transaction_timestamp: timestamp_comparison_exp
  last_updated: timestamp_comparison_exp
  processor: String_comparison_exp
}

"""
unique or primary key constraints on table "processor_status"
"""
enum processor_status_constraint {
  """
  unique or primary key constraint on columns "processor"
  """
  processor_status_pkey
}

"""
input type for incrementing numeric columns in table "processor_status"
"""
input processor_status_inc_input {
  last_success_version: bigint
}

"""
input type for inserting data into table "processor_status"
"""
input processor_status_insert_input {
  last_success_version: bigint
  last_transaction_timestamp: timestamp
  last_updated: timestamp
  processor: String
}

"""aggregate max on columns"""
type processor_status_max_fields {
  last_success_version: bigint
  last_transaction_timestamp: timestamp
  last_updated: timestamp
  processor: String
}

"""aggregate min on columns"""
type processor_status_min_fields {
  last_success_version: bigint
  last_transaction_timestamp: timestamp
  last_updated: timestamp
  processor: String
}

"""
response of any mutation on the table "processor_status"
"""
type processor_status_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [processor_status!]!
}

"""
on_conflict condition type for table "processor_status"
"""
input processor_status_on_conflict {
  constraint: processor_status_constraint!
  update_columns: [processor_status_update_column!]! = []
  where: processor_status_bool_exp
}

"""Ordering options when selecting data from "processor_status"."""
input processor_status_order_by {
  last_success_version: order_by
  last_transaction_timestamp: order_by
  last_updated: order_by
  processor: order_by
}

"""primary key columns input for table: processor_status"""
input processor_status_pk_columns_input {
  processor: String!
}

"""
select columns of table "processor_status"
"""
enum processor_status_select_column {
  """column name"""
  last_success_version

  """column name"""
  last_transaction_timestamp

  """column name"""
  last_updated

  """column name"""
  processor
}

"""
input type for updating data in table "processor_status"
"""
input processor_status_set_input {
  last_success_version: bigint
  last_transaction_timestamp: timestamp
  last_updated: timestamp
  processor: String
}

"""aggregate stddev on columns"""
type processor_status_stddev_fields {
  last_success_version: Float
}

"""aggregate stddev_pop on columns"""
type processor_status_stddev_pop_fields {
  last_success_version: Float
}

"""aggregate stddev_samp on columns"""
type processor_status_stddev_samp_fields {
  last_success_version: Float
}

"""
Streaming cursor of the table "processor_status"
"""
input processor_status_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: processor_status_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input processor_status_stream_cursor_value_input {
  last_success_version: bigint
  last_transaction_timestamp: timestamp
  last_updated: timestamp
  processor: String
}

"""aggregate sum on columns"""
type processor_status_sum_fields {
  last_success_version: bigint
}

"""
update columns of table "processor_status"
"""
enum processor_status_update_column {
  """column name"""
  last_success_version

  """column name"""
  last_transaction_timestamp

  """column name"""
  last_updated

  """column name"""
  processor
}

input processor_status_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: processor_status_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: processor_status_set_input

  """filter the rows which have to be updated"""
  where: processor_status_bool_exp!
}

"""aggregate var_pop on columns"""
type processor_status_var_pop_fields {
  last_success_version: Float
}

"""aggregate var_samp on columns"""
type processor_status_var_samp_fields {
  last_success_version: Float
}

"""aggregate variance on columns"""
type processor_status_variance_fields {
  last_success_version: Float
}

"""
columns and relationships of "proposal_votes"
"""
type proposal_votes {
  inserted_at: timestamp!
  num_votes: numeric!
  proposal_id: bigint!
  should_pass: Boolean!
  staking_pool_address: String!
  transaction_timestamp: timestamp!
  transaction_version: bigint!
  voter_address: String!
}

"""
aggregated selection of "proposal_votes"
"""
type proposal_votes_aggregate {
  aggregate: proposal_votes_aggregate_fields
  nodes: [proposal_votes!]!
}

"""
aggregate fields of "proposal_votes"
"""
type proposal_votes_aggregate_fields {
  avg: proposal_votes_avg_fields
  count(columns: [proposal_votes_select_column!], distinct: Boolean): Int!
  max: proposal_votes_max_fields
  min: proposal_votes_min_fields
  stddev: proposal_votes_stddev_fields
  stddev_pop: proposal_votes_stddev_pop_fields
  stddev_samp: proposal_votes_stddev_samp_fields
  sum: proposal_votes_sum_fields
  var_pop: proposal_votes_var_pop_fields
  var_samp: proposal_votes_var_samp_fields
  variance: proposal_votes_variance_fields
}

"""aggregate avg on columns"""
type proposal_votes_avg_fields {
  num_votes: Float
  proposal_id: Float
  transaction_version: Float
}

"""
Boolean expression to filter rows from the table "proposal_votes". All fields are combined with a logical 'AND'.
"""
input proposal_votes_bool_exp {
  _and: [proposal_votes_bool_exp!]
  _not: proposal_votes_bool_exp
  _or: [proposal_votes_bool_exp!]
  inserted_at: timestamp_comparison_exp
  num_votes: numeric_comparison_exp
  proposal_id: bigint_comparison_exp
  should_pass: Boolean_comparison_exp
  staking_pool_address: String_comparison_exp
  transaction_timestamp: timestamp_comparison_exp
  transaction_version: bigint_comparison_exp
  voter_address: String_comparison_exp
}

"""
unique or primary key constraints on table "proposal_votes"
"""
enum proposal_votes_constraint {
  """
  unique or primary key constraint on columns "transaction_version", "voter_address", "proposal_id"
  """
  proposal_votes_pkey
}

"""
input type for incrementing numeric columns in table "proposal_votes"
"""
input proposal_votes_inc_input {
  num_votes: numeric
  proposal_id: bigint
  transaction_version: bigint
}

"""
input type for inserting data into table "proposal_votes"
"""
input proposal_votes_insert_input {
  inserted_at: timestamp
  num_votes: numeric
  proposal_id: bigint
  should_pass: Boolean
  staking_pool_address: String
  transaction_timestamp: timestamp
  transaction_version: bigint
  voter_address: String
}

"""aggregate max on columns"""
type proposal_votes_max_fields {
  inserted_at: timestamp
  num_votes: numeric
  proposal_id: bigint
  staking_pool_address: String
  transaction_timestamp: timestamp
  transaction_version: bigint
  voter_address: String
}

"""aggregate min on columns"""
type proposal_votes_min_fields {
  inserted_at: timestamp
  num_votes: numeric
  proposal_id: bigint
  staking_pool_address: String
  transaction_timestamp: timestamp
  transaction_version: bigint
  voter_address: String
}

"""
response of any mutation on the table "proposal_votes"
"""
type proposal_votes_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [proposal_votes!]!
}

"""
on_conflict condition type for table "proposal_votes"
"""
input proposal_votes_on_conflict {
  constraint: proposal_votes_constraint!
  update_columns: [proposal_votes_update_column!]! = []
  where: proposal_votes_bool_exp
}

"""Ordering options when selecting data from "proposal_votes"."""
input proposal_votes_order_by {
  inserted_at: order_by
  num_votes: order_by
  proposal_id: order_by
  should_pass: order_by
  staking_pool_address: order_by
  transaction_timestamp: order_by
  transaction_version: order_by
  voter_address: order_by
}

"""primary key columns input for table: proposal_votes"""
input proposal_votes_pk_columns_input {
  proposal_id: bigint!
  transaction_version: bigint!
  voter_address: String!
}

"""
select columns of table "proposal_votes"
"""
enum proposal_votes_select_column {
  """column name"""
  inserted_at

  """column name"""
  num_votes

  """column name"""
  proposal_id

  """column name"""
  should_pass

  """column name"""
  staking_pool_address

  """column name"""
  transaction_timestamp

  """column name"""
  transaction_version

  """column name"""
  voter_address
}

"""
input type for updating data in table "proposal_votes"
"""
input proposal_votes_set_input {
  inserted_at: timestamp
  num_votes: numeric
  proposal_id: bigint
  should_pass: Boolean
  staking_pool_address: String
  transaction_timestamp: timestamp
  transaction_version: bigint
  voter_address: String
}

"""aggregate stddev on columns"""
type proposal_votes_stddev_fields {
  num_votes: Float
  proposal_id: Float
  transaction_version: Float
}

"""aggregate stddev_pop on columns"""
type proposal_votes_stddev_pop_fields {
  num_votes: Float
  proposal_id: Float
  transaction_version: Float
}

"""aggregate stddev_samp on columns"""
type proposal_votes_stddev_samp_fields {
  num_votes: Float
  proposal_id: Float
  transaction_version: Float
}

"""
Streaming cursor of the table "proposal_votes"
"""
input proposal_votes_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: proposal_votes_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input proposal_votes_stream_cursor_value_input {
  inserted_at: timestamp
  num_votes: numeric
  proposal_id: bigint
  should_pass: Boolean
  staking_pool_address: String
  transaction_timestamp: timestamp
  transaction_version: bigint
  voter_address: String
}

"""aggregate sum on columns"""
type proposal_votes_sum_fields {
  num_votes: numeric
  proposal_id: bigint
  transaction_version: bigint
}

"""
update columns of table "proposal_votes"
"""
enum proposal_votes_update_column {
  """column name"""
  inserted_at

  """column name"""
  num_votes

  """column name"""
  proposal_id

  """column name"""
  should_pass

  """column name"""
  staking_pool_address

  """column name"""
  transaction_timestamp

  """column name"""
  transaction_version

  """column name"""
  voter_address
}

input proposal_votes_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: proposal_votes_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: proposal_votes_set_input

  """filter the rows which have to be updated"""
  where: proposal_votes_bool_exp!
}

"""aggregate var_pop on columns"""
type proposal_votes_var_pop_fields {
  num_votes: Float
  proposal_id: Float
  transaction_version: Float
}

"""aggregate var_samp on columns"""
type proposal_votes_var_samp_fields {
  num_votes: Float
  proposal_id: Float
  transaction_version: Float
}

"""aggregate variance on columns"""
type proposal_votes_variance_fields {
  num_votes: Float
  proposal_id: Float
  transaction_version: Float
}

type query_root {
  """
  fetch data from the table: "account_transactions"
  """
  account_transactions(
    """distinct select on columns"""
    distinct_on: [account_transactions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [account_transactions_order_by!]

    """filter the rows returned"""
    where: account_transactions_bool_exp
  ): [account_transactions!]!

  """
  fetch aggregated fields from the table: "account_transactions"
  """
  account_transactions_aggregate(
    """distinct select on columns"""
    distinct_on: [account_transactions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [account_transactions_order_by!]

    """filter the rows returned"""
    where: account_transactions_bool_exp
  ): account_transactions_aggregate!

  """
  fetch data from the table: "account_transactions" using primary key columns
  """
  account_transactions_by_pk(account_address: String!, transaction_version: bigint!): account_transactions

  """
  fetch data from the table: "address_events_summary"
  """
  address_events_summary(
    """distinct select on columns"""
    distinct_on: [address_events_summary_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [address_events_summary_order_by!]

    """filter the rows returned"""
    where: address_events_summary_bool_exp
  ): [address_events_summary!]!

  """
  fetch aggregated fields from the table: "address_events_summary"
  """
  address_events_summary_aggregate(
    """distinct select on columns"""
    distinct_on: [address_events_summary_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [address_events_summary_order_by!]

    """filter the rows returned"""
    where: address_events_summary_bool_exp
  ): address_events_summary_aggregate!

  """
  fetch data from the table: "address_version_from_events"
  """
  address_version_from_events(
    """distinct select on columns"""
    distinct_on: [address_version_from_events_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [address_version_from_events_order_by!]

    """filter the rows returned"""
    where: address_version_from_events_bool_exp
  ): [address_version_from_events!]!

  """
  fetch aggregated fields from the table: "address_version_from_events"
  """
  address_version_from_events_aggregate(
    """distinct select on columns"""
    distinct_on: [address_version_from_events_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [address_version_from_events_order_by!]

    """filter the rows returned"""
    where: address_version_from_events_bool_exp
  ): address_version_from_events_aggregate!

  """
  fetch data from the table: "legacy_migration_v1.address_version_from_move_resources"
  """
  address_version_from_move_resources(
    """distinct select on columns"""
    distinct_on: [address_version_from_move_resources_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [address_version_from_move_resources_order_by!]

    """filter the rows returned"""
    where: address_version_from_move_resources_bool_exp
  ): [address_version_from_move_resources!]!

  """
  fetch aggregated fields from the table: "legacy_migration_v1.address_version_from_move_resources"
  """
  address_version_from_move_resources_aggregate(
    """distinct select on columns"""
    distinct_on: [address_version_from_move_resources_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [address_version_from_move_resources_order_by!]

    """filter the rows returned"""
    where: address_version_from_move_resources_bool_exp
  ): address_version_from_move_resources_aggregate!

  """
  fetch data from the table: "block_metadata_transactions"
  """
  block_metadata_transactions(
    """distinct select on columns"""
    distinct_on: [block_metadata_transactions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [block_metadata_transactions_order_by!]

    """filter the rows returned"""
    where: block_metadata_transactions_bool_exp
  ): [block_metadata_transactions!]!

  """
  fetch aggregated fields from the table: "block_metadata_transactions"
  """
  block_metadata_transactions_aggregate(
    """distinct select on columns"""
    distinct_on: [block_metadata_transactions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [block_metadata_transactions_order_by!]

    """filter the rows returned"""
    where: block_metadata_transactions_bool_exp
  ): block_metadata_transactions_aggregate!

  """
  fetch data from the table: "block_metadata_transactions" using primary key columns
  """
  block_metadata_transactions_by_pk(version: bigint!): block_metadata_transactions

  """An array relationship"""
  coin_activities(
    """distinct select on columns"""
    distinct_on: [coin_activities_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [coin_activities_order_by!]

    """filter the rows returned"""
    where: coin_activities_bool_exp
  ): [coin_activities!]!

  """An aggregate relationship"""
  coin_activities_aggregate(
    """distinct select on columns"""
    distinct_on: [coin_activities_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [coin_activities_order_by!]

    """filter the rows returned"""
    where: coin_activities_bool_exp
  ): coin_activities_aggregate!

  """
  fetch data from the table: "legacy_migration_v1.coin_balances"
  """
  coin_balances(
    """distinct select on columns"""
    distinct_on: [coin_balances_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [coin_balances_order_by!]

    """filter the rows returned"""
    where: coin_balances_bool_exp
  ): [coin_balances!]!

  """
  fetch aggregated fields from the table: "legacy_migration_v1.coin_balances"
  """
  coin_balances_aggregate(
    """distinct select on columns"""
    distinct_on: [coin_balances_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [coin_balances_order_by!]

    """filter the rows returned"""
    where: coin_balances_bool_exp
  ): coin_balances_aggregate!

  """
  fetch data from the table: "legacy_migration_v1.coin_infos"
  """
  coin_infos(
    """distinct select on columns"""
    distinct_on: [coin_infos_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [coin_infos_order_by!]

    """filter the rows returned"""
    where: coin_infos_bool_exp
  ): [coin_infos!]!

  """
  fetch aggregated fields from the table: "legacy_migration_v1.coin_infos"
  """
  coin_infos_aggregate(
    """distinct select on columns"""
    distinct_on: [coin_infos_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [coin_infos_order_by!]

    """filter the rows returned"""
    where: coin_infos_bool_exp
  ): coin_infos_aggregate!

  """
  fetch data from the table: "coin_supply"
  """
  coin_supply(
    """distinct select on columns"""
    distinct_on: [coin_supply_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [coin_supply_order_by!]

    """filter the rows returned"""
    where: coin_supply_bool_exp
  ): [coin_supply!]!

  """
  fetch aggregated fields from the table: "coin_supply"
  """
  coin_supply_aggregate(
    """distinct select on columns"""
    distinct_on: [coin_supply_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [coin_supply_order_by!]

    """filter the rows returned"""
    where: coin_supply_bool_exp
  ): coin_supply_aggregate!

  """fetch data from the table: "coin_supply" using primary key columns"""
  coin_supply_by_pk(coin_type_hash: String!, transaction_version: bigint!): coin_supply

  """
  fetch data from the table: "legacy_migration_v1.collection_datas"
  """
  collection_datas(
    """distinct select on columns"""
    distinct_on: [collection_datas_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [collection_datas_order_by!]

    """filter the rows returned"""
    where: collection_datas_bool_exp
  ): [collection_datas!]!

  """
  fetch aggregated fields from the table: "legacy_migration_v1.collection_datas"
  """
  collection_datas_aggregate(
    """distinct select on columns"""
    distinct_on: [collection_datas_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [collection_datas_order_by!]

    """filter the rows returned"""
    where: collection_datas_bool_exp
  ): collection_datas_aggregate!

  """
  fetch data from the table: "legacy_migration_v1.current_ans_lookup"
  """
  current_ans_lookup(
    """distinct select on columns"""
    distinct_on: [current_ans_lookup_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_ans_lookup_order_by!]

    """filter the rows returned"""
    where: current_ans_lookup_bool_exp
  ): [current_ans_lookup!]!

  """
  fetch aggregated fields from the table: "legacy_migration_v1.current_ans_lookup"
  """
  current_ans_lookup_aggregate(
    """distinct select on columns"""
    distinct_on: [current_ans_lookup_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_ans_lookup_order_by!]

    """filter the rows returned"""
    where: current_ans_lookup_bool_exp
  ): current_ans_lookup_aggregate!

  """
  fetch data from the table: "current_ans_lookup_v2"
  """
  current_ans_lookup_v2(
    """distinct select on columns"""
    distinct_on: [current_ans_lookup_v2_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_ans_lookup_v2_order_by!]

    """filter the rows returned"""
    where: current_ans_lookup_v2_bool_exp
  ): [current_ans_lookup_v2!]!

  """
  fetch aggregated fields from the table: "current_ans_lookup_v2"
  """
  current_ans_lookup_v2_aggregate(
    """distinct select on columns"""
    distinct_on: [current_ans_lookup_v2_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_ans_lookup_v2_order_by!]

    """filter the rows returned"""
    where: current_ans_lookup_v2_bool_exp
  ): current_ans_lookup_v2_aggregate!

  """
  fetch data from the table: "current_ans_lookup_v2" using primary key columns
  """
  current_ans_lookup_v2_by_pk(domain: String!, subdomain: String!, token_standard: String!): current_ans_lookup_v2

  """
  fetch data from the table: "current_aptos_names"
  """
  current_aptos_names(
    """distinct select on columns"""
    distinct_on: [current_aptos_names_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_aptos_names_order_by!]

    """filter the rows returned"""
    where: current_aptos_names_bool_exp
  ): [current_aptos_names!]!

  """
  fetch aggregated fields from the table: "current_aptos_names"
  """
  current_aptos_names_aggregate(
    """distinct select on columns"""
    distinct_on: [current_aptos_names_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_aptos_names_order_by!]

    """filter the rows returned"""
    where: current_aptos_names_bool_exp
  ): current_aptos_names_aggregate!

  """
  fetch data from the table: "legacy_migration_v1.current_coin_balances"
  """
  current_coin_balances(
    """distinct select on columns"""
    distinct_on: [current_coin_balances_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_coin_balances_order_by!]

    """filter the rows returned"""
    where: current_coin_balances_bool_exp
  ): [current_coin_balances!]!

  """
  fetch aggregated fields from the table: "legacy_migration_v1.current_coin_balances"
  """
  current_coin_balances_aggregate(
    """distinct select on columns"""
    distinct_on: [current_coin_balances_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_coin_balances_order_by!]

    """filter the rows returned"""
    where: current_coin_balances_bool_exp
  ): current_coin_balances_aggregate!

  """
  fetch data from the table: "legacy_migration_v1.current_collection_datas"
  """
  current_collection_datas(
    """distinct select on columns"""
    distinct_on: [current_collection_datas_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_collection_datas_order_by!]

    """filter the rows returned"""
    where: current_collection_datas_bool_exp
  ): [current_collection_datas!]!

  """
  fetch aggregated fields from the table: "legacy_migration_v1.current_collection_datas"
  """
  current_collection_datas_aggregate(
    """distinct select on columns"""
    distinct_on: [current_collection_datas_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_collection_datas_order_by!]

    """filter the rows returned"""
    where: current_collection_datas_bool_exp
  ): current_collection_datas_aggregate!

  """
  fetch data from the table: "current_collection_ownership_v2_view"
  """
  current_collection_ownership_v2_view(
    """distinct select on columns"""
    distinct_on: [current_collection_ownership_v2_view_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_collection_ownership_v2_view_order_by!]

    """filter the rows returned"""
    where: current_collection_ownership_v2_view_bool_exp
  ): [current_collection_ownership_v2_view!]!

  """
  fetch aggregated fields from the table: "current_collection_ownership_v2_view"
  """
  current_collection_ownership_v2_view_aggregate(
    """distinct select on columns"""
    distinct_on: [current_collection_ownership_v2_view_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_collection_ownership_v2_view_order_by!]

    """filter the rows returned"""
    where: current_collection_ownership_v2_view_bool_exp
  ): current_collection_ownership_v2_view_aggregate!

  """
  fetch data from the table: "current_collections_v2"
  """
  current_collections_v2(
    """distinct select on columns"""
    distinct_on: [current_collections_v2_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_collections_v2_order_by!]

    """filter the rows returned"""
    where: current_collections_v2_bool_exp
  ): [current_collections_v2!]!

  """
  fetch aggregated fields from the table: "current_collections_v2"
  """
  current_collections_v2_aggregate(
    """distinct select on columns"""
    distinct_on: [current_collections_v2_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_collections_v2_order_by!]

    """filter the rows returned"""
    where: current_collections_v2_bool_exp
  ): current_collections_v2_aggregate!

  """
  fetch data from the table: "current_collections_v2" using primary key columns
  """
  current_collections_v2_by_pk(collection_id: String!): current_collections_v2

  """
  fetch data from the table: "current_delegated_staking_pool_balances"
  """
  current_delegated_staking_pool_balances(
    """distinct select on columns"""
    distinct_on: [current_delegated_staking_pool_balances_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_delegated_staking_pool_balances_order_by!]

    """filter the rows returned"""
    where: current_delegated_staking_pool_balances_bool_exp
  ): [current_delegated_staking_pool_balances!]!

  """
  fetch aggregated fields from the table: "current_delegated_staking_pool_balances"
  """
  current_delegated_staking_pool_balances_aggregate(
    """distinct select on columns"""
    distinct_on: [current_delegated_staking_pool_balances_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_delegated_staking_pool_balances_order_by!]

    """filter the rows returned"""
    where: current_delegated_staking_pool_balances_bool_exp
  ): current_delegated_staking_pool_balances_aggregate!

  """
  fetch data from the table: "current_delegated_staking_pool_balances" using primary key columns
  """
  current_delegated_staking_pool_balances_by_pk(staking_pool_address: String!): current_delegated_staking_pool_balances

  """
  fetch data from the table: "current_delegated_voter"
  """
  current_delegated_voter(
    """distinct select on columns"""
    distinct_on: [current_delegated_voter_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_delegated_voter_order_by!]

    """filter the rows returned"""
    where: current_delegated_voter_bool_exp
  ): [current_delegated_voter!]!

  """
  fetch aggregated fields from the table: "current_delegated_voter"
  """
  current_delegated_voter_aggregate(
    """distinct select on columns"""
    distinct_on: [current_delegated_voter_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_delegated_voter_order_by!]

    """filter the rows returned"""
    where: current_delegated_voter_bool_exp
  ): current_delegated_voter_aggregate!

  """
  fetch data from the table: "current_delegated_voter" using primary key columns
  """
  current_delegated_voter_by_pk(delegation_pool_address: String!, delegator_address: String!): current_delegated_voter

  """
  fetch data from the table: "current_delegator_balances"
  """
  current_delegator_balances(
    """distinct select on columns"""
    distinct_on: [current_delegator_balances_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_delegator_balances_order_by!]

    """filter the rows returned"""
    where: current_delegator_balances_bool_exp
  ): [current_delegator_balances!]!

  """
  fetch aggregated fields from the table: "current_delegator_balances"
  """
  current_delegator_balances_aggregate(
    """distinct select on columns"""
    distinct_on: [current_delegator_balances_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_delegator_balances_order_by!]

    """filter the rows returned"""
    where: current_delegator_balances_bool_exp
  ): current_delegator_balances_aggregate!

  """
  fetch data from the table: "current_delegator_balances" using primary key columns
  """
  current_delegator_balances_by_pk(delegator_address: String!, pool_address: String!, pool_type: String!, table_handle: String!): current_delegator_balances

  """
  fetch data from the table: "current_fungible_asset_balances"
  """
  current_fungible_asset_balances(
    """distinct select on columns"""
    distinct_on: [current_fungible_asset_balances_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_fungible_asset_balances_order_by!]

    """filter the rows returned"""
    where: current_fungible_asset_balances_bool_exp
  ): [current_fungible_asset_balances!]!

  """
  fetch aggregated fields from the table: "current_fungible_asset_balances"
  """
  current_fungible_asset_balances_aggregate(
    """distinct select on columns"""
    distinct_on: [current_fungible_asset_balances_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_fungible_asset_balances_order_by!]

    """filter the rows returned"""
    where: current_fungible_asset_balances_bool_exp
  ): current_fungible_asset_balances_aggregate!

  """
  fetch data from the table: "current_fungible_asset_balances" using primary key columns
  """
  current_fungible_asset_balances_by_pk(storage_id: String!): current_fungible_asset_balances

  """
  fetch data from the table: "current_objects"
  """
  current_objects(
    """distinct select on columns"""
    distinct_on: [current_objects_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_objects_order_by!]

    """filter the rows returned"""
    where: current_objects_bool_exp
  ): [current_objects!]!

  """
  fetch aggregated fields from the table: "current_objects"
  """
  current_objects_aggregate(
    """distinct select on columns"""
    distinct_on: [current_objects_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_objects_order_by!]

    """filter the rows returned"""
    where: current_objects_bool_exp
  ): current_objects_aggregate!

  """fetch data from the table: "current_objects" using primary key columns"""
  current_objects_by_pk(object_address: String!): current_objects

  """
  fetch data from the table: "current_staking_pool_voter"
  """
  current_staking_pool_voter(
    """distinct select on columns"""
    distinct_on: [current_staking_pool_voter_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_staking_pool_voter_order_by!]

    """filter the rows returned"""
    where: current_staking_pool_voter_bool_exp
  ): [current_staking_pool_voter!]!

  """
  fetch aggregated fields from the table: "current_staking_pool_voter"
  """
  current_staking_pool_voter_aggregate(
    """distinct select on columns"""
    distinct_on: [current_staking_pool_voter_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_staking_pool_voter_order_by!]

    """filter the rows returned"""
    where: current_staking_pool_voter_bool_exp
  ): current_staking_pool_voter_aggregate!

  """
  fetch data from the table: "current_staking_pool_voter" using primary key columns
  """
  current_staking_pool_voter_by_pk(staking_pool_address: String!): current_staking_pool_voter

  """
  fetch data from the table: "current_table_items"
  """
  current_table_items(
    """distinct select on columns"""
    distinct_on: [current_table_items_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_table_items_order_by!]

    """filter the rows returned"""
    where: current_table_items_bool_exp
  ): [current_table_items!]!

  """
  fetch aggregated fields from the table: "current_table_items"
  """
  current_table_items_aggregate(
    """distinct select on columns"""
    distinct_on: [current_table_items_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_table_items_order_by!]

    """filter the rows returned"""
    where: current_table_items_bool_exp
  ): current_table_items_aggregate!

  """
  fetch data from the table: "current_table_items" using primary key columns
  """
  current_table_items_by_pk(key_hash: String!, table_handle: String!): current_table_items

  """
  fetch data from the table: "legacy_migration_v1.current_token_datas"
  """
  current_token_datas(
    """distinct select on columns"""
    distinct_on: [current_token_datas_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_token_datas_order_by!]

    """filter the rows returned"""
    where: current_token_datas_bool_exp
  ): [current_token_datas!]!

  """
  fetch aggregated fields from the table: "legacy_migration_v1.current_token_datas"
  """
  current_token_datas_aggregate(
    """distinct select on columns"""
    distinct_on: [current_token_datas_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_token_datas_order_by!]

    """filter the rows returned"""
    where: current_token_datas_bool_exp
  ): current_token_datas_aggregate!

  """
  fetch data from the table: "current_token_datas_v2"
  """
  current_token_datas_v2(
    """distinct select on columns"""
    distinct_on: [current_token_datas_v2_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_token_datas_v2_order_by!]

    """filter the rows returned"""
    where: current_token_datas_v2_bool_exp
  ): [current_token_datas_v2!]!

  """
  fetch aggregated fields from the table: "current_token_datas_v2"
  """
  current_token_datas_v2_aggregate(
    """distinct select on columns"""
    distinct_on: [current_token_datas_v2_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_token_datas_v2_order_by!]

    """filter the rows returned"""
    where: current_token_datas_v2_bool_exp
  ): current_token_datas_v2_aggregate!

  """
  fetch data from the table: "current_token_datas_v2" using primary key columns
  """
  current_token_datas_v2_by_pk(token_data_id: String!): current_token_datas_v2

  """
  fetch data from the table: "legacy_migration_v1.current_token_ownerships"
  """
  current_token_ownerships(
    """distinct select on columns"""
    distinct_on: [current_token_ownerships_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_token_ownerships_order_by!]

    """filter the rows returned"""
    where: current_token_ownerships_bool_exp
  ): [current_token_ownerships!]!

  """
  fetch aggregated fields from the table: "legacy_migration_v1.current_token_ownerships"
  """
  current_token_ownerships_aggregate(
    """distinct select on columns"""
    distinct_on: [current_token_ownerships_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_token_ownerships_order_by!]

    """filter the rows returned"""
    where: current_token_ownerships_bool_exp
  ): current_token_ownerships_aggregate!

  """
  fetch data from the table: "current_token_ownerships_v2"
  """
  current_token_ownerships_v2(
    """distinct select on columns"""
    distinct_on: [current_token_ownerships_v2_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_token_ownerships_v2_order_by!]

    """filter the rows returned"""
    where: current_token_ownerships_v2_bool_exp
  ): [current_token_ownerships_v2!]!

  """
  fetch aggregated fields from the table: "current_token_ownerships_v2"
  """
  current_token_ownerships_v2_aggregate(
    """distinct select on columns"""
    distinct_on: [current_token_ownerships_v2_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_token_ownerships_v2_order_by!]

    """filter the rows returned"""
    where: current_token_ownerships_v2_bool_exp
  ): current_token_ownerships_v2_aggregate!

  """
  fetch data from the table: "current_token_ownerships_v2" using primary key columns
  """
  current_token_ownerships_v2_by_pk(owner_address: String!, property_version_v1: numeric!, storage_id: String!, token_data_id: String!): current_token_ownerships_v2

  """
  fetch data from the table: "current_token_pending_claims"
  """
  current_token_pending_claims(
    """distinct select on columns"""
    distinct_on: [current_token_pending_claims_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_token_pending_claims_order_by!]

    """filter the rows returned"""
    where: current_token_pending_claims_bool_exp
  ): [current_token_pending_claims!]!

  """
  fetch aggregated fields from the table: "current_token_pending_claims"
  """
  current_token_pending_claims_aggregate(
    """distinct select on columns"""
    distinct_on: [current_token_pending_claims_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_token_pending_claims_order_by!]

    """filter the rows returned"""
    where: current_token_pending_claims_bool_exp
  ): current_token_pending_claims_aggregate!

  """
  fetch data from the table: "current_token_pending_claims" using primary key columns
  """
  current_token_pending_claims_by_pk(from_address: String!, property_version: numeric!, to_address: String!, token_data_id_hash: String!): current_token_pending_claims

  """
  fetch data from the table: "current_token_royalty_v1"
  """
  current_token_royalty_v1(
    """distinct select on columns"""
    distinct_on: [current_token_royalty_v1_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_token_royalty_v1_order_by!]

    """filter the rows returned"""
    where: current_token_royalty_v1_bool_exp
  ): [current_token_royalty_v1!]!

  """
  fetch aggregated fields from the table: "current_token_royalty_v1"
  """
  current_token_royalty_v1_aggregate(
    """distinct select on columns"""
    distinct_on: [current_token_royalty_v1_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_token_royalty_v1_order_by!]

    """filter the rows returned"""
    where: current_token_royalty_v1_bool_exp
  ): current_token_royalty_v1_aggregate!

  """
  fetch data from the table: "current_token_royalty_v1" using primary key columns
  """
  current_token_royalty_v1_by_pk(token_data_id: String!): current_token_royalty_v1

  """An array relationship"""
  delegated_staking_activities(
    """distinct select on columns"""
    distinct_on: [delegated_staking_activities_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delegated_staking_activities_order_by!]

    """filter the rows returned"""
    where: delegated_staking_activities_bool_exp
  ): [delegated_staking_activities!]!

  """An aggregate relationship"""
  delegated_staking_activities_aggregate(
    """distinct select on columns"""
    distinct_on: [delegated_staking_activities_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delegated_staking_activities_order_by!]

    """filter the rows returned"""
    where: delegated_staking_activities_bool_exp
  ): delegated_staking_activities_aggregate!

  """
  fetch data from the table: "delegated_staking_activities" using primary key columns
  """
  delegated_staking_activities_by_pk(event_index: bigint!, transaction_version: bigint!): delegated_staking_activities

  """
  fetch data from the table: "delegated_staking_pool_balances"
  """
  delegated_staking_pool_balances(
    """distinct select on columns"""
    distinct_on: [delegated_staking_pool_balances_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delegated_staking_pool_balances_order_by!]

    """filter the rows returned"""
    where: delegated_staking_pool_balances_bool_exp
  ): [delegated_staking_pool_balances!]!

  """
  fetch aggregated fields from the table: "delegated_staking_pool_balances"
  """
  delegated_staking_pool_balances_aggregate(
    """distinct select on columns"""
    distinct_on: [delegated_staking_pool_balances_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delegated_staking_pool_balances_order_by!]

    """filter the rows returned"""
    where: delegated_staking_pool_balances_bool_exp
  ): delegated_staking_pool_balances_aggregate!

  """
  fetch data from the table: "delegated_staking_pool_balances" using primary key columns
  """
  delegated_staking_pool_balances_by_pk(staking_pool_address: String!, transaction_version: bigint!): delegated_staking_pool_balances

  """
  fetch data from the table: "delegated_staking_pools"
  """
  delegated_staking_pools(
    """distinct select on columns"""
    distinct_on: [delegated_staking_pools_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delegated_staking_pools_order_by!]

    """filter the rows returned"""
    where: delegated_staking_pools_bool_exp
  ): [delegated_staking_pools!]!

  """
  fetch aggregated fields from the table: "delegated_staking_pools"
  """
  delegated_staking_pools_aggregate(
    """distinct select on columns"""
    distinct_on: [delegated_staking_pools_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delegated_staking_pools_order_by!]

    """filter the rows returned"""
    where: delegated_staking_pools_bool_exp
  ): delegated_staking_pools_aggregate!

  """
  fetch data from the table: "delegated_staking_pools" using primary key columns
  """
  delegated_staking_pools_by_pk(staking_pool_address: String!): delegated_staking_pools

  """
  fetch data from the table: "delegator_distinct_pool"
  """
  delegator_distinct_pool(
    """distinct select on columns"""
    distinct_on: [delegator_distinct_pool_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delegator_distinct_pool_order_by!]

    """filter the rows returned"""
    where: delegator_distinct_pool_bool_exp
  ): [delegator_distinct_pool!]!

  """
  fetch aggregated fields from the table: "delegator_distinct_pool"
  """
  delegator_distinct_pool_aggregate(
    """distinct select on columns"""
    distinct_on: [delegator_distinct_pool_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delegator_distinct_pool_order_by!]

    """filter the rows returned"""
    where: delegator_distinct_pool_bool_exp
  ): delegator_distinct_pool_aggregate!

  """
  fetch data from the table: "events"
  """
  events(
    """distinct select on columns"""
    distinct_on: [events_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [events_order_by!]

    """filter the rows returned"""
    where: events_bool_exp
  ): [events!]!

  """
  fetch aggregated fields from the table: "events"
  """
  events_aggregate(
    """distinct select on columns"""
    distinct_on: [events_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [events_order_by!]

    """filter the rows returned"""
    where: events_bool_exp
  ): events_aggregate!

  """fetch data from the table: "events" using primary key columns"""
  events_by_pk(event_index: bigint!, transaction_version: bigint!): events

  """An array relationship"""
  fungible_asset_activities(
    """distinct select on columns"""
    distinct_on: [fungible_asset_activities_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [fungible_asset_activities_order_by!]

    """filter the rows returned"""
    where: fungible_asset_activities_bool_exp
  ): [fungible_asset_activities!]!

  """An aggregate relationship"""
  fungible_asset_activities_aggregate(
    """distinct select on columns"""
    distinct_on: [fungible_asset_activities_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [fungible_asset_activities_order_by!]

    """filter the rows returned"""
    where: fungible_asset_activities_bool_exp
  ): fungible_asset_activities_aggregate!

  """
  fetch data from the table: "fungible_asset_activities" using primary key columns
  """
  fungible_asset_activities_by_pk(event_index: bigint!, transaction_version: bigint!): fungible_asset_activities

  """
  fetch data from the table: "fungible_asset_metadata"
  """
  fungible_asset_metadata(
    """distinct select on columns"""
    distinct_on: [fungible_asset_metadata_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [fungible_asset_metadata_order_by!]

    """filter the rows returned"""
    where: fungible_asset_metadata_bool_exp
  ): [fungible_asset_metadata!]!

  """
  fetch aggregated fields from the table: "fungible_asset_metadata"
  """
  fungible_asset_metadata_aggregate(
    """distinct select on columns"""
    distinct_on: [fungible_asset_metadata_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [fungible_asset_metadata_order_by!]

    """filter the rows returned"""
    where: fungible_asset_metadata_bool_exp
  ): fungible_asset_metadata_aggregate!

  """
  fetch data from the table: "fungible_asset_metadata" using primary key columns
  """
  fungible_asset_metadata_by_pk(asset_type: String!): fungible_asset_metadata

  """
  fetch data from the table: "indexer_status"
  """
  indexer_status(
    """distinct select on columns"""
    distinct_on: [indexer_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [indexer_status_order_by!]

    """filter the rows returned"""
    where: indexer_status_bool_exp
  ): [indexer_status!]!

  """
  fetch aggregated fields from the table: "indexer_status"
  """
  indexer_status_aggregate(
    """distinct select on columns"""
    distinct_on: [indexer_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [indexer_status_order_by!]

    """filter the rows returned"""
    where: indexer_status_bool_exp
  ): indexer_status_aggregate!

  """fetch data from the table: "indexer_status" using primary key columns"""
  indexer_status_by_pk(db: String!): indexer_status

  """
  fetch data from the table: "ledger_infos"
  """
  ledger_infos(
    """distinct select on columns"""
    distinct_on: [ledger_infos_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ledger_infos_order_by!]

    """filter the rows returned"""
    where: ledger_infos_bool_exp
  ): [ledger_infos!]!

  """
  fetch aggregated fields from the table: "ledger_infos"
  """
  ledger_infos_aggregate(
    """distinct select on columns"""
    distinct_on: [ledger_infos_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ledger_infos_order_by!]

    """filter the rows returned"""
    where: ledger_infos_bool_exp
  ): ledger_infos_aggregate!

  """fetch data from the table: "ledger_infos" using primary key columns"""
  ledger_infos_by_pk(chain_id: bigint!): ledger_infos

  """
  fetch data from the table: "legacy_migration_v1.move_resources"
  """
  move_resources(
    """distinct select on columns"""
    distinct_on: [move_resources_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [move_resources_order_by!]

    """filter the rows returned"""
    where: move_resources_bool_exp
  ): [move_resources!]!

  """
  fetch aggregated fields from the table: "legacy_migration_v1.move_resources"
  """
  move_resources_aggregate(
    """distinct select on columns"""
    distinct_on: [move_resources_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [move_resources_order_by!]

    """filter the rows returned"""
    where: move_resources_bool_exp
  ): move_resources_aggregate!

  """
  fetch data from the table: "nft_metadata_crawler.parsed_asset_uris"
  """
  nft_metadata_crawler_parsed_asset_uris(
    """distinct select on columns"""
    distinct_on: [nft_metadata_crawler_parsed_asset_uris_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [nft_metadata_crawler_parsed_asset_uris_order_by!]

    """filter the rows returned"""
    where: nft_metadata_crawler_parsed_asset_uris_bool_exp
  ): [nft_metadata_crawler_parsed_asset_uris!]!

  """
  fetch aggregated fields from the table: "nft_metadata_crawler.parsed_asset_uris"
  """
  nft_metadata_crawler_parsed_asset_uris_aggregate(
    """distinct select on columns"""
    distinct_on: [nft_metadata_crawler_parsed_asset_uris_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [nft_metadata_crawler_parsed_asset_uris_order_by!]

    """filter the rows returned"""
    where: nft_metadata_crawler_parsed_asset_uris_bool_exp
  ): nft_metadata_crawler_parsed_asset_uris_aggregate!

  """
  fetch data from the table: "nft_metadata_crawler.parsed_asset_uris" using primary key columns
  """
  nft_metadata_crawler_parsed_asset_uris_by_pk(asset_uri: String!): nft_metadata_crawler_parsed_asset_uris

  """
  fetch data from the table: "num_active_delegator_per_pool"
  """
  num_active_delegator_per_pool(
    """distinct select on columns"""
    distinct_on: [num_active_delegator_per_pool_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [num_active_delegator_per_pool_order_by!]

    """filter the rows returned"""
    where: num_active_delegator_per_pool_bool_exp
  ): [num_active_delegator_per_pool!]!

  """
  fetch aggregated fields from the table: "num_active_delegator_per_pool"
  """
  num_active_delegator_per_pool_aggregate(
    """distinct select on columns"""
    distinct_on: [num_active_delegator_per_pool_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [num_active_delegator_per_pool_order_by!]

    """filter the rows returned"""
    where: num_active_delegator_per_pool_bool_exp
  ): num_active_delegator_per_pool_aggregate!

  """
  fetch data from the table: "processor_status"
  """
  processor_status(
    """distinct select on columns"""
    distinct_on: [processor_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [processor_status_order_by!]

    """filter the rows returned"""
    where: processor_status_bool_exp
  ): [processor_status!]!

  """
  fetch aggregated fields from the table: "processor_status"
  """
  processor_status_aggregate(
    """distinct select on columns"""
    distinct_on: [processor_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [processor_status_order_by!]

    """filter the rows returned"""
    where: processor_status_bool_exp
  ): processor_status_aggregate!

  """
  fetch data from the table: "processor_status" using primary key columns
  """
  processor_status_by_pk(processor: String!): processor_status

  """
  fetch data from the table: "proposal_votes"
  """
  proposal_votes(
    """distinct select on columns"""
    distinct_on: [proposal_votes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [proposal_votes_order_by!]

    """filter the rows returned"""
    where: proposal_votes_bool_exp
  ): [proposal_votes!]!

  """
  fetch aggregated fields from the table: "proposal_votes"
  """
  proposal_votes_aggregate(
    """distinct select on columns"""
    distinct_on: [proposal_votes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [proposal_votes_order_by!]

    """filter the rows returned"""
    where: proposal_votes_bool_exp
  ): proposal_votes_aggregate!

  """fetch data from the table: "proposal_votes" using primary key columns"""
  proposal_votes_by_pk(proposal_id: bigint!, transaction_version: bigint!, voter_address: String!): proposal_votes

  """
  fetch data from the table: "signatures"
  """
  signatures(
    """distinct select on columns"""
    distinct_on: [signatures_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [signatures_order_by!]

    """filter the rows returned"""
    where: signatures_bool_exp
  ): [signatures!]!

  """
  fetch aggregated fields from the table: "signatures"
  """
  signatures_aggregate(
    """distinct select on columns"""
    distinct_on: [signatures_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [signatures_order_by!]

    """filter the rows returned"""
    where: signatures_bool_exp
  ): signatures_aggregate!

  """fetch data from the table: "signatures" using primary key columns"""
  signatures_by_pk(is_sender_primary: Boolean!, multi_agent_index: bigint!, multi_sig_index: bigint!, transaction_version: bigint!): signatures

  """
  fetch data from the table: "table_items"
  """
  table_items(
    """distinct select on columns"""
    distinct_on: [table_items_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [table_items_order_by!]

    """filter the rows returned"""
    where: table_items_bool_exp
  ): [table_items!]!

  """
  fetch aggregated fields from the table: "table_items"
  """
  table_items_aggregate(
    """distinct select on columns"""
    distinct_on: [table_items_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [table_items_order_by!]

    """filter the rows returned"""
    where: table_items_bool_exp
  ): table_items_aggregate!

  """fetch data from the table: "table_items" using primary key columns"""
  table_items_by_pk(transaction_version: bigint!, write_set_change_index: bigint!): table_items

  """
  fetch data from the table: "table_metadatas"
  """
  table_metadatas(
    """distinct select on columns"""
    distinct_on: [table_metadatas_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [table_metadatas_order_by!]

    """filter the rows returned"""
    where: table_metadatas_bool_exp
  ): [table_metadatas!]!

  """
  fetch aggregated fields from the table: "table_metadatas"
  """
  table_metadatas_aggregate(
    """distinct select on columns"""
    distinct_on: [table_metadatas_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [table_metadatas_order_by!]

    """filter the rows returned"""
    where: table_metadatas_bool_exp
  ): table_metadatas_aggregate!

  """fetch data from the table: "table_metadatas" using primary key columns"""
  table_metadatas_by_pk(handle: String!): table_metadatas

  """An array relationship"""
  token_activities(
    """distinct select on columns"""
    distinct_on: [token_activities_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_activities_order_by!]

    """filter the rows returned"""
    where: token_activities_bool_exp
  ): [token_activities!]!

  """An aggregate relationship"""
  token_activities_aggregate(
    """distinct select on columns"""
    distinct_on: [token_activities_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_activities_order_by!]

    """filter the rows returned"""
    where: token_activities_bool_exp
  ): token_activities_aggregate!

  """An array relationship"""
  token_activities_v2(
    """distinct select on columns"""
    distinct_on: [token_activities_v2_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_activities_v2_order_by!]

    """filter the rows returned"""
    where: token_activities_v2_bool_exp
  ): [token_activities_v2!]!

  """An aggregate relationship"""
  token_activities_v2_aggregate(
    """distinct select on columns"""
    distinct_on: [token_activities_v2_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_activities_v2_order_by!]

    """filter the rows returned"""
    where: token_activities_v2_bool_exp
  ): token_activities_v2_aggregate!

  """
  fetch data from the table: "token_activities_v2" using primary key columns
  """
  token_activities_v2_by_pk(event_index: bigint!, transaction_version: bigint!): token_activities_v2

  """
  fetch data from the table: "legacy_migration_v1.token_datas"
  """
  token_datas(
    """distinct select on columns"""
    distinct_on: [token_datas_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_datas_order_by!]

    """filter the rows returned"""
    where: token_datas_bool_exp
  ): [token_datas!]!

  """
  fetch aggregated fields from the table: "legacy_migration_v1.token_datas"
  """
  token_datas_aggregate(
    """distinct select on columns"""
    distinct_on: [token_datas_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_datas_order_by!]

    """filter the rows returned"""
    where: token_datas_bool_exp
  ): token_datas_aggregate!

  """
  fetch data from the table: "legacy_migration_v1.token_ownerships"
  """
  token_ownerships(
    """distinct select on columns"""
    distinct_on: [token_ownerships_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_ownerships_order_by!]

    """filter the rows returned"""
    where: token_ownerships_bool_exp
  ): [token_ownerships!]!

  """
  fetch aggregated fields from the table: "legacy_migration_v1.token_ownerships"
  """
  token_ownerships_aggregate(
    """distinct select on columns"""
    distinct_on: [token_ownerships_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_ownerships_order_by!]

    """filter the rows returned"""
    where: token_ownerships_bool_exp
  ): token_ownerships_aggregate!

  """
  fetch data from the table: "legacy_migration_v1.tokens"
  """
  tokens(
    """distinct select on columns"""
    distinct_on: [tokens_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tokens_order_by!]

    """filter the rows returned"""
    where: tokens_bool_exp
  ): [tokens!]!

  """
  fetch aggregated fields from the table: "legacy_migration_v1.tokens"
  """
  tokens_aggregate(
    """distinct select on columns"""
    distinct_on: [tokens_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tokens_order_by!]

    """filter the rows returned"""
    where: tokens_bool_exp
  ): tokens_aggregate!

  """
  fetch data from the table: "user_transactions"
  """
  user_transactions(
    """distinct select on columns"""
    distinct_on: [user_transactions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_transactions_order_by!]

    """filter the rows returned"""
    where: user_transactions_bool_exp
  ): [user_transactions!]!

  """
  fetch aggregated fields from the table: "user_transactions"
  """
  user_transactions_aggregate(
    """distinct select on columns"""
    distinct_on: [user_transactions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_transactions_order_by!]

    """filter the rows returned"""
    where: user_transactions_bool_exp
  ): user_transactions_aggregate!

  """
  fetch data from the table: "user_transactions" using primary key columns
  """
  user_transactions_by_pk(version: bigint!): user_transactions
}

"""
columns and relationships of "signatures"
"""
type signatures {
  inserted_at: timestamp!
  is_sender_primary: Boolean!
  multi_agent_index: bigint!
  multi_sig_index: bigint!
  public_key: String!
  public_key_indices(
    """JSON select path"""
    path: String
  ): jsonb!
  signature: String!
  signer: String!
  threshold: bigint!
  transaction_block_height: bigint!
  transaction_version: bigint!
  type: String!
}

"""
aggregated selection of "signatures"
"""
type signatures_aggregate {
  aggregate: signatures_aggregate_fields
  nodes: [signatures!]!
}

"""
aggregate fields of "signatures"
"""
type signatures_aggregate_fields {
  avg: signatures_avg_fields
  count(columns: [signatures_select_column!], distinct: Boolean): Int!
  max: signatures_max_fields
  min: signatures_min_fields
  stddev: signatures_stddev_fields
  stddev_pop: signatures_stddev_pop_fields
  stddev_samp: signatures_stddev_samp_fields
  sum: signatures_sum_fields
  var_pop: signatures_var_pop_fields
  var_samp: signatures_var_samp_fields
  variance: signatures_variance_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input signatures_append_input {
  public_key_indices: jsonb
}

"""aggregate avg on columns"""
type signatures_avg_fields {
  multi_agent_index: Float
  multi_sig_index: Float
  threshold: Float
  transaction_block_height: Float
  transaction_version: Float
}

"""
Boolean expression to filter rows from the table "signatures". All fields are combined with a logical 'AND'.
"""
input signatures_bool_exp {
  _and: [signatures_bool_exp!]
  _not: signatures_bool_exp
  _or: [signatures_bool_exp!]
  inserted_at: timestamp_comparison_exp
  is_sender_primary: Boolean_comparison_exp
  multi_agent_index: bigint_comparison_exp
  multi_sig_index: bigint_comparison_exp
  public_key: String_comparison_exp
  public_key_indices: jsonb_comparison_exp
  signature: String_comparison_exp
  signer: String_comparison_exp
  threshold: bigint_comparison_exp
  transaction_block_height: bigint_comparison_exp
  transaction_version: bigint_comparison_exp
  type: String_comparison_exp
}

"""
unique or primary key constraints on table "signatures"
"""
enum signatures_constraint {
  """
  unique or primary key constraint on columns "transaction_version", "is_sender_primary", "multi_agent_index", "multi_sig_index"
  """
  signatures_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input signatures_delete_at_path_input {
  public_key_indices: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input signatures_delete_elem_input {
  public_key_indices: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input signatures_delete_key_input {
  public_key_indices: String
}

"""
input type for incrementing numeric columns in table "signatures"
"""
input signatures_inc_input {
  multi_agent_index: bigint
  multi_sig_index: bigint
  threshold: bigint
  transaction_block_height: bigint
  transaction_version: bigint
}

"""
input type for inserting data into table "signatures"
"""
input signatures_insert_input {
  inserted_at: timestamp
  is_sender_primary: Boolean
  multi_agent_index: bigint
  multi_sig_index: bigint
  public_key: String
  public_key_indices: jsonb
  signature: String
  signer: String
  threshold: bigint
  transaction_block_height: bigint
  transaction_version: bigint
  type: String
}

"""aggregate max on columns"""
type signatures_max_fields {
  inserted_at: timestamp
  multi_agent_index: bigint
  multi_sig_index: bigint
  public_key: String
  signature: String
  signer: String
  threshold: bigint
  transaction_block_height: bigint
  transaction_version: bigint
  type: String
}

"""aggregate min on columns"""
type signatures_min_fields {
  inserted_at: timestamp
  multi_agent_index: bigint
  multi_sig_index: bigint
  public_key: String
  signature: String
  signer: String
  threshold: bigint
  transaction_block_height: bigint
  transaction_version: bigint
  type: String
}

"""
response of any mutation on the table "signatures"
"""
type signatures_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [signatures!]!
}

"""
on_conflict condition type for table "signatures"
"""
input signatures_on_conflict {
  constraint: signatures_constraint!
  update_columns: [signatures_update_column!]! = []
  where: signatures_bool_exp
}

"""Ordering options when selecting data from "signatures"."""
input signatures_order_by {
  inserted_at: order_by
  is_sender_primary: order_by
  multi_agent_index: order_by
  multi_sig_index: order_by
  public_key: order_by
  public_key_indices: order_by
  signature: order_by
  signer: order_by
  threshold: order_by
  transaction_block_height: order_by
  transaction_version: order_by
  type: order_by
}

"""primary key columns input for table: signatures"""
input signatures_pk_columns_input {
  is_sender_primary: Boolean!
  multi_agent_index: bigint!
  multi_sig_index: bigint!
  transaction_version: bigint!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input signatures_prepend_input {
  public_key_indices: jsonb
}

"""
select columns of table "signatures"
"""
enum signatures_select_column {
  """column name"""
  inserted_at

  """column name"""
  is_sender_primary

  """column name"""
  multi_agent_index

  """column name"""
  multi_sig_index

  """column name"""
  public_key

  """column name"""
  public_key_indices

  """column name"""
  signature

  """column name"""
  signer

  """column name"""
  threshold

  """column name"""
  transaction_block_height

  """column name"""
  transaction_version

  """column name"""
  type
}

"""
input type for updating data in table "signatures"
"""
input signatures_set_input {
  inserted_at: timestamp
  is_sender_primary: Boolean
  multi_agent_index: bigint
  multi_sig_index: bigint
  public_key: String
  public_key_indices: jsonb
  signature: String
  signer: String
  threshold: bigint
  transaction_block_height: bigint
  transaction_version: bigint
  type: String
}

"""aggregate stddev on columns"""
type signatures_stddev_fields {
  multi_agent_index: Float
  multi_sig_index: Float
  threshold: Float
  transaction_block_height: Float
  transaction_version: Float
}

"""aggregate stddev_pop on columns"""
type signatures_stddev_pop_fields {
  multi_agent_index: Float
  multi_sig_index: Float
  threshold: Float
  transaction_block_height: Float
  transaction_version: Float
}

"""aggregate stddev_samp on columns"""
type signatures_stddev_samp_fields {
  multi_agent_index: Float
  multi_sig_index: Float
  threshold: Float
  transaction_block_height: Float
  transaction_version: Float
}

"""
Streaming cursor of the table "signatures"
"""
input signatures_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: signatures_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input signatures_stream_cursor_value_input {
  inserted_at: timestamp
  is_sender_primary: Boolean
  multi_agent_index: bigint
  multi_sig_index: bigint
  public_key: String
  public_key_indices: jsonb
  signature: String
  signer: String
  threshold: bigint
  transaction_block_height: bigint
  transaction_version: bigint
  type: String
}

"""aggregate sum on columns"""
type signatures_sum_fields {
  multi_agent_index: bigint
  multi_sig_index: bigint
  threshold: bigint
  transaction_block_height: bigint
  transaction_version: bigint
}

"""
update columns of table "signatures"
"""
enum signatures_update_column {
  """column name"""
  inserted_at

  """column name"""
  is_sender_primary

  """column name"""
  multi_agent_index

  """column name"""
  multi_sig_index

  """column name"""
  public_key

  """column name"""
  public_key_indices

  """column name"""
  signature

  """column name"""
  signer

  """column name"""
  threshold

  """column name"""
  transaction_block_height

  """column name"""
  transaction_version

  """column name"""
  type
}

input signatures_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: signatures_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: signatures_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: signatures_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: signatures_delete_key_input

  """increments the numeric columns with given value of the filtered values"""
  _inc: signatures_inc_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: signatures_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: signatures_set_input

  """filter the rows which have to be updated"""
  where: signatures_bool_exp!
}

"""aggregate var_pop on columns"""
type signatures_var_pop_fields {
  multi_agent_index: Float
  multi_sig_index: Float
  threshold: Float
  transaction_block_height: Float
  transaction_version: Float
}

"""aggregate var_samp on columns"""
type signatures_var_samp_fields {
  multi_agent_index: Float
  multi_sig_index: Float
  threshold: Float
  transaction_block_height: Float
  transaction_version: Float
}

"""aggregate variance on columns"""
type signatures_variance_fields {
  multi_agent_index: Float
  multi_sig_index: Float
  threshold: Float
  transaction_block_height: Float
  transaction_version: Float
}

type subscription_root {
  """
  fetch data from the table: "account_transactions"
  """
  account_transactions(
    """distinct select on columns"""
    distinct_on: [account_transactions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [account_transactions_order_by!]

    """filter the rows returned"""
    where: account_transactions_bool_exp
  ): [account_transactions!]!

  """
  fetch aggregated fields from the table: "account_transactions"
  """
  account_transactions_aggregate(
    """distinct select on columns"""
    distinct_on: [account_transactions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [account_transactions_order_by!]

    """filter the rows returned"""
    where: account_transactions_bool_exp
  ): account_transactions_aggregate!

  """
  fetch data from the table: "account_transactions" using primary key columns
  """
  account_transactions_by_pk(account_address: String!, transaction_version: bigint!): account_transactions

  """
  fetch data from the table in a streaming manner: "account_transactions"
  """
  account_transactions_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [account_transactions_stream_cursor_input]!

    """filter the rows returned"""
    where: account_transactions_bool_exp
  ): [account_transactions!]!

  """
  fetch data from the table: "address_events_summary"
  """
  address_events_summary(
    """distinct select on columns"""
    distinct_on: [address_events_summary_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [address_events_summary_order_by!]

    """filter the rows returned"""
    where: address_events_summary_bool_exp
  ): [address_events_summary!]!

  """
  fetch aggregated fields from the table: "address_events_summary"
  """
  address_events_summary_aggregate(
    """distinct select on columns"""
    distinct_on: [address_events_summary_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [address_events_summary_order_by!]

    """filter the rows returned"""
    where: address_events_summary_bool_exp
  ): address_events_summary_aggregate!

  """
  fetch data from the table in a streaming manner: "address_events_summary"
  """
  address_events_summary_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [address_events_summary_stream_cursor_input]!

    """filter the rows returned"""
    where: address_events_summary_bool_exp
  ): [address_events_summary!]!

  """
  fetch data from the table: "address_version_from_events"
  """
  address_version_from_events(
    """distinct select on columns"""
    distinct_on: [address_version_from_events_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [address_version_from_events_order_by!]

    """filter the rows returned"""
    where: address_version_from_events_bool_exp
  ): [address_version_from_events!]!

  """
  fetch aggregated fields from the table: "address_version_from_events"
  """
  address_version_from_events_aggregate(
    """distinct select on columns"""
    distinct_on: [address_version_from_events_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [address_version_from_events_order_by!]

    """filter the rows returned"""
    where: address_version_from_events_bool_exp
  ): address_version_from_events_aggregate!

  """
  fetch data from the table in a streaming manner: "address_version_from_events"
  """
  address_version_from_events_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [address_version_from_events_stream_cursor_input]!

    """filter the rows returned"""
    where: address_version_from_events_bool_exp
  ): [address_version_from_events!]!

  """
  fetch data from the table: "legacy_migration_v1.address_version_from_move_resources"
  """
  address_version_from_move_resources(
    """distinct select on columns"""
    distinct_on: [address_version_from_move_resources_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [address_version_from_move_resources_order_by!]

    """filter the rows returned"""
    where: address_version_from_move_resources_bool_exp
  ): [address_version_from_move_resources!]!

  """
  fetch aggregated fields from the table: "legacy_migration_v1.address_version_from_move_resources"
  """
  address_version_from_move_resources_aggregate(
    """distinct select on columns"""
    distinct_on: [address_version_from_move_resources_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [address_version_from_move_resources_order_by!]

    """filter the rows returned"""
    where: address_version_from_move_resources_bool_exp
  ): address_version_from_move_resources_aggregate!

  """
  fetch data from the table in a streaming manner: "legacy_migration_v1.address_version_from_move_resources"
  """
  address_version_from_move_resources_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [address_version_from_move_resources_stream_cursor_input]!

    """filter the rows returned"""
    where: address_version_from_move_resources_bool_exp
  ): [address_version_from_move_resources!]!

  """
  fetch data from the table: "block_metadata_transactions"
  """
  block_metadata_transactions(
    """distinct select on columns"""
    distinct_on: [block_metadata_transactions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [block_metadata_transactions_order_by!]

    """filter the rows returned"""
    where: block_metadata_transactions_bool_exp
  ): [block_metadata_transactions!]!

  """
  fetch aggregated fields from the table: "block_metadata_transactions"
  """
  block_metadata_transactions_aggregate(
    """distinct select on columns"""
    distinct_on: [block_metadata_transactions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [block_metadata_transactions_order_by!]

    """filter the rows returned"""
    where: block_metadata_transactions_bool_exp
  ): block_metadata_transactions_aggregate!

  """
  fetch data from the table: "block_metadata_transactions" using primary key columns
  """
  block_metadata_transactions_by_pk(version: bigint!): block_metadata_transactions

  """
  fetch data from the table in a streaming manner: "block_metadata_transactions"
  """
  block_metadata_transactions_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [block_metadata_transactions_stream_cursor_input]!

    """filter the rows returned"""
    where: block_metadata_transactions_bool_exp
  ): [block_metadata_transactions!]!

  """An array relationship"""
  coin_activities(
    """distinct select on columns"""
    distinct_on: [coin_activities_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [coin_activities_order_by!]

    """filter the rows returned"""
    where: coin_activities_bool_exp
  ): [coin_activities!]!

  """An aggregate relationship"""
  coin_activities_aggregate(
    """distinct select on columns"""
    distinct_on: [coin_activities_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [coin_activities_order_by!]

    """filter the rows returned"""
    where: coin_activities_bool_exp
  ): coin_activities_aggregate!

  """
  fetch data from the table in a streaming manner: "legacy_migration_v1.coin_activities"
  """
  coin_activities_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [coin_activities_stream_cursor_input]!

    """filter the rows returned"""
    where: coin_activities_bool_exp
  ): [coin_activities!]!

  """
  fetch data from the table: "legacy_migration_v1.coin_balances"
  """
  coin_balances(
    """distinct select on columns"""
    distinct_on: [coin_balances_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [coin_balances_order_by!]

    """filter the rows returned"""
    where: coin_balances_bool_exp
  ): [coin_balances!]!

  """
  fetch aggregated fields from the table: "legacy_migration_v1.coin_balances"
  """
  coin_balances_aggregate(
    """distinct select on columns"""
    distinct_on: [coin_balances_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [coin_balances_order_by!]

    """filter the rows returned"""
    where: coin_balances_bool_exp
  ): coin_balances_aggregate!

  """
  fetch data from the table in a streaming manner: "legacy_migration_v1.coin_balances"
  """
  coin_balances_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [coin_balances_stream_cursor_input]!

    """filter the rows returned"""
    where: coin_balances_bool_exp
  ): [coin_balances!]!

  """
  fetch data from the table: "legacy_migration_v1.coin_infos"
  """
  coin_infos(
    """distinct select on columns"""
    distinct_on: [coin_infos_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [coin_infos_order_by!]

    """filter the rows returned"""
    where: coin_infos_bool_exp
  ): [coin_infos!]!

  """
  fetch aggregated fields from the table: "legacy_migration_v1.coin_infos"
  """
  coin_infos_aggregate(
    """distinct select on columns"""
    distinct_on: [coin_infos_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [coin_infos_order_by!]

    """filter the rows returned"""
    where: coin_infos_bool_exp
  ): coin_infos_aggregate!

  """
  fetch data from the table in a streaming manner: "legacy_migration_v1.coin_infos"
  """
  coin_infos_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [coin_infos_stream_cursor_input]!

    """filter the rows returned"""
    where: coin_infos_bool_exp
  ): [coin_infos!]!

  """
  fetch data from the table: "coin_supply"
  """
  coin_supply(
    """distinct select on columns"""
    distinct_on: [coin_supply_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [coin_supply_order_by!]

    """filter the rows returned"""
    where: coin_supply_bool_exp
  ): [coin_supply!]!

  """
  fetch aggregated fields from the table: "coin_supply"
  """
  coin_supply_aggregate(
    """distinct select on columns"""
    distinct_on: [coin_supply_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [coin_supply_order_by!]

    """filter the rows returned"""
    where: coin_supply_bool_exp
  ): coin_supply_aggregate!

  """fetch data from the table: "coin_supply" using primary key columns"""
  coin_supply_by_pk(coin_type_hash: String!, transaction_version: bigint!): coin_supply

  """
  fetch data from the table in a streaming manner: "coin_supply"
  """
  coin_supply_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [coin_supply_stream_cursor_input]!

    """filter the rows returned"""
    where: coin_supply_bool_exp
  ): [coin_supply!]!

  """
  fetch data from the table: "legacy_migration_v1.collection_datas"
  """
  collection_datas(
    """distinct select on columns"""
    distinct_on: [collection_datas_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [collection_datas_order_by!]

    """filter the rows returned"""
    where: collection_datas_bool_exp
  ): [collection_datas!]!

  """
  fetch aggregated fields from the table: "legacy_migration_v1.collection_datas"
  """
  collection_datas_aggregate(
    """distinct select on columns"""
    distinct_on: [collection_datas_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [collection_datas_order_by!]

    """filter the rows returned"""
    where: collection_datas_bool_exp
  ): collection_datas_aggregate!

  """
  fetch data from the table in a streaming manner: "legacy_migration_v1.collection_datas"
  """
  collection_datas_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [collection_datas_stream_cursor_input]!

    """filter the rows returned"""
    where: collection_datas_bool_exp
  ): [collection_datas!]!

  """
  fetch data from the table: "legacy_migration_v1.current_ans_lookup"
  """
  current_ans_lookup(
    """distinct select on columns"""
    distinct_on: [current_ans_lookup_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_ans_lookup_order_by!]

    """filter the rows returned"""
    where: current_ans_lookup_bool_exp
  ): [current_ans_lookup!]!

  """
  fetch aggregated fields from the table: "legacy_migration_v1.current_ans_lookup"
  """
  current_ans_lookup_aggregate(
    """distinct select on columns"""
    distinct_on: [current_ans_lookup_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_ans_lookup_order_by!]

    """filter the rows returned"""
    where: current_ans_lookup_bool_exp
  ): current_ans_lookup_aggregate!

  """
  fetch data from the table in a streaming manner: "legacy_migration_v1.current_ans_lookup"
  """
  current_ans_lookup_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [current_ans_lookup_stream_cursor_input]!

    """filter the rows returned"""
    where: current_ans_lookup_bool_exp
  ): [current_ans_lookup!]!

  """
  fetch data from the table: "current_ans_lookup_v2"
  """
  current_ans_lookup_v2(
    """distinct select on columns"""
    distinct_on: [current_ans_lookup_v2_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_ans_lookup_v2_order_by!]

    """filter the rows returned"""
    where: current_ans_lookup_v2_bool_exp
  ): [current_ans_lookup_v2!]!

  """
  fetch aggregated fields from the table: "current_ans_lookup_v2"
  """
  current_ans_lookup_v2_aggregate(
    """distinct select on columns"""
    distinct_on: [current_ans_lookup_v2_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_ans_lookup_v2_order_by!]

    """filter the rows returned"""
    where: current_ans_lookup_v2_bool_exp
  ): current_ans_lookup_v2_aggregate!

  """
  fetch data from the table: "current_ans_lookup_v2" using primary key columns
  """
  current_ans_lookup_v2_by_pk(domain: String!, subdomain: String!, token_standard: String!): current_ans_lookup_v2

  """
  fetch data from the table in a streaming manner: "current_ans_lookup_v2"
  """
  current_ans_lookup_v2_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [current_ans_lookup_v2_stream_cursor_input]!

    """filter the rows returned"""
    where: current_ans_lookup_v2_bool_exp
  ): [current_ans_lookup_v2!]!

  """
  fetch data from the table: "current_aptos_names"
  """
  current_aptos_names(
    """distinct select on columns"""
    distinct_on: [current_aptos_names_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_aptos_names_order_by!]

    """filter the rows returned"""
    where: current_aptos_names_bool_exp
  ): [current_aptos_names!]!

  """
  fetch aggregated fields from the table: "current_aptos_names"
  """
  current_aptos_names_aggregate(
    """distinct select on columns"""
    distinct_on: [current_aptos_names_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_aptos_names_order_by!]

    """filter the rows returned"""
    where: current_aptos_names_bool_exp
  ): current_aptos_names_aggregate!

  """
  fetch data from the table in a streaming manner: "current_aptos_names"
  """
  current_aptos_names_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [current_aptos_names_stream_cursor_input]!

    """filter the rows returned"""
    where: current_aptos_names_bool_exp
  ): [current_aptos_names!]!

  """
  fetch data from the table: "legacy_migration_v1.current_coin_balances"
  """
  current_coin_balances(
    """distinct select on columns"""
    distinct_on: [current_coin_balances_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_coin_balances_order_by!]

    """filter the rows returned"""
    where: current_coin_balances_bool_exp
  ): [current_coin_balances!]!

  """
  fetch aggregated fields from the table: "legacy_migration_v1.current_coin_balances"
  """
  current_coin_balances_aggregate(
    """distinct select on columns"""
    distinct_on: [current_coin_balances_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_coin_balances_order_by!]

    """filter the rows returned"""
    where: current_coin_balances_bool_exp
  ): current_coin_balances_aggregate!

  """
  fetch data from the table in a streaming manner: "legacy_migration_v1.current_coin_balances"
  """
  current_coin_balances_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [current_coin_balances_stream_cursor_input]!

    """filter the rows returned"""
    where: current_coin_balances_bool_exp
  ): [current_coin_balances!]!

  """
  fetch data from the table: "legacy_migration_v1.current_collection_datas"
  """
  current_collection_datas(
    """distinct select on columns"""
    distinct_on: [current_collection_datas_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_collection_datas_order_by!]

    """filter the rows returned"""
    where: current_collection_datas_bool_exp
  ): [current_collection_datas!]!

  """
  fetch aggregated fields from the table: "legacy_migration_v1.current_collection_datas"
  """
  current_collection_datas_aggregate(
    """distinct select on columns"""
    distinct_on: [current_collection_datas_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_collection_datas_order_by!]

    """filter the rows returned"""
    where: current_collection_datas_bool_exp
  ): current_collection_datas_aggregate!

  """
  fetch data from the table in a streaming manner: "legacy_migration_v1.current_collection_datas"
  """
  current_collection_datas_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [current_collection_datas_stream_cursor_input]!

    """filter the rows returned"""
    where: current_collection_datas_bool_exp
  ): [current_collection_datas!]!

  """
  fetch data from the table: "current_collection_ownership_v2_view"
  """
  current_collection_ownership_v2_view(
    """distinct select on columns"""
    distinct_on: [current_collection_ownership_v2_view_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_collection_ownership_v2_view_order_by!]

    """filter the rows returned"""
    where: current_collection_ownership_v2_view_bool_exp
  ): [current_collection_ownership_v2_view!]!

  """
  fetch aggregated fields from the table: "current_collection_ownership_v2_view"
  """
  current_collection_ownership_v2_view_aggregate(
    """distinct select on columns"""
    distinct_on: [current_collection_ownership_v2_view_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_collection_ownership_v2_view_order_by!]

    """filter the rows returned"""
    where: current_collection_ownership_v2_view_bool_exp
  ): current_collection_ownership_v2_view_aggregate!

  """
  fetch data from the table in a streaming manner: "current_collection_ownership_v2_view"
  """
  current_collection_ownership_v2_view_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [current_collection_ownership_v2_view_stream_cursor_input]!

    """filter the rows returned"""
    where: current_collection_ownership_v2_view_bool_exp
  ): [current_collection_ownership_v2_view!]!

  """
  fetch data from the table: "current_collections_v2"
  """
  current_collections_v2(
    """distinct select on columns"""
    distinct_on: [current_collections_v2_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_collections_v2_order_by!]

    """filter the rows returned"""
    where: current_collections_v2_bool_exp
  ): [current_collections_v2!]!

  """
  fetch aggregated fields from the table: "current_collections_v2"
  """
  current_collections_v2_aggregate(
    """distinct select on columns"""
    distinct_on: [current_collections_v2_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_collections_v2_order_by!]

    """filter the rows returned"""
    where: current_collections_v2_bool_exp
  ): current_collections_v2_aggregate!

  """
  fetch data from the table: "current_collections_v2" using primary key columns
  """
  current_collections_v2_by_pk(collection_id: String!): current_collections_v2

  """
  fetch data from the table in a streaming manner: "current_collections_v2"
  """
  current_collections_v2_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [current_collections_v2_stream_cursor_input]!

    """filter the rows returned"""
    where: current_collections_v2_bool_exp
  ): [current_collections_v2!]!

  """
  fetch data from the table: "current_delegated_staking_pool_balances"
  """
  current_delegated_staking_pool_balances(
    """distinct select on columns"""
    distinct_on: [current_delegated_staking_pool_balances_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_delegated_staking_pool_balances_order_by!]

    """filter the rows returned"""
    where: current_delegated_staking_pool_balances_bool_exp
  ): [current_delegated_staking_pool_balances!]!

  """
  fetch aggregated fields from the table: "current_delegated_staking_pool_balances"
  """
  current_delegated_staking_pool_balances_aggregate(
    """distinct select on columns"""
    distinct_on: [current_delegated_staking_pool_balances_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_delegated_staking_pool_balances_order_by!]

    """filter the rows returned"""
    where: current_delegated_staking_pool_balances_bool_exp
  ): current_delegated_staking_pool_balances_aggregate!

  """
  fetch data from the table: "current_delegated_staking_pool_balances" using primary key columns
  """
  current_delegated_staking_pool_balances_by_pk(staking_pool_address: String!): current_delegated_staking_pool_balances

  """
  fetch data from the table in a streaming manner: "current_delegated_staking_pool_balances"
  """
  current_delegated_staking_pool_balances_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [current_delegated_staking_pool_balances_stream_cursor_input]!

    """filter the rows returned"""
    where: current_delegated_staking_pool_balances_bool_exp
  ): [current_delegated_staking_pool_balances!]!

  """
  fetch data from the table: "current_delegated_voter"
  """
  current_delegated_voter(
    """distinct select on columns"""
    distinct_on: [current_delegated_voter_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_delegated_voter_order_by!]

    """filter the rows returned"""
    where: current_delegated_voter_bool_exp
  ): [current_delegated_voter!]!

  """
  fetch aggregated fields from the table: "current_delegated_voter"
  """
  current_delegated_voter_aggregate(
    """distinct select on columns"""
    distinct_on: [current_delegated_voter_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_delegated_voter_order_by!]

    """filter the rows returned"""
    where: current_delegated_voter_bool_exp
  ): current_delegated_voter_aggregate!

  """
  fetch data from the table: "current_delegated_voter" using primary key columns
  """
  current_delegated_voter_by_pk(delegation_pool_address: String!, delegator_address: String!): current_delegated_voter

  """
  fetch data from the table in a streaming manner: "current_delegated_voter"
  """
  current_delegated_voter_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [current_delegated_voter_stream_cursor_input]!

    """filter the rows returned"""
    where: current_delegated_voter_bool_exp
  ): [current_delegated_voter!]!

  """
  fetch data from the table: "current_delegator_balances"
  """
  current_delegator_balances(
    """distinct select on columns"""
    distinct_on: [current_delegator_balances_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_delegator_balances_order_by!]

    """filter the rows returned"""
    where: current_delegator_balances_bool_exp
  ): [current_delegator_balances!]!

  """
  fetch aggregated fields from the table: "current_delegator_balances"
  """
  current_delegator_balances_aggregate(
    """distinct select on columns"""
    distinct_on: [current_delegator_balances_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_delegator_balances_order_by!]

    """filter the rows returned"""
    where: current_delegator_balances_bool_exp
  ): current_delegator_balances_aggregate!

  """
  fetch data from the table: "current_delegator_balances" using primary key columns
  """
  current_delegator_balances_by_pk(delegator_address: String!, pool_address: String!, pool_type: String!, table_handle: String!): current_delegator_balances

  """
  fetch data from the table in a streaming manner: "current_delegator_balances"
  """
  current_delegator_balances_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [current_delegator_balances_stream_cursor_input]!

    """filter the rows returned"""
    where: current_delegator_balances_bool_exp
  ): [current_delegator_balances!]!

  """
  fetch data from the table: "current_fungible_asset_balances"
  """
  current_fungible_asset_balances(
    """distinct select on columns"""
    distinct_on: [current_fungible_asset_balances_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_fungible_asset_balances_order_by!]

    """filter the rows returned"""
    where: current_fungible_asset_balances_bool_exp
  ): [current_fungible_asset_balances!]!

  """
  fetch aggregated fields from the table: "current_fungible_asset_balances"
  """
  current_fungible_asset_balances_aggregate(
    """distinct select on columns"""
    distinct_on: [current_fungible_asset_balances_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_fungible_asset_balances_order_by!]

    """filter the rows returned"""
    where: current_fungible_asset_balances_bool_exp
  ): current_fungible_asset_balances_aggregate!

  """
  fetch data from the table: "current_fungible_asset_balances" using primary key columns
  """
  current_fungible_asset_balances_by_pk(storage_id: String!): current_fungible_asset_balances

  """
  fetch data from the table in a streaming manner: "current_fungible_asset_balances"
  """
  current_fungible_asset_balances_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [current_fungible_asset_balances_stream_cursor_input]!

    """filter the rows returned"""
    where: current_fungible_asset_balances_bool_exp
  ): [current_fungible_asset_balances!]!

  """
  fetch data from the table: "current_objects"
  """
  current_objects(
    """distinct select on columns"""
    distinct_on: [current_objects_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_objects_order_by!]

    """filter the rows returned"""
    where: current_objects_bool_exp
  ): [current_objects!]!

  """
  fetch aggregated fields from the table: "current_objects"
  """
  current_objects_aggregate(
    """distinct select on columns"""
    distinct_on: [current_objects_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_objects_order_by!]

    """filter the rows returned"""
    where: current_objects_bool_exp
  ): current_objects_aggregate!

  """fetch data from the table: "current_objects" using primary key columns"""
  current_objects_by_pk(object_address: String!): current_objects

  """
  fetch data from the table in a streaming manner: "current_objects"
  """
  current_objects_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [current_objects_stream_cursor_input]!

    """filter the rows returned"""
    where: current_objects_bool_exp
  ): [current_objects!]!

  """
  fetch data from the table: "current_staking_pool_voter"
  """
  current_staking_pool_voter(
    """distinct select on columns"""
    distinct_on: [current_staking_pool_voter_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_staking_pool_voter_order_by!]

    """filter the rows returned"""
    where: current_staking_pool_voter_bool_exp
  ): [current_staking_pool_voter!]!

  """
  fetch aggregated fields from the table: "current_staking_pool_voter"
  """
  current_staking_pool_voter_aggregate(
    """distinct select on columns"""
    distinct_on: [current_staking_pool_voter_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_staking_pool_voter_order_by!]

    """filter the rows returned"""
    where: current_staking_pool_voter_bool_exp
  ): current_staking_pool_voter_aggregate!

  """
  fetch data from the table: "current_staking_pool_voter" using primary key columns
  """
  current_staking_pool_voter_by_pk(staking_pool_address: String!): current_staking_pool_voter

  """
  fetch data from the table in a streaming manner: "current_staking_pool_voter"
  """
  current_staking_pool_voter_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [current_staking_pool_voter_stream_cursor_input]!

    """filter the rows returned"""
    where: current_staking_pool_voter_bool_exp
  ): [current_staking_pool_voter!]!

  """
  fetch data from the table: "current_table_items"
  """
  current_table_items(
    """distinct select on columns"""
    distinct_on: [current_table_items_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_table_items_order_by!]

    """filter the rows returned"""
    where: current_table_items_bool_exp
  ): [current_table_items!]!

  """
  fetch aggregated fields from the table: "current_table_items"
  """
  current_table_items_aggregate(
    """distinct select on columns"""
    distinct_on: [current_table_items_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_table_items_order_by!]

    """filter the rows returned"""
    where: current_table_items_bool_exp
  ): current_table_items_aggregate!

  """
  fetch data from the table: "current_table_items" using primary key columns
  """
  current_table_items_by_pk(key_hash: String!, table_handle: String!): current_table_items

  """
  fetch data from the table in a streaming manner: "current_table_items"
  """
  current_table_items_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [current_table_items_stream_cursor_input]!

    """filter the rows returned"""
    where: current_table_items_bool_exp
  ): [current_table_items!]!

  """
  fetch data from the table: "legacy_migration_v1.current_token_datas"
  """
  current_token_datas(
    """distinct select on columns"""
    distinct_on: [current_token_datas_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_token_datas_order_by!]

    """filter the rows returned"""
    where: current_token_datas_bool_exp
  ): [current_token_datas!]!

  """
  fetch aggregated fields from the table: "legacy_migration_v1.current_token_datas"
  """
  current_token_datas_aggregate(
    """distinct select on columns"""
    distinct_on: [current_token_datas_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_token_datas_order_by!]

    """filter the rows returned"""
    where: current_token_datas_bool_exp
  ): current_token_datas_aggregate!

  """
  fetch data from the table in a streaming manner: "legacy_migration_v1.current_token_datas"
  """
  current_token_datas_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [current_token_datas_stream_cursor_input]!

    """filter the rows returned"""
    where: current_token_datas_bool_exp
  ): [current_token_datas!]!

  """
  fetch data from the table: "current_token_datas_v2"
  """
  current_token_datas_v2(
    """distinct select on columns"""
    distinct_on: [current_token_datas_v2_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_token_datas_v2_order_by!]

    """filter the rows returned"""
    where: current_token_datas_v2_bool_exp
  ): [current_token_datas_v2!]!

  """
  fetch aggregated fields from the table: "current_token_datas_v2"
  """
  current_token_datas_v2_aggregate(
    """distinct select on columns"""
    distinct_on: [current_token_datas_v2_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_token_datas_v2_order_by!]

    """filter the rows returned"""
    where: current_token_datas_v2_bool_exp
  ): current_token_datas_v2_aggregate!

  """
  fetch data from the table: "current_token_datas_v2" using primary key columns
  """
  current_token_datas_v2_by_pk(token_data_id: String!): current_token_datas_v2

  """
  fetch data from the table in a streaming manner: "current_token_datas_v2"
  """
  current_token_datas_v2_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [current_token_datas_v2_stream_cursor_input]!

    """filter the rows returned"""
    where: current_token_datas_v2_bool_exp
  ): [current_token_datas_v2!]!

  """
  fetch data from the table: "legacy_migration_v1.current_token_ownerships"
  """
  current_token_ownerships(
    """distinct select on columns"""
    distinct_on: [current_token_ownerships_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_token_ownerships_order_by!]

    """filter the rows returned"""
    where: current_token_ownerships_bool_exp
  ): [current_token_ownerships!]!

  """
  fetch aggregated fields from the table: "legacy_migration_v1.current_token_ownerships"
  """
  current_token_ownerships_aggregate(
    """distinct select on columns"""
    distinct_on: [current_token_ownerships_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_token_ownerships_order_by!]

    """filter the rows returned"""
    where: current_token_ownerships_bool_exp
  ): current_token_ownerships_aggregate!

  """
  fetch data from the table in a streaming manner: "legacy_migration_v1.current_token_ownerships"
  """
  current_token_ownerships_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [current_token_ownerships_stream_cursor_input]!

    """filter the rows returned"""
    where: current_token_ownerships_bool_exp
  ): [current_token_ownerships!]!

  """
  fetch data from the table: "current_token_ownerships_v2"
  """
  current_token_ownerships_v2(
    """distinct select on columns"""
    distinct_on: [current_token_ownerships_v2_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_token_ownerships_v2_order_by!]

    """filter the rows returned"""
    where: current_token_ownerships_v2_bool_exp
  ): [current_token_ownerships_v2!]!

  """
  fetch aggregated fields from the table: "current_token_ownerships_v2"
  """
  current_token_ownerships_v2_aggregate(
    """distinct select on columns"""
    distinct_on: [current_token_ownerships_v2_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_token_ownerships_v2_order_by!]

    """filter the rows returned"""
    where: current_token_ownerships_v2_bool_exp
  ): current_token_ownerships_v2_aggregate!

  """
  fetch data from the table: "current_token_ownerships_v2" using primary key columns
  """
  current_token_ownerships_v2_by_pk(owner_address: String!, property_version_v1: numeric!, storage_id: String!, token_data_id: String!): current_token_ownerships_v2

  """
  fetch data from the table in a streaming manner: "current_token_ownerships_v2"
  """
  current_token_ownerships_v2_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [current_token_ownerships_v2_stream_cursor_input]!

    """filter the rows returned"""
    where: current_token_ownerships_v2_bool_exp
  ): [current_token_ownerships_v2!]!

  """
  fetch data from the table: "current_token_pending_claims"
  """
  current_token_pending_claims(
    """distinct select on columns"""
    distinct_on: [current_token_pending_claims_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_token_pending_claims_order_by!]

    """filter the rows returned"""
    where: current_token_pending_claims_bool_exp
  ): [current_token_pending_claims!]!

  """
  fetch aggregated fields from the table: "current_token_pending_claims"
  """
  current_token_pending_claims_aggregate(
    """distinct select on columns"""
    distinct_on: [current_token_pending_claims_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_token_pending_claims_order_by!]

    """filter the rows returned"""
    where: current_token_pending_claims_bool_exp
  ): current_token_pending_claims_aggregate!

  """
  fetch data from the table: "current_token_pending_claims" using primary key columns
  """
  current_token_pending_claims_by_pk(from_address: String!, property_version: numeric!, to_address: String!, token_data_id_hash: String!): current_token_pending_claims

  """
  fetch data from the table in a streaming manner: "current_token_pending_claims"
  """
  current_token_pending_claims_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [current_token_pending_claims_stream_cursor_input]!

    """filter the rows returned"""
    where: current_token_pending_claims_bool_exp
  ): [current_token_pending_claims!]!

  """
  fetch data from the table: "current_token_royalty_v1"
  """
  current_token_royalty_v1(
    """distinct select on columns"""
    distinct_on: [current_token_royalty_v1_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_token_royalty_v1_order_by!]

    """filter the rows returned"""
    where: current_token_royalty_v1_bool_exp
  ): [current_token_royalty_v1!]!

  """
  fetch aggregated fields from the table: "current_token_royalty_v1"
  """
  current_token_royalty_v1_aggregate(
    """distinct select on columns"""
    distinct_on: [current_token_royalty_v1_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_token_royalty_v1_order_by!]

    """filter the rows returned"""
    where: current_token_royalty_v1_bool_exp
  ): current_token_royalty_v1_aggregate!

  """
  fetch data from the table: "current_token_royalty_v1" using primary key columns
  """
  current_token_royalty_v1_by_pk(token_data_id: String!): current_token_royalty_v1

  """
  fetch data from the table in a streaming manner: "current_token_royalty_v1"
  """
  current_token_royalty_v1_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [current_token_royalty_v1_stream_cursor_input]!

    """filter the rows returned"""
    where: current_token_royalty_v1_bool_exp
  ): [current_token_royalty_v1!]!

  """An array relationship"""
  delegated_staking_activities(
    """distinct select on columns"""
    distinct_on: [delegated_staking_activities_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delegated_staking_activities_order_by!]

    """filter the rows returned"""
    where: delegated_staking_activities_bool_exp
  ): [delegated_staking_activities!]!

  """An aggregate relationship"""
  delegated_staking_activities_aggregate(
    """distinct select on columns"""
    distinct_on: [delegated_staking_activities_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delegated_staking_activities_order_by!]

    """filter the rows returned"""
    where: delegated_staking_activities_bool_exp
  ): delegated_staking_activities_aggregate!

  """
  fetch data from the table: "delegated_staking_activities" using primary key columns
  """
  delegated_staking_activities_by_pk(event_index: bigint!, transaction_version: bigint!): delegated_staking_activities

  """
  fetch data from the table in a streaming manner: "delegated_staking_activities"
  """
  delegated_staking_activities_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [delegated_staking_activities_stream_cursor_input]!

    """filter the rows returned"""
    where: delegated_staking_activities_bool_exp
  ): [delegated_staking_activities!]!

  """
  fetch data from the table: "delegated_staking_pool_balances"
  """
  delegated_staking_pool_balances(
    """distinct select on columns"""
    distinct_on: [delegated_staking_pool_balances_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delegated_staking_pool_balances_order_by!]

    """filter the rows returned"""
    where: delegated_staking_pool_balances_bool_exp
  ): [delegated_staking_pool_balances!]!

  """
  fetch aggregated fields from the table: "delegated_staking_pool_balances"
  """
  delegated_staking_pool_balances_aggregate(
    """distinct select on columns"""
    distinct_on: [delegated_staking_pool_balances_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delegated_staking_pool_balances_order_by!]

    """filter the rows returned"""
    where: delegated_staking_pool_balances_bool_exp
  ): delegated_staking_pool_balances_aggregate!

  """
  fetch data from the table: "delegated_staking_pool_balances" using primary key columns
  """
  delegated_staking_pool_balances_by_pk(staking_pool_address: String!, transaction_version: bigint!): delegated_staking_pool_balances

  """
  fetch data from the table in a streaming manner: "delegated_staking_pool_balances"
  """
  delegated_staking_pool_balances_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [delegated_staking_pool_balances_stream_cursor_input]!

    """filter the rows returned"""
    where: delegated_staking_pool_balances_bool_exp
  ): [delegated_staking_pool_balances!]!

  """
  fetch data from the table: "delegated_staking_pools"
  """
  delegated_staking_pools(
    """distinct select on columns"""
    distinct_on: [delegated_staking_pools_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delegated_staking_pools_order_by!]

    """filter the rows returned"""
    where: delegated_staking_pools_bool_exp
  ): [delegated_staking_pools!]!

  """
  fetch aggregated fields from the table: "delegated_staking_pools"
  """
  delegated_staking_pools_aggregate(
    """distinct select on columns"""
    distinct_on: [delegated_staking_pools_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delegated_staking_pools_order_by!]

    """filter the rows returned"""
    where: delegated_staking_pools_bool_exp
  ): delegated_staking_pools_aggregate!

  """
  fetch data from the table: "delegated_staking_pools" using primary key columns
  """
  delegated_staking_pools_by_pk(staking_pool_address: String!): delegated_staking_pools

  """
  fetch data from the table in a streaming manner: "delegated_staking_pools"
  """
  delegated_staking_pools_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [delegated_staking_pools_stream_cursor_input]!

    """filter the rows returned"""
    where: delegated_staking_pools_bool_exp
  ): [delegated_staking_pools!]!

  """
  fetch data from the table: "delegator_distinct_pool"
  """
  delegator_distinct_pool(
    """distinct select on columns"""
    distinct_on: [delegator_distinct_pool_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delegator_distinct_pool_order_by!]

    """filter the rows returned"""
    where: delegator_distinct_pool_bool_exp
  ): [delegator_distinct_pool!]!

  """
  fetch aggregated fields from the table: "delegator_distinct_pool"
  """
  delegator_distinct_pool_aggregate(
    """distinct select on columns"""
    distinct_on: [delegator_distinct_pool_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delegator_distinct_pool_order_by!]

    """filter the rows returned"""
    where: delegator_distinct_pool_bool_exp
  ): delegator_distinct_pool_aggregate!

  """
  fetch data from the table in a streaming manner: "delegator_distinct_pool"
  """
  delegator_distinct_pool_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [delegator_distinct_pool_stream_cursor_input]!

    """filter the rows returned"""
    where: delegator_distinct_pool_bool_exp
  ): [delegator_distinct_pool!]!

  """
  fetch data from the table: "events"
  """
  events(
    """distinct select on columns"""
    distinct_on: [events_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [events_order_by!]

    """filter the rows returned"""
    where: events_bool_exp
  ): [events!]!

  """
  fetch aggregated fields from the table: "events"
  """
  events_aggregate(
    """distinct select on columns"""
    distinct_on: [events_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [events_order_by!]

    """filter the rows returned"""
    where: events_bool_exp
  ): events_aggregate!

  """fetch data from the table: "events" using primary key columns"""
  events_by_pk(event_index: bigint!, transaction_version: bigint!): events

  """
  fetch data from the table in a streaming manner: "events"
  """
  events_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [events_stream_cursor_input]!

    """filter the rows returned"""
    where: events_bool_exp
  ): [events!]!

  """An array relationship"""
  fungible_asset_activities(
    """distinct select on columns"""
    distinct_on: [fungible_asset_activities_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [fungible_asset_activities_order_by!]

    """filter the rows returned"""
    where: fungible_asset_activities_bool_exp
  ): [fungible_asset_activities!]!

  """An aggregate relationship"""
  fungible_asset_activities_aggregate(
    """distinct select on columns"""
    distinct_on: [fungible_asset_activities_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [fungible_asset_activities_order_by!]

    """filter the rows returned"""
    where: fungible_asset_activities_bool_exp
  ): fungible_asset_activities_aggregate!

  """
  fetch data from the table: "fungible_asset_activities" using primary key columns
  """
  fungible_asset_activities_by_pk(event_index: bigint!, transaction_version: bigint!): fungible_asset_activities

  """
  fetch data from the table in a streaming manner: "fungible_asset_activities"
  """
  fungible_asset_activities_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [fungible_asset_activities_stream_cursor_input]!

    """filter the rows returned"""
    where: fungible_asset_activities_bool_exp
  ): [fungible_asset_activities!]!

  """
  fetch data from the table: "fungible_asset_metadata"
  """
  fungible_asset_metadata(
    """distinct select on columns"""
    distinct_on: [fungible_asset_metadata_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [fungible_asset_metadata_order_by!]

    """filter the rows returned"""
    where: fungible_asset_metadata_bool_exp
  ): [fungible_asset_metadata!]!

  """
  fetch aggregated fields from the table: "fungible_asset_metadata"
  """
  fungible_asset_metadata_aggregate(
    """distinct select on columns"""
    distinct_on: [fungible_asset_metadata_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [fungible_asset_metadata_order_by!]

    """filter the rows returned"""
    where: fungible_asset_metadata_bool_exp
  ): fungible_asset_metadata_aggregate!

  """
  fetch data from the table: "fungible_asset_metadata" using primary key columns
  """
  fungible_asset_metadata_by_pk(asset_type: String!): fungible_asset_metadata

  """
  fetch data from the table in a streaming manner: "fungible_asset_metadata"
  """
  fungible_asset_metadata_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [fungible_asset_metadata_stream_cursor_input]!

    """filter the rows returned"""
    where: fungible_asset_metadata_bool_exp
  ): [fungible_asset_metadata!]!

  """
  fetch data from the table: "indexer_status"
  """
  indexer_status(
    """distinct select on columns"""
    distinct_on: [indexer_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [indexer_status_order_by!]

    """filter the rows returned"""
    where: indexer_status_bool_exp
  ): [indexer_status!]!

  """
  fetch aggregated fields from the table: "indexer_status"
  """
  indexer_status_aggregate(
    """distinct select on columns"""
    distinct_on: [indexer_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [indexer_status_order_by!]

    """filter the rows returned"""
    where: indexer_status_bool_exp
  ): indexer_status_aggregate!

  """fetch data from the table: "indexer_status" using primary key columns"""
  indexer_status_by_pk(db: String!): indexer_status

  """
  fetch data from the table in a streaming manner: "indexer_status"
  """
  indexer_status_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [indexer_status_stream_cursor_input]!

    """filter the rows returned"""
    where: indexer_status_bool_exp
  ): [indexer_status!]!

  """
  fetch data from the table: "ledger_infos"
  """
  ledger_infos(
    """distinct select on columns"""
    distinct_on: [ledger_infos_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ledger_infos_order_by!]

    """filter the rows returned"""
    where: ledger_infos_bool_exp
  ): [ledger_infos!]!

  """
  fetch aggregated fields from the table: "ledger_infos"
  """
  ledger_infos_aggregate(
    """distinct select on columns"""
    distinct_on: [ledger_infos_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ledger_infos_order_by!]

    """filter the rows returned"""
    where: ledger_infos_bool_exp
  ): ledger_infos_aggregate!

  """fetch data from the table: "ledger_infos" using primary key columns"""
  ledger_infos_by_pk(chain_id: bigint!): ledger_infos

  """
  fetch data from the table in a streaming manner: "ledger_infos"
  """
  ledger_infos_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [ledger_infos_stream_cursor_input]!

    """filter the rows returned"""
    where: ledger_infos_bool_exp
  ): [ledger_infos!]!

  """
  fetch data from the table: "legacy_migration_v1.move_resources"
  """
  move_resources(
    """distinct select on columns"""
    distinct_on: [move_resources_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [move_resources_order_by!]

    """filter the rows returned"""
    where: move_resources_bool_exp
  ): [move_resources!]!

  """
  fetch aggregated fields from the table: "legacy_migration_v1.move_resources"
  """
  move_resources_aggregate(
    """distinct select on columns"""
    distinct_on: [move_resources_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [move_resources_order_by!]

    """filter the rows returned"""
    where: move_resources_bool_exp
  ): move_resources_aggregate!

  """
  fetch data from the table in a streaming manner: "legacy_migration_v1.move_resources"
  """
  move_resources_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [move_resources_stream_cursor_input]!

    """filter the rows returned"""
    where: move_resources_bool_exp
  ): [move_resources!]!

  """
  fetch data from the table: "nft_metadata_crawler.parsed_asset_uris"
  """
  nft_metadata_crawler_parsed_asset_uris(
    """distinct select on columns"""
    distinct_on: [nft_metadata_crawler_parsed_asset_uris_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [nft_metadata_crawler_parsed_asset_uris_order_by!]

    """filter the rows returned"""
    where: nft_metadata_crawler_parsed_asset_uris_bool_exp
  ): [nft_metadata_crawler_parsed_asset_uris!]!

  """
  fetch aggregated fields from the table: "nft_metadata_crawler.parsed_asset_uris"
  """
  nft_metadata_crawler_parsed_asset_uris_aggregate(
    """distinct select on columns"""
    distinct_on: [nft_metadata_crawler_parsed_asset_uris_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [nft_metadata_crawler_parsed_asset_uris_order_by!]

    """filter the rows returned"""
    where: nft_metadata_crawler_parsed_asset_uris_bool_exp
  ): nft_metadata_crawler_parsed_asset_uris_aggregate!

  """
  fetch data from the table: "nft_metadata_crawler.parsed_asset_uris" using primary key columns
  """
  nft_metadata_crawler_parsed_asset_uris_by_pk(asset_uri: String!): nft_metadata_crawler_parsed_asset_uris

  """
  fetch data from the table in a streaming manner: "nft_metadata_crawler.parsed_asset_uris"
  """
  nft_metadata_crawler_parsed_asset_uris_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [nft_metadata_crawler_parsed_asset_uris_stream_cursor_input]!

    """filter the rows returned"""
    where: nft_metadata_crawler_parsed_asset_uris_bool_exp
  ): [nft_metadata_crawler_parsed_asset_uris!]!

  """
  fetch data from the table: "num_active_delegator_per_pool"
  """
  num_active_delegator_per_pool(
    """distinct select on columns"""
    distinct_on: [num_active_delegator_per_pool_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [num_active_delegator_per_pool_order_by!]

    """filter the rows returned"""
    where: num_active_delegator_per_pool_bool_exp
  ): [num_active_delegator_per_pool!]!

  """
  fetch aggregated fields from the table: "num_active_delegator_per_pool"
  """
  num_active_delegator_per_pool_aggregate(
    """distinct select on columns"""
    distinct_on: [num_active_delegator_per_pool_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [num_active_delegator_per_pool_order_by!]

    """filter the rows returned"""
    where: num_active_delegator_per_pool_bool_exp
  ): num_active_delegator_per_pool_aggregate!

  """
  fetch data from the table in a streaming manner: "num_active_delegator_per_pool"
  """
  num_active_delegator_per_pool_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [num_active_delegator_per_pool_stream_cursor_input]!

    """filter the rows returned"""
    where: num_active_delegator_per_pool_bool_exp
  ): [num_active_delegator_per_pool!]!

  """
  fetch data from the table: "processor_status"
  """
  processor_status(
    """distinct select on columns"""
    distinct_on: [processor_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [processor_status_order_by!]

    """filter the rows returned"""
    where: processor_status_bool_exp
  ): [processor_status!]!

  """
  fetch aggregated fields from the table: "processor_status"
  """
  processor_status_aggregate(
    """distinct select on columns"""
    distinct_on: [processor_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [processor_status_order_by!]

    """filter the rows returned"""
    where: processor_status_bool_exp
  ): processor_status_aggregate!

  """
  fetch data from the table: "processor_status" using primary key columns
  """
  processor_status_by_pk(processor: String!): processor_status

  """
  fetch data from the table in a streaming manner: "processor_status"
  """
  processor_status_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [processor_status_stream_cursor_input]!

    """filter the rows returned"""
    where: processor_status_bool_exp
  ): [processor_status!]!

  """
  fetch data from the table: "proposal_votes"
  """
  proposal_votes(
    """distinct select on columns"""
    distinct_on: [proposal_votes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [proposal_votes_order_by!]

    """filter the rows returned"""
    where: proposal_votes_bool_exp
  ): [proposal_votes!]!

  """
  fetch aggregated fields from the table: "proposal_votes"
  """
  proposal_votes_aggregate(
    """distinct select on columns"""
    distinct_on: [proposal_votes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [proposal_votes_order_by!]

    """filter the rows returned"""
    where: proposal_votes_bool_exp
  ): proposal_votes_aggregate!

  """fetch data from the table: "proposal_votes" using primary key columns"""
  proposal_votes_by_pk(proposal_id: bigint!, transaction_version: bigint!, voter_address: String!): proposal_votes

  """
  fetch data from the table in a streaming manner: "proposal_votes"
  """
  proposal_votes_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [proposal_votes_stream_cursor_input]!

    """filter the rows returned"""
    where: proposal_votes_bool_exp
  ): [proposal_votes!]!

  """
  fetch data from the table: "signatures"
  """
  signatures(
    """distinct select on columns"""
    distinct_on: [signatures_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [signatures_order_by!]

    """filter the rows returned"""
    where: signatures_bool_exp
  ): [signatures!]!

  """
  fetch aggregated fields from the table: "signatures"
  """
  signatures_aggregate(
    """distinct select on columns"""
    distinct_on: [signatures_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [signatures_order_by!]

    """filter the rows returned"""
    where: signatures_bool_exp
  ): signatures_aggregate!

  """fetch data from the table: "signatures" using primary key columns"""
  signatures_by_pk(is_sender_primary: Boolean!, multi_agent_index: bigint!, multi_sig_index: bigint!, transaction_version: bigint!): signatures

  """
  fetch data from the table in a streaming manner: "signatures"
  """
  signatures_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [signatures_stream_cursor_input]!

    """filter the rows returned"""
    where: signatures_bool_exp
  ): [signatures!]!

  """
  fetch data from the table: "table_items"
  """
  table_items(
    """distinct select on columns"""
    distinct_on: [table_items_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [table_items_order_by!]

    """filter the rows returned"""
    where: table_items_bool_exp
  ): [table_items!]!

  """
  fetch aggregated fields from the table: "table_items"
  """
  table_items_aggregate(
    """distinct select on columns"""
    distinct_on: [table_items_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [table_items_order_by!]

    """filter the rows returned"""
    where: table_items_bool_exp
  ): table_items_aggregate!

  """fetch data from the table: "table_items" using primary key columns"""
  table_items_by_pk(transaction_version: bigint!, write_set_change_index: bigint!): table_items

  """
  fetch data from the table in a streaming manner: "table_items"
  """
  table_items_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [table_items_stream_cursor_input]!

    """filter the rows returned"""
    where: table_items_bool_exp
  ): [table_items!]!

  """
  fetch data from the table: "table_metadatas"
  """
  table_metadatas(
    """distinct select on columns"""
    distinct_on: [table_metadatas_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [table_metadatas_order_by!]

    """filter the rows returned"""
    where: table_metadatas_bool_exp
  ): [table_metadatas!]!

  """
  fetch aggregated fields from the table: "table_metadatas"
  """
  table_metadatas_aggregate(
    """distinct select on columns"""
    distinct_on: [table_metadatas_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [table_metadatas_order_by!]

    """filter the rows returned"""
    where: table_metadatas_bool_exp
  ): table_metadatas_aggregate!

  """fetch data from the table: "table_metadatas" using primary key columns"""
  table_metadatas_by_pk(handle: String!): table_metadatas

  """
  fetch data from the table in a streaming manner: "table_metadatas"
  """
  table_metadatas_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [table_metadatas_stream_cursor_input]!

    """filter the rows returned"""
    where: table_metadatas_bool_exp
  ): [table_metadatas!]!

  """An array relationship"""
  token_activities(
    """distinct select on columns"""
    distinct_on: [token_activities_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_activities_order_by!]

    """filter the rows returned"""
    where: token_activities_bool_exp
  ): [token_activities!]!

  """An aggregate relationship"""
  token_activities_aggregate(
    """distinct select on columns"""
    distinct_on: [token_activities_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_activities_order_by!]

    """filter the rows returned"""
    where: token_activities_bool_exp
  ): token_activities_aggregate!

  """
  fetch data from the table in a streaming manner: "legacy_migration_v1.token_activities"
  """
  token_activities_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [token_activities_stream_cursor_input]!

    """filter the rows returned"""
    where: token_activities_bool_exp
  ): [token_activities!]!

  """An array relationship"""
  token_activities_v2(
    """distinct select on columns"""
    distinct_on: [token_activities_v2_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_activities_v2_order_by!]

    """filter the rows returned"""
    where: token_activities_v2_bool_exp
  ): [token_activities_v2!]!

  """An aggregate relationship"""
  token_activities_v2_aggregate(
    """distinct select on columns"""
    distinct_on: [token_activities_v2_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_activities_v2_order_by!]

    """filter the rows returned"""
    where: token_activities_v2_bool_exp
  ): token_activities_v2_aggregate!

  """
  fetch data from the table: "token_activities_v2" using primary key columns
  """
  token_activities_v2_by_pk(event_index: bigint!, transaction_version: bigint!): token_activities_v2

  """
  fetch data from the table in a streaming manner: "token_activities_v2"
  """
  token_activities_v2_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [token_activities_v2_stream_cursor_input]!

    """filter the rows returned"""
    where: token_activities_v2_bool_exp
  ): [token_activities_v2!]!

  """
  fetch data from the table: "legacy_migration_v1.token_datas"
  """
  token_datas(
    """distinct select on columns"""
    distinct_on: [token_datas_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_datas_order_by!]

    """filter the rows returned"""
    where: token_datas_bool_exp
  ): [token_datas!]!

  """
  fetch aggregated fields from the table: "legacy_migration_v1.token_datas"
  """
  token_datas_aggregate(
    """distinct select on columns"""
    distinct_on: [token_datas_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_datas_order_by!]

    """filter the rows returned"""
    where: token_datas_bool_exp
  ): token_datas_aggregate!

  """
  fetch data from the table in a streaming manner: "legacy_migration_v1.token_datas"
  """
  token_datas_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [token_datas_stream_cursor_input]!

    """filter the rows returned"""
    where: token_datas_bool_exp
  ): [token_datas!]!

  """
  fetch data from the table: "legacy_migration_v1.token_ownerships"
  """
  token_ownerships(
    """distinct select on columns"""
    distinct_on: [token_ownerships_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_ownerships_order_by!]

    """filter the rows returned"""
    where: token_ownerships_bool_exp
  ): [token_ownerships!]!

  """
  fetch aggregated fields from the table: "legacy_migration_v1.token_ownerships"
  """
  token_ownerships_aggregate(
    """distinct select on columns"""
    distinct_on: [token_ownerships_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [token_ownerships_order_by!]

    """filter the rows returned"""
    where: token_ownerships_bool_exp
  ): token_ownerships_aggregate!

  """
  fetch data from the table in a streaming manner: "legacy_migration_v1.token_ownerships"
  """
  token_ownerships_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [token_ownerships_stream_cursor_input]!

    """filter the rows returned"""
    where: token_ownerships_bool_exp
  ): [token_ownerships!]!

  """
  fetch data from the table: "legacy_migration_v1.tokens"
  """
  tokens(
    """distinct select on columns"""
    distinct_on: [tokens_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tokens_order_by!]

    """filter the rows returned"""
    where: tokens_bool_exp
  ): [tokens!]!

  """
  fetch aggregated fields from the table: "legacy_migration_v1.tokens"
  """
  tokens_aggregate(
    """distinct select on columns"""
    distinct_on: [tokens_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tokens_order_by!]

    """filter the rows returned"""
    where: tokens_bool_exp
  ): tokens_aggregate!

  """
  fetch data from the table in a streaming manner: "legacy_migration_v1.tokens"
  """
  tokens_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [tokens_stream_cursor_input]!

    """filter the rows returned"""
    where: tokens_bool_exp
  ): [tokens!]!

  """
  fetch data from the table: "user_transactions"
  """
  user_transactions(
    """distinct select on columns"""
    distinct_on: [user_transactions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_transactions_order_by!]

    """filter the rows returned"""
    where: user_transactions_bool_exp
  ): [user_transactions!]!

  """
  fetch aggregated fields from the table: "user_transactions"
  """
  user_transactions_aggregate(
    """distinct select on columns"""
    distinct_on: [user_transactions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_transactions_order_by!]

    """filter the rows returned"""
    where: user_transactions_bool_exp
  ): user_transactions_aggregate!

  """
  fetch data from the table: "user_transactions" using primary key columns
  """
  user_transactions_by_pk(version: bigint!): user_transactions

  """
  fetch data from the table in a streaming manner: "user_transactions"
  """
  user_transactions_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [user_transactions_stream_cursor_input]!

    """filter the rows returned"""
    where: user_transactions_bool_exp
  ): [user_transactions!]!
}

"""
columns and relationships of "table_items"
"""
type table_items {
  decoded_key(
    """JSON select path"""
    path: String
  ): jsonb!
  decoded_value(
    """JSON select path"""
    path: String
  ): jsonb
  inserted_at: timestamp!
  is_deleted: Boolean!
  key: String!
  table_handle: String!
  transaction_block_height: bigint!
  transaction_version: bigint!
  write_set_change_index: bigint!
}

"""
aggregated selection of "table_items"
"""
type table_items_aggregate {
  aggregate: table_items_aggregate_fields
  nodes: [table_items!]!
}

"""
aggregate fields of "table_items"
"""
type table_items_aggregate_fields {
  avg: table_items_avg_fields
  count(columns: [table_items_select_column!], distinct: Boolean): Int!
  max: table_items_max_fields
  min: table_items_min_fields
  stddev: table_items_stddev_fields
  stddev_pop: table_items_stddev_pop_fields
  stddev_samp: table_items_stddev_samp_fields
  sum: table_items_sum_fields
  var_pop: table_items_var_pop_fields
  var_samp: table_items_var_samp_fields
  variance: table_items_variance_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input table_items_append_input {
  decoded_key: jsonb
  decoded_value: jsonb
}

"""aggregate avg on columns"""
type table_items_avg_fields {
  transaction_block_height: Float
  transaction_version: Float
  write_set_change_index: Float
}

"""
Boolean expression to filter rows from the table "table_items". All fields are combined with a logical 'AND'.
"""
input table_items_bool_exp {
  _and: [table_items_bool_exp!]
  _not: table_items_bool_exp
  _or: [table_items_bool_exp!]
  decoded_key: jsonb_comparison_exp
  decoded_value: jsonb_comparison_exp
  inserted_at: timestamp_comparison_exp
  is_deleted: Boolean_comparison_exp
  key: String_comparison_exp
  table_handle: String_comparison_exp
  transaction_block_height: bigint_comparison_exp
  transaction_version: bigint_comparison_exp
  write_set_change_index: bigint_comparison_exp
}

"""
unique or primary key constraints on table "table_items"
"""
enum table_items_constraint {
  """
  unique or primary key constraint on columns "transaction_version", "write_set_change_index"
  """
  table_items_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input table_items_delete_at_path_input {
  decoded_key: [String!]
  decoded_value: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input table_items_delete_elem_input {
  decoded_key: Int
  decoded_value: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input table_items_delete_key_input {
  decoded_key: String
  decoded_value: String
}

"""
input type for incrementing numeric columns in table "table_items"
"""
input table_items_inc_input {
  transaction_block_height: bigint
  transaction_version: bigint
  write_set_change_index: bigint
}

"""
input type for inserting data into table "table_items"
"""
input table_items_insert_input {
  decoded_key: jsonb
  decoded_value: jsonb
  inserted_at: timestamp
  is_deleted: Boolean
  key: String
  table_handle: String
  transaction_block_height: bigint
  transaction_version: bigint
  write_set_change_index: bigint
}

"""aggregate max on columns"""
type table_items_max_fields {
  inserted_at: timestamp
  key: String
  table_handle: String
  transaction_block_height: bigint
  transaction_version: bigint
  write_set_change_index: bigint
}

"""aggregate min on columns"""
type table_items_min_fields {
  inserted_at: timestamp
  key: String
  table_handle: String
  transaction_block_height: bigint
  transaction_version: bigint
  write_set_change_index: bigint
}

"""
response of any mutation on the table "table_items"
"""
type table_items_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [table_items!]!
}

"""
on_conflict condition type for table "table_items"
"""
input table_items_on_conflict {
  constraint: table_items_constraint!
  update_columns: [table_items_update_column!]! = []
  where: table_items_bool_exp
}

"""Ordering options when selecting data from "table_items"."""
input table_items_order_by {
  decoded_key: order_by
  decoded_value: order_by
  inserted_at: order_by
  is_deleted: order_by
  key: order_by
  table_handle: order_by
  transaction_block_height: order_by
  transaction_version: order_by
  write_set_change_index: order_by
}

"""primary key columns input for table: table_items"""
input table_items_pk_columns_input {
  transaction_version: bigint!
  write_set_change_index: bigint!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input table_items_prepend_input {
  decoded_key: jsonb
  decoded_value: jsonb
}

"""
select columns of table "table_items"
"""
enum table_items_select_column {
  """column name"""
  decoded_key

  """column name"""
  decoded_value

  """column name"""
  inserted_at

  """column name"""
  is_deleted

  """column name"""
  key

  """column name"""
  table_handle

  """column name"""
  transaction_block_height

  """column name"""
  transaction_version

  """column name"""
  write_set_change_index
}

"""
input type for updating data in table "table_items"
"""
input table_items_set_input {
  decoded_key: jsonb
  decoded_value: jsonb
  inserted_at: timestamp
  is_deleted: Boolean
  key: String
  table_handle: String
  transaction_block_height: bigint
  transaction_version: bigint
  write_set_change_index: bigint
}

"""aggregate stddev on columns"""
type table_items_stddev_fields {
  transaction_block_height: Float
  transaction_version: Float
  write_set_change_index: Float
}

"""aggregate stddev_pop on columns"""
type table_items_stddev_pop_fields {
  transaction_block_height: Float
  transaction_version: Float
  write_set_change_index: Float
}

"""aggregate stddev_samp on columns"""
type table_items_stddev_samp_fields {
  transaction_block_height: Float
  transaction_version: Float
  write_set_change_index: Float
}

"""
Streaming cursor of the table "table_items"
"""
input table_items_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: table_items_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input table_items_stream_cursor_value_input {
  decoded_key: jsonb
  decoded_value: jsonb
  inserted_at: timestamp
  is_deleted: Boolean
  key: String
  table_handle: String
  transaction_block_height: bigint
  transaction_version: bigint
  write_set_change_index: bigint
}

"""aggregate sum on columns"""
type table_items_sum_fields {
  transaction_block_height: bigint
  transaction_version: bigint
  write_set_change_index: bigint
}

"""
update columns of table "table_items"
"""
enum table_items_update_column {
  """column name"""
  decoded_key

  """column name"""
  decoded_value

  """column name"""
  inserted_at

  """column name"""
  is_deleted

  """column name"""
  key

  """column name"""
  table_handle

  """column name"""
  transaction_block_height

  """column name"""
  transaction_version

  """column name"""
  write_set_change_index
}

input table_items_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: table_items_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: table_items_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: table_items_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: table_items_delete_key_input

  """increments the numeric columns with given value of the filtered values"""
  _inc: table_items_inc_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: table_items_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: table_items_set_input

  """filter the rows which have to be updated"""
  where: table_items_bool_exp!
}

"""aggregate var_pop on columns"""
type table_items_var_pop_fields {
  transaction_block_height: Float
  transaction_version: Float
  write_set_change_index: Float
}

"""aggregate var_samp on columns"""
type table_items_var_samp_fields {
  transaction_block_height: Float
  transaction_version: Float
  write_set_change_index: Float
}

"""aggregate variance on columns"""
type table_items_variance_fields {
  transaction_block_height: Float
  transaction_version: Float
  write_set_change_index: Float
}

"""
columns and relationships of "table_metadatas"
"""
type table_metadatas {
  handle: String!
  inserted_at: timestamp!
  key_type: String!
  value_type: String!
}

"""
aggregated selection of "table_metadatas"
"""
type table_metadatas_aggregate {
  aggregate: table_metadatas_aggregate_fields
  nodes: [table_metadatas!]!
}

"""
aggregate fields of "table_metadatas"
"""
type table_metadatas_aggregate_fields {
  count(columns: [table_metadatas_select_column!], distinct: Boolean): Int!
  max: table_metadatas_max_fields
  min: table_metadatas_min_fields
}

"""
Boolean expression to filter rows from the table "table_metadatas". All fields are combined with a logical 'AND'.
"""
input table_metadatas_bool_exp {
  _and: [table_metadatas_bool_exp!]
  _not: table_metadatas_bool_exp
  _or: [table_metadatas_bool_exp!]
  handle: String_comparison_exp
  inserted_at: timestamp_comparison_exp
  key_type: String_comparison_exp
  value_type: String_comparison_exp
}

"""
unique or primary key constraints on table "table_metadatas"
"""
enum table_metadatas_constraint {
  """
  unique or primary key constraint on columns "handle"
  """
  table_metadatas_pkey
}

"""
input type for inserting data into table "table_metadatas"
"""
input table_metadatas_insert_input {
  handle: String
  inserted_at: timestamp
  key_type: String
  value_type: String
}

"""aggregate max on columns"""
type table_metadatas_max_fields {
  handle: String
  inserted_at: timestamp
  key_type: String
  value_type: String
}

"""aggregate min on columns"""
type table_metadatas_min_fields {
  handle: String
  inserted_at: timestamp
  key_type: String
  value_type: String
}

"""
response of any mutation on the table "table_metadatas"
"""
type table_metadatas_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [table_metadatas!]!
}

"""
on_conflict condition type for table "table_metadatas"
"""
input table_metadatas_on_conflict {
  constraint: table_metadatas_constraint!
  update_columns: [table_metadatas_update_column!]! = []
  where: table_metadatas_bool_exp
}

"""Ordering options when selecting data from "table_metadatas"."""
input table_metadatas_order_by {
  handle: order_by
  inserted_at: order_by
  key_type: order_by
  value_type: order_by
}

"""primary key columns input for table: table_metadatas"""
input table_metadatas_pk_columns_input {
  handle: String!
}

"""
select columns of table "table_metadatas"
"""
enum table_metadatas_select_column {
  """column name"""
  handle

  """column name"""
  inserted_at

  """column name"""
  key_type

  """column name"""
  value_type
}

"""
input type for updating data in table "table_metadatas"
"""
input table_metadatas_set_input {
  handle: String
  inserted_at: timestamp
  key_type: String
  value_type: String
}

"""
Streaming cursor of the table "table_metadatas"
"""
input table_metadatas_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: table_metadatas_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input table_metadatas_stream_cursor_value_input {
  handle: String
  inserted_at: timestamp
  key_type: String
  value_type: String
}

"""
update columns of table "table_metadatas"
"""
enum table_metadatas_update_column {
  """column name"""
  handle

  """column name"""
  inserted_at

  """column name"""
  key_type

  """column name"""
  value_type
}

input table_metadatas_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: table_metadatas_set_input

  """filter the rows which have to be updated"""
  where: table_metadatas_bool_exp!
}

scalar timestamp

"""
Boolean expression to compare columns of type "timestamp". All fields are combined with logical 'AND'.
"""
input timestamp_comparison_exp {
  _eq: timestamp
  _gt: timestamp
  _gte: timestamp
  _in: [timestamp!]
  _is_null: Boolean
  _lt: timestamp
  _lte: timestamp
  _neq: timestamp
  _nin: [timestamp!]
}

"""
columns and relationships of "legacy_migration_v1.token_activities"
"""
type token_activities {
  """An array relationship"""
  aptos_names_owner(
    """distinct select on columns"""
    distinct_on: [current_aptos_names_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_aptos_names_order_by!]

    """filter the rows returned"""
    where: current_aptos_names_bool_exp
  ): [current_aptos_names!]!

  """An aggregate relationship"""
  aptos_names_owner_aggregate(
    """distinct select on columns"""
    distinct_on: [current_aptos_names_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_aptos_names_order_by!]

    """filter the rows returned"""
    where: current_aptos_names_bool_exp
  ): current_aptos_names_aggregate!

  """An array relationship"""
  aptos_names_to(
    """distinct select on columns"""
    distinct_on: [current_aptos_names_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_aptos_names_order_by!]

    """filter the rows returned"""
    where: current_aptos_names_bool_exp
  ): [current_aptos_names!]!

  """An aggregate relationship"""
  aptos_names_to_aggregate(
    """distinct select on columns"""
    distinct_on: [current_aptos_names_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_aptos_names_order_by!]

    """filter the rows returned"""
    where: current_aptos_names_bool_exp
  ): current_aptos_names_aggregate!
  coin_amount: String
  coin_type: String
  collection_data_id_hash: String
  collection_name: String
  creator_address: String

  """An object relationship"""
  current_token_data: current_token_datas
  event_account_address: String
  event_creation_number: Int
  event_index: bigint
  event_sequence_number: Int
  from_address: String
  inserted_at: timestamp
  name: String
  property_version: numeric
  to_address: String
  token_amount: numeric
  token_data_id_hash: String
  transaction_timestamp: timestamp
  transaction_version: bigint
  transfer_type: String
}

"""
aggregated selection of "legacy_migration_v1.token_activities"
"""
type token_activities_aggregate {
  aggregate: token_activities_aggregate_fields
  nodes: [token_activities!]!
}

input token_activities_aggregate_bool_exp {
  count: token_activities_aggregate_bool_exp_count
}

input token_activities_aggregate_bool_exp_count {
  arguments: [token_activities_select_column!]
  distinct: Boolean
  filter: token_activities_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "legacy_migration_v1.token_activities"
"""
type token_activities_aggregate_fields {
  avg: token_activities_avg_fields
  count(columns: [token_activities_select_column!], distinct: Boolean): Int!
  max: token_activities_max_fields
  min: token_activities_min_fields
  stddev: token_activities_stddev_fields
  stddev_pop: token_activities_stddev_pop_fields
  stddev_samp: token_activities_stddev_samp_fields
  sum: token_activities_sum_fields
  var_pop: token_activities_var_pop_fields
  var_samp: token_activities_var_samp_fields
  variance: token_activities_variance_fields
}

"""
order by aggregate values of table "legacy_migration_v1.token_activities"
"""
input token_activities_aggregate_order_by {
  avg: token_activities_avg_order_by
  count: order_by
  max: token_activities_max_order_by
  min: token_activities_min_order_by
  stddev: token_activities_stddev_order_by
  stddev_pop: token_activities_stddev_pop_order_by
  stddev_samp: token_activities_stddev_samp_order_by
  sum: token_activities_sum_order_by
  var_pop: token_activities_var_pop_order_by
  var_samp: token_activities_var_samp_order_by
  variance: token_activities_variance_order_by
}

"""
input type for inserting array relation for remote table "legacy_migration_v1.token_activities"
"""
input token_activities_arr_rel_insert_input {
  data: [token_activities_insert_input!]!
}

"""aggregate avg on columns"""
type token_activities_avg_fields {
  event_creation_number: Float
  event_index: Float
  event_sequence_number: Float
  property_version: Float
  token_amount: Float
  transaction_version: Float
}

"""
order by avg() on columns of table "legacy_migration_v1.token_activities"
"""
input token_activities_avg_order_by {
  event_creation_number: order_by
  event_index: order_by
  event_sequence_number: order_by
  property_version: order_by
  token_amount: order_by
  transaction_version: order_by
}

"""
Boolean expression to filter rows from the table "legacy_migration_v1.token_activities". All fields are combined with a logical 'AND'.
"""
input token_activities_bool_exp {
  _and: [token_activities_bool_exp!]
  _not: token_activities_bool_exp
  _or: [token_activities_bool_exp!]
  aptos_names_owner: current_aptos_names_bool_exp
  aptos_names_owner_aggregate: current_aptos_names_aggregate_bool_exp
  aptos_names_to: current_aptos_names_bool_exp
  aptos_names_to_aggregate: current_aptos_names_aggregate_bool_exp
  coin_amount: String_comparison_exp
  coin_type: String_comparison_exp
  collection_data_id_hash: String_comparison_exp
  collection_name: String_comparison_exp
  creator_address: String_comparison_exp
  current_token_data: current_token_datas_bool_exp
  event_account_address: String_comparison_exp
  event_creation_number: Int_comparison_exp
  event_index: bigint_comparison_exp
  event_sequence_number: Int_comparison_exp
  from_address: String_comparison_exp
  inserted_at: timestamp_comparison_exp
  name: String_comparison_exp
  property_version: numeric_comparison_exp
  to_address: String_comparison_exp
  token_amount: numeric_comparison_exp
  token_data_id_hash: String_comparison_exp
  transaction_timestamp: timestamp_comparison_exp
  transaction_version: bigint_comparison_exp
  transfer_type: String_comparison_exp
}

"""
input type for inserting data into table "legacy_migration_v1.token_activities"
"""
input token_activities_insert_input {
  aptos_names_owner: current_aptos_names_arr_rel_insert_input
  aptos_names_to: current_aptos_names_arr_rel_insert_input
  coin_amount: String
  coin_type: String
  collection_data_id_hash: String
  collection_name: String
  creator_address: String
  current_token_data: current_token_datas_obj_rel_insert_input
  event_account_address: String
  event_creation_number: Int
  event_index: bigint
  event_sequence_number: Int
  from_address: String
  inserted_at: timestamp
  name: String
  property_version: numeric
  to_address: String
  token_amount: numeric
  token_data_id_hash: String
  transaction_timestamp: timestamp
  transaction_version: bigint
  transfer_type: String
}

"""aggregate max on columns"""
type token_activities_max_fields {
  coin_amount: String
  coin_type: String
  collection_data_id_hash: String
  collection_name: String
  creator_address: String
  event_account_address: String
  event_creation_number: Int
  event_index: bigint
  event_sequence_number: Int
  from_address: String
  inserted_at: timestamp
  name: String
  property_version: numeric
  to_address: String
  token_amount: numeric
  token_data_id_hash: String
  transaction_timestamp: timestamp
  transaction_version: bigint
  transfer_type: String
}

"""
order by max() on columns of table "legacy_migration_v1.token_activities"
"""
input token_activities_max_order_by {
  coin_amount: order_by
  coin_type: order_by
  collection_data_id_hash: order_by
  collection_name: order_by
  creator_address: order_by
  event_account_address: order_by
  event_creation_number: order_by
  event_index: order_by
  event_sequence_number: order_by
  from_address: order_by
  inserted_at: order_by
  name: order_by
  property_version: order_by
  to_address: order_by
  token_amount: order_by
  token_data_id_hash: order_by
  transaction_timestamp: order_by
  transaction_version: order_by
  transfer_type: order_by
}

"""aggregate min on columns"""
type token_activities_min_fields {
  coin_amount: String
  coin_type: String
  collection_data_id_hash: String
  collection_name: String
  creator_address: String
  event_account_address: String
  event_creation_number: Int
  event_index: bigint
  event_sequence_number: Int
  from_address: String
  inserted_at: timestamp
  name: String
  property_version: numeric
  to_address: String
  token_amount: numeric
  token_data_id_hash: String
  transaction_timestamp: timestamp
  transaction_version: bigint
  transfer_type: String
}

"""
order by min() on columns of table "legacy_migration_v1.token_activities"
"""
input token_activities_min_order_by {
  coin_amount: order_by
  coin_type: order_by
  collection_data_id_hash: order_by
  collection_name: order_by
  creator_address: order_by
  event_account_address: order_by
  event_creation_number: order_by
  event_index: order_by
  event_sequence_number: order_by
  from_address: order_by
  inserted_at: order_by
  name: order_by
  property_version: order_by
  to_address: order_by
  token_amount: order_by
  token_data_id_hash: order_by
  transaction_timestamp: order_by
  transaction_version: order_by
  transfer_type: order_by
}

"""
Ordering options when selecting data from "legacy_migration_v1.token_activities".
"""
input token_activities_order_by {
  aptos_names_owner_aggregate: current_aptos_names_aggregate_order_by
  aptos_names_to_aggregate: current_aptos_names_aggregate_order_by
  coin_amount: order_by
  coin_type: order_by
  collection_data_id_hash: order_by
  collection_name: order_by
  creator_address: order_by
  current_token_data: current_token_datas_order_by
  event_account_address: order_by
  event_creation_number: order_by
  event_index: order_by
  event_sequence_number: order_by
  from_address: order_by
  inserted_at: order_by
  name: order_by
  property_version: order_by
  to_address: order_by
  token_amount: order_by
  token_data_id_hash: order_by
  transaction_timestamp: order_by
  transaction_version: order_by
  transfer_type: order_by
}

"""
select columns of table "legacy_migration_v1.token_activities"
"""
enum token_activities_select_column {
  """column name"""
  coin_amount

  """column name"""
  coin_type

  """column name"""
  collection_data_id_hash

  """column name"""
  collection_name

  """column name"""
  creator_address

  """column name"""
  event_account_address

  """column name"""
  event_creation_number

  """column name"""
  event_index

  """column name"""
  event_sequence_number

  """column name"""
  from_address

  """column name"""
  inserted_at

  """column name"""
  name

  """column name"""
  property_version

  """column name"""
  to_address

  """column name"""
  token_amount

  """column name"""
  token_data_id_hash

  """column name"""
  transaction_timestamp

  """column name"""
  transaction_version

  """column name"""
  transfer_type
}

"""aggregate stddev on columns"""
type token_activities_stddev_fields {
  event_creation_number: Float
  event_index: Float
  event_sequence_number: Float
  property_version: Float
  token_amount: Float
  transaction_version: Float
}

"""
order by stddev() on columns of table "legacy_migration_v1.token_activities"
"""
input token_activities_stddev_order_by {
  event_creation_number: order_by
  event_index: order_by
  event_sequence_number: order_by
  property_version: order_by
  token_amount: order_by
  transaction_version: order_by
}

"""aggregate stddev_pop on columns"""
type token_activities_stddev_pop_fields {
  event_creation_number: Float
  event_index: Float
  event_sequence_number: Float
  property_version: Float
  token_amount: Float
  transaction_version: Float
}

"""
order by stddev_pop() on columns of table "legacy_migration_v1.token_activities"
"""
input token_activities_stddev_pop_order_by {
  event_creation_number: order_by
  event_index: order_by
  event_sequence_number: order_by
  property_version: order_by
  token_amount: order_by
  transaction_version: order_by
}

"""aggregate stddev_samp on columns"""
type token_activities_stddev_samp_fields {
  event_creation_number: Float
  event_index: Float
  event_sequence_number: Float
  property_version: Float
  token_amount: Float
  transaction_version: Float
}

"""
order by stddev_samp() on columns of table "legacy_migration_v1.token_activities"
"""
input token_activities_stddev_samp_order_by {
  event_creation_number: order_by
  event_index: order_by
  event_sequence_number: order_by
  property_version: order_by
  token_amount: order_by
  transaction_version: order_by
}

"""
Streaming cursor of the table "token_activities"
"""
input token_activities_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: token_activities_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input token_activities_stream_cursor_value_input {
  coin_amount: String
  coin_type: String
  collection_data_id_hash: String
  collection_name: String
  creator_address: String
  event_account_address: String
  event_creation_number: Int
  event_index: bigint
  event_sequence_number: Int
  from_address: String
  inserted_at: timestamp
  name: String
  property_version: numeric
  to_address: String
  token_amount: numeric
  token_data_id_hash: String
  transaction_timestamp: timestamp
  transaction_version: bigint
  transfer_type: String
}

"""aggregate sum on columns"""
type token_activities_sum_fields {
  event_creation_number: Int
  event_index: bigint
  event_sequence_number: Int
  property_version: numeric
  token_amount: numeric
  transaction_version: bigint
}

"""
order by sum() on columns of table "legacy_migration_v1.token_activities"
"""
input token_activities_sum_order_by {
  event_creation_number: order_by
  event_index: order_by
  event_sequence_number: order_by
  property_version: order_by
  token_amount: order_by
  transaction_version: order_by
}

"""
columns and relationships of "token_activities_v2"
"""
type token_activities_v2 {
  after_value: String

  """An array relationship"""
  aptos_names_from(
    """distinct select on columns"""
    distinct_on: [current_aptos_names_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_aptos_names_order_by!]

    """filter the rows returned"""
    where: current_aptos_names_bool_exp
  ): [current_aptos_names!]!

  """An aggregate relationship"""
  aptos_names_from_aggregate(
    """distinct select on columns"""
    distinct_on: [current_aptos_names_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_aptos_names_order_by!]

    """filter the rows returned"""
    where: current_aptos_names_bool_exp
  ): current_aptos_names_aggregate!

  """An array relationship"""
  aptos_names_to(
    """distinct select on columns"""
    distinct_on: [current_aptos_names_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_aptos_names_order_by!]

    """filter the rows returned"""
    where: current_aptos_names_bool_exp
  ): [current_aptos_names!]!

  """An aggregate relationship"""
  aptos_names_to_aggregate(
    """distinct select on columns"""
    distinct_on: [current_aptos_names_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_aptos_names_order_by!]

    """filter the rows returned"""
    where: current_aptos_names_bool_exp
  ): current_aptos_names_aggregate!
  before_value: String

  """An object relationship"""
  current_token_data: current_token_datas_v2
  entry_function_id_str: String
  event_account_address: String!
  event_index: bigint!
  from_address: String
  inserted_at: timestamp!
  is_fungible_v2: Boolean
  property_version_v1: numeric!
  to_address: String
  token_amount: numeric!
  token_data_id: String!
  token_standard: String!
  transaction_timestamp: timestamp!
  transaction_version: bigint!
  type: String!
}

"""
aggregated selection of "token_activities_v2"
"""
type token_activities_v2_aggregate {
  aggregate: token_activities_v2_aggregate_fields
  nodes: [token_activities_v2!]!
}

input token_activities_v2_aggregate_bool_exp {
  bool_and: token_activities_v2_aggregate_bool_exp_bool_and
  bool_or: token_activities_v2_aggregate_bool_exp_bool_or
  count: token_activities_v2_aggregate_bool_exp_count
}

input token_activities_v2_aggregate_bool_exp_bool_and {
  arguments: token_activities_v2_select_column_token_activities_v2_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: token_activities_v2_bool_exp
  predicate: Boolean_comparison_exp!
}

input token_activities_v2_aggregate_bool_exp_bool_or {
  arguments: token_activities_v2_select_column_token_activities_v2_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: token_activities_v2_bool_exp
  predicate: Boolean_comparison_exp!
}

input token_activities_v2_aggregate_bool_exp_count {
  arguments: [token_activities_v2_select_column!]
  distinct: Boolean
  filter: token_activities_v2_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "token_activities_v2"
"""
type token_activities_v2_aggregate_fields {
  avg: token_activities_v2_avg_fields
  count(columns: [token_activities_v2_select_column!], distinct: Boolean): Int!
  max: token_activities_v2_max_fields
  min: token_activities_v2_min_fields
  stddev: token_activities_v2_stddev_fields
  stddev_pop: token_activities_v2_stddev_pop_fields
  stddev_samp: token_activities_v2_stddev_samp_fields
  sum: token_activities_v2_sum_fields
  var_pop: token_activities_v2_var_pop_fields
  var_samp: token_activities_v2_var_samp_fields
  variance: token_activities_v2_variance_fields
}

"""
order by aggregate values of table "token_activities_v2"
"""
input token_activities_v2_aggregate_order_by {
  avg: token_activities_v2_avg_order_by
  count: order_by
  max: token_activities_v2_max_order_by
  min: token_activities_v2_min_order_by
  stddev: token_activities_v2_stddev_order_by
  stddev_pop: token_activities_v2_stddev_pop_order_by
  stddev_samp: token_activities_v2_stddev_samp_order_by
  sum: token_activities_v2_sum_order_by
  var_pop: token_activities_v2_var_pop_order_by
  var_samp: token_activities_v2_var_samp_order_by
  variance: token_activities_v2_variance_order_by
}

"""
input type for inserting array relation for remote table "token_activities_v2"
"""
input token_activities_v2_arr_rel_insert_input {
  data: [token_activities_v2_insert_input!]!

  """upsert condition"""
  on_conflict: token_activities_v2_on_conflict
}

"""aggregate avg on columns"""
type token_activities_v2_avg_fields {
  event_index: Float
  property_version_v1: Float
  token_amount: Float
  transaction_version: Float
}

"""
order by avg() on columns of table "token_activities_v2"
"""
input token_activities_v2_avg_order_by {
  event_index: order_by
  property_version_v1: order_by
  token_amount: order_by
  transaction_version: order_by
}

"""
Boolean expression to filter rows from the table "token_activities_v2". All fields are combined with a logical 'AND'.
"""
input token_activities_v2_bool_exp {
  _and: [token_activities_v2_bool_exp!]
  _not: token_activities_v2_bool_exp
  _or: [token_activities_v2_bool_exp!]
  after_value: String_comparison_exp
  aptos_names_from: current_aptos_names_bool_exp
  aptos_names_from_aggregate: current_aptos_names_aggregate_bool_exp
  aptos_names_to: current_aptos_names_bool_exp
  aptos_names_to_aggregate: current_aptos_names_aggregate_bool_exp
  before_value: String_comparison_exp
  current_token_data: current_token_datas_v2_bool_exp
  entry_function_id_str: String_comparison_exp
  event_account_address: String_comparison_exp
  event_index: bigint_comparison_exp
  from_address: String_comparison_exp
  inserted_at: timestamp_comparison_exp
  is_fungible_v2: Boolean_comparison_exp
  property_version_v1: numeric_comparison_exp
  to_address: String_comparison_exp
  token_amount: numeric_comparison_exp
  token_data_id: String_comparison_exp
  token_standard: String_comparison_exp
  transaction_timestamp: timestamp_comparison_exp
  transaction_version: bigint_comparison_exp
  type: String_comparison_exp
}

"""
unique or primary key constraints on table "token_activities_v2"
"""
enum token_activities_v2_constraint {
  """
  unique or primary key constraint on columns "transaction_version", "event_index"
  """
  token_activities_v2_pkey
}

"""
input type for incrementing numeric columns in table "token_activities_v2"
"""
input token_activities_v2_inc_input {
  event_index: bigint
  property_version_v1: numeric
  token_amount: numeric
  transaction_version: bigint
}

"""
input type for inserting data into table "token_activities_v2"
"""
input token_activities_v2_insert_input {
  after_value: String
  aptos_names_from: current_aptos_names_arr_rel_insert_input
  aptos_names_to: current_aptos_names_arr_rel_insert_input
  before_value: String
  current_token_data: current_token_datas_v2_obj_rel_insert_input
  entry_function_id_str: String
  event_account_address: String
  event_index: bigint
  from_address: String
  inserted_at: timestamp
  is_fungible_v2: Boolean
  property_version_v1: numeric
  to_address: String
  token_amount: numeric
  token_data_id: String
  token_standard: String
  transaction_timestamp: timestamp
  transaction_version: bigint
  type: String
}

"""aggregate max on columns"""
type token_activities_v2_max_fields {
  after_value: String
  before_value: String
  entry_function_id_str: String
  event_account_address: String
  event_index: bigint
  from_address: String
  inserted_at: timestamp
  property_version_v1: numeric
  to_address: String
  token_amount: numeric
  token_data_id: String
  token_standard: String
  transaction_timestamp: timestamp
  transaction_version: bigint
  type: String
}

"""
order by max() on columns of table "token_activities_v2"
"""
input token_activities_v2_max_order_by {
  after_value: order_by
  before_value: order_by
  entry_function_id_str: order_by
  event_account_address: order_by
  event_index: order_by
  from_address: order_by
  inserted_at: order_by
  property_version_v1: order_by
  to_address: order_by
  token_amount: order_by
  token_data_id: order_by
  token_standard: order_by
  transaction_timestamp: order_by
  transaction_version: order_by
  type: order_by
}

"""aggregate min on columns"""
type token_activities_v2_min_fields {
  after_value: String
  before_value: String
  entry_function_id_str: String
  event_account_address: String
  event_index: bigint
  from_address: String
  inserted_at: timestamp
  property_version_v1: numeric
  to_address: String
  token_amount: numeric
  token_data_id: String
  token_standard: String
  transaction_timestamp: timestamp
  transaction_version: bigint
  type: String
}

"""
order by min() on columns of table "token_activities_v2"
"""
input token_activities_v2_min_order_by {
  after_value: order_by
  before_value: order_by
  entry_function_id_str: order_by
  event_account_address: order_by
  event_index: order_by
  from_address: order_by
  inserted_at: order_by
  property_version_v1: order_by
  to_address: order_by
  token_amount: order_by
  token_data_id: order_by
  token_standard: order_by
  transaction_timestamp: order_by
  transaction_version: order_by
  type: order_by
}

"""
response of any mutation on the table "token_activities_v2"
"""
type token_activities_v2_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [token_activities_v2!]!
}

"""
on_conflict condition type for table "token_activities_v2"
"""
input token_activities_v2_on_conflict {
  constraint: token_activities_v2_constraint!
  update_columns: [token_activities_v2_update_column!]! = []
  where: token_activities_v2_bool_exp
}

"""Ordering options when selecting data from "token_activities_v2"."""
input token_activities_v2_order_by {
  after_value: order_by
  aptos_names_from_aggregate: current_aptos_names_aggregate_order_by
  aptos_names_to_aggregate: current_aptos_names_aggregate_order_by
  before_value: order_by
  current_token_data: current_token_datas_v2_order_by
  entry_function_id_str: order_by
  event_account_address: order_by
  event_index: order_by
  from_address: order_by
  inserted_at: order_by
  is_fungible_v2: order_by
  property_version_v1: order_by
  to_address: order_by
  token_amount: order_by
  token_data_id: order_by
  token_standard: order_by
  transaction_timestamp: order_by
  transaction_version: order_by
  type: order_by
}

"""primary key columns input for table: token_activities_v2"""
input token_activities_v2_pk_columns_input {
  event_index: bigint!
  transaction_version: bigint!
}

"""
select columns of table "token_activities_v2"
"""
enum token_activities_v2_select_column {
  """column name"""
  after_value

  """column name"""
  before_value

  """column name"""
  entry_function_id_str

  """column name"""
  event_account_address

  """column name"""
  event_index

  """column name"""
  from_address

  """column name"""
  inserted_at

  """column name"""
  is_fungible_v2

  """column name"""
  property_version_v1

  """column name"""
  to_address

  """column name"""
  token_amount

  """column name"""
  token_data_id

  """column name"""
  token_standard

  """column name"""
  transaction_timestamp

  """column name"""
  transaction_version

  """column name"""
  type
}

"""
select "token_activities_v2_aggregate_bool_exp_bool_and_arguments_columns" columns of table "token_activities_v2"
"""
enum token_activities_v2_select_column_token_activities_v2_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  is_fungible_v2
}

"""
select "token_activities_v2_aggregate_bool_exp_bool_or_arguments_columns" columns of table "token_activities_v2"
"""
enum token_activities_v2_select_column_token_activities_v2_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  is_fungible_v2
}

"""
input type for updating data in table "token_activities_v2"
"""
input token_activities_v2_set_input {
  after_value: String
  before_value: String
  entry_function_id_str: String
  event_account_address: String
  event_index: bigint
  from_address: String
  inserted_at: timestamp
  is_fungible_v2: Boolean
  property_version_v1: numeric
  to_address: String
  token_amount: numeric
  token_data_id: String
  token_standard: String
  transaction_timestamp: timestamp
  transaction_version: bigint
  type: String
}

"""aggregate stddev on columns"""
type token_activities_v2_stddev_fields {
  event_index: Float
  property_version_v1: Float
  token_amount: Float
  transaction_version: Float
}

"""
order by stddev() on columns of table "token_activities_v2"
"""
input token_activities_v2_stddev_order_by {
  event_index: order_by
  property_version_v1: order_by
  token_amount: order_by
  transaction_version: order_by
}

"""aggregate stddev_pop on columns"""
type token_activities_v2_stddev_pop_fields {
  event_index: Float
  property_version_v1: Float
  token_amount: Float
  transaction_version: Float
}

"""
order by stddev_pop() on columns of table "token_activities_v2"
"""
input token_activities_v2_stddev_pop_order_by {
  event_index: order_by
  property_version_v1: order_by
  token_amount: order_by
  transaction_version: order_by
}

"""aggregate stddev_samp on columns"""
type token_activities_v2_stddev_samp_fields {
  event_index: Float
  property_version_v1: Float
  token_amount: Float
  transaction_version: Float
}

"""
order by stddev_samp() on columns of table "token_activities_v2"
"""
input token_activities_v2_stddev_samp_order_by {
  event_index: order_by
  property_version_v1: order_by
  token_amount: order_by
  transaction_version: order_by
}

"""
Streaming cursor of the table "token_activities_v2"
"""
input token_activities_v2_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: token_activities_v2_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input token_activities_v2_stream_cursor_value_input {
  after_value: String
  before_value: String
  entry_function_id_str: String
  event_account_address: String
  event_index: bigint
  from_address: String
  inserted_at: timestamp
  is_fungible_v2: Boolean
  property_version_v1: numeric
  to_address: String
  token_amount: numeric
  token_data_id: String
  token_standard: String
  transaction_timestamp: timestamp
  transaction_version: bigint
  type: String
}

"""aggregate sum on columns"""
type token_activities_v2_sum_fields {
  event_index: bigint
  property_version_v1: numeric
  token_amount: numeric
  transaction_version: bigint
}

"""
order by sum() on columns of table "token_activities_v2"
"""
input token_activities_v2_sum_order_by {
  event_index: order_by
  property_version_v1: order_by
  token_amount: order_by
  transaction_version: order_by
}

"""
update columns of table "token_activities_v2"
"""
enum token_activities_v2_update_column {
  """column name"""
  after_value

  """column name"""
  before_value

  """column name"""
  entry_function_id_str

  """column name"""
  event_account_address

  """column name"""
  event_index

  """column name"""
  from_address

  """column name"""
  inserted_at

  """column name"""
  is_fungible_v2

  """column name"""
  property_version_v1

  """column name"""
  to_address

  """column name"""
  token_amount

  """column name"""
  token_data_id

  """column name"""
  token_standard

  """column name"""
  transaction_timestamp

  """column name"""
  transaction_version

  """column name"""
  type
}

input token_activities_v2_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: token_activities_v2_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: token_activities_v2_set_input

  """filter the rows which have to be updated"""
  where: token_activities_v2_bool_exp!
}

"""aggregate var_pop on columns"""
type token_activities_v2_var_pop_fields {
  event_index: Float
  property_version_v1: Float
  token_amount: Float
  transaction_version: Float
}

"""
order by var_pop() on columns of table "token_activities_v2"
"""
input token_activities_v2_var_pop_order_by {
  event_index: order_by
  property_version_v1: order_by
  token_amount: order_by
  transaction_version: order_by
}

"""aggregate var_samp on columns"""
type token_activities_v2_var_samp_fields {
  event_index: Float
  property_version_v1: Float
  token_amount: Float
  transaction_version: Float
}

"""
order by var_samp() on columns of table "token_activities_v2"
"""
input token_activities_v2_var_samp_order_by {
  event_index: order_by
  property_version_v1: order_by
  token_amount: order_by
  transaction_version: order_by
}

"""aggregate variance on columns"""
type token_activities_v2_variance_fields {
  event_index: Float
  property_version_v1: Float
  token_amount: Float
  transaction_version: Float
}

"""
order by variance() on columns of table "token_activities_v2"
"""
input token_activities_v2_variance_order_by {
  event_index: order_by
  property_version_v1: order_by
  token_amount: order_by
  transaction_version: order_by
}

"""aggregate var_pop on columns"""
type token_activities_var_pop_fields {
  event_creation_number: Float
  event_index: Float
  event_sequence_number: Float
  property_version: Float
  token_amount: Float
  transaction_version: Float
}

"""
order by var_pop() on columns of table "legacy_migration_v1.token_activities"
"""
input token_activities_var_pop_order_by {
  event_creation_number: order_by
  event_index: order_by
  event_sequence_number: order_by
  property_version: order_by
  token_amount: order_by
  transaction_version: order_by
}

"""aggregate var_samp on columns"""
type token_activities_var_samp_fields {
  event_creation_number: Float
  event_index: Float
  event_sequence_number: Float
  property_version: Float
  token_amount: Float
  transaction_version: Float
}

"""
order by var_samp() on columns of table "legacy_migration_v1.token_activities"
"""
input token_activities_var_samp_order_by {
  event_creation_number: order_by
  event_index: order_by
  event_sequence_number: order_by
  property_version: order_by
  token_amount: order_by
  transaction_version: order_by
}

"""aggregate variance on columns"""
type token_activities_variance_fields {
  event_creation_number: Float
  event_index: Float
  event_sequence_number: Float
  property_version: Float
  token_amount: Float
  transaction_version: Float
}

"""
order by variance() on columns of table "legacy_migration_v1.token_activities"
"""
input token_activities_variance_order_by {
  event_creation_number: order_by
  event_index: order_by
  event_sequence_number: order_by
  property_version: order_by
  token_amount: order_by
  transaction_version: order_by
}

"""
columns and relationships of "legacy_migration_v1.token_datas"
"""
type token_datas {
  collection_data_id_hash: String
  collection_name: String
  creator_address: String
  default_properties(
    """JSON select path"""
    path: String
  ): jsonb
  description: String
  description_mutable: Boolean
  inserted_at: timestamp
  largest_property_version: numeric
  maximum: numeric
  maximum_mutable: Boolean
  metadata_uri: String
  name: String
  payee_address: String
  properties_mutable: Boolean
  royalty_mutable: Boolean
  royalty_points_denominator: String
  royalty_points_numerator: String
  supply: numeric
  token_data_id_hash: String
  transaction_timestamp: timestamp
  transaction_version: bigint
  uri_mutable: Boolean
}

"""
aggregated selection of "legacy_migration_v1.token_datas"
"""
type token_datas_aggregate {
  aggregate: token_datas_aggregate_fields
  nodes: [token_datas!]!
}

"""
aggregate fields of "legacy_migration_v1.token_datas"
"""
type token_datas_aggregate_fields {
  avg: token_datas_avg_fields
  count(columns: [token_datas_select_column!], distinct: Boolean): Int!
  max: token_datas_max_fields
  min: token_datas_min_fields
  stddev: token_datas_stddev_fields
  stddev_pop: token_datas_stddev_pop_fields
  stddev_samp: token_datas_stddev_samp_fields
  sum: token_datas_sum_fields
  var_pop: token_datas_var_pop_fields
  var_samp: token_datas_var_samp_fields
  variance: token_datas_variance_fields
}

"""aggregate avg on columns"""
type token_datas_avg_fields {
  largest_property_version: Float
  maximum: Float
  supply: Float
  transaction_version: Float
}

"""
Boolean expression to filter rows from the table "legacy_migration_v1.token_datas". All fields are combined with a logical 'AND'.
"""
input token_datas_bool_exp {
  _and: [token_datas_bool_exp!]
  _not: token_datas_bool_exp
  _or: [token_datas_bool_exp!]
  collection_data_id_hash: String_comparison_exp
  collection_name: String_comparison_exp
  creator_address: String_comparison_exp
  default_properties: jsonb_comparison_exp
  description: String_comparison_exp
  description_mutable: Boolean_comparison_exp
  inserted_at: timestamp_comparison_exp
  largest_property_version: numeric_comparison_exp
  maximum: numeric_comparison_exp
  maximum_mutable: Boolean_comparison_exp
  metadata_uri: String_comparison_exp
  name: String_comparison_exp
  payee_address: String_comparison_exp
  properties_mutable: Boolean_comparison_exp
  royalty_mutable: Boolean_comparison_exp
  royalty_points_denominator: String_comparison_exp
  royalty_points_numerator: String_comparison_exp
  supply: numeric_comparison_exp
  token_data_id_hash: String_comparison_exp
  transaction_timestamp: timestamp_comparison_exp
  transaction_version: bigint_comparison_exp
  uri_mutable: Boolean_comparison_exp
}

"""aggregate max on columns"""
type token_datas_max_fields {
  collection_data_id_hash: String
  collection_name: String
  creator_address: String
  description: String
  inserted_at: timestamp
  largest_property_version: numeric
  maximum: numeric
  metadata_uri: String
  name: String
  payee_address: String
  royalty_points_denominator: String
  royalty_points_numerator: String
  supply: numeric
  token_data_id_hash: String
  transaction_timestamp: timestamp
  transaction_version: bigint
}

"""aggregate min on columns"""
type token_datas_min_fields {
  collection_data_id_hash: String
  collection_name: String
  creator_address: String
  description: String
  inserted_at: timestamp
  largest_property_version: numeric
  maximum: numeric
  metadata_uri: String
  name: String
  payee_address: String
  royalty_points_denominator: String
  royalty_points_numerator: String
  supply: numeric
  token_data_id_hash: String
  transaction_timestamp: timestamp
  transaction_version: bigint
}

"""
Ordering options when selecting data from "legacy_migration_v1.token_datas".
"""
input token_datas_order_by {
  collection_data_id_hash: order_by
  collection_name: order_by
  creator_address: order_by
  default_properties: order_by
  description: order_by
  description_mutable: order_by
  inserted_at: order_by
  largest_property_version: order_by
  maximum: order_by
  maximum_mutable: order_by
  metadata_uri: order_by
  name: order_by
  payee_address: order_by
  properties_mutable: order_by
  royalty_mutable: order_by
  royalty_points_denominator: order_by
  royalty_points_numerator: order_by
  supply: order_by
  token_data_id_hash: order_by
  transaction_timestamp: order_by
  transaction_version: order_by
  uri_mutable: order_by
}

"""
select columns of table "legacy_migration_v1.token_datas"
"""
enum token_datas_select_column {
  """column name"""
  collection_data_id_hash

  """column name"""
  collection_name

  """column name"""
  creator_address

  """column name"""
  default_properties

  """column name"""
  description

  """column name"""
  description_mutable

  """column name"""
  inserted_at

  """column name"""
  largest_property_version

  """column name"""
  maximum

  """column name"""
  maximum_mutable

  """column name"""
  metadata_uri

  """column name"""
  name

  """column name"""
  payee_address

  """column name"""
  properties_mutable

  """column name"""
  royalty_mutable

  """column name"""
  royalty_points_denominator

  """column name"""
  royalty_points_numerator

  """column name"""
  supply

  """column name"""
  token_data_id_hash

  """column name"""
  transaction_timestamp

  """column name"""
  transaction_version

  """column name"""
  uri_mutable
}

"""aggregate stddev on columns"""
type token_datas_stddev_fields {
  largest_property_version: Float
  maximum: Float
  supply: Float
  transaction_version: Float
}

"""aggregate stddev_pop on columns"""
type token_datas_stddev_pop_fields {
  largest_property_version: Float
  maximum: Float
  supply: Float
  transaction_version: Float
}

"""aggregate stddev_samp on columns"""
type token_datas_stddev_samp_fields {
  largest_property_version: Float
  maximum: Float
  supply: Float
  transaction_version: Float
}

"""
Streaming cursor of the table "token_datas"
"""
input token_datas_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: token_datas_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input token_datas_stream_cursor_value_input {
  collection_data_id_hash: String
  collection_name: String
  creator_address: String
  default_properties: jsonb
  description: String
  description_mutable: Boolean
  inserted_at: timestamp
  largest_property_version: numeric
  maximum: numeric
  maximum_mutable: Boolean
  metadata_uri: String
  name: String
  payee_address: String
  properties_mutable: Boolean
  royalty_mutable: Boolean
  royalty_points_denominator: String
  royalty_points_numerator: String
  supply: numeric
  token_data_id_hash: String
  transaction_timestamp: timestamp
  transaction_version: bigint
  uri_mutable: Boolean
}

"""aggregate sum on columns"""
type token_datas_sum_fields {
  largest_property_version: numeric
  maximum: numeric
  supply: numeric
  transaction_version: bigint
}

"""aggregate var_pop on columns"""
type token_datas_var_pop_fields {
  largest_property_version: Float
  maximum: Float
  supply: Float
  transaction_version: Float
}

"""aggregate var_samp on columns"""
type token_datas_var_samp_fields {
  largest_property_version: Float
  maximum: Float
  supply: Float
  transaction_version: Float
}

"""aggregate variance on columns"""
type token_datas_variance_fields {
  largest_property_version: Float
  maximum: Float
  supply: Float
  transaction_version: Float
}

"""
columns and relationships of "legacy_migration_v1.token_ownerships"
"""
type token_ownerships {
  amount: numeric
  collection_data_id_hash: String
  collection_name: String
  creator_address: String
  inserted_at: timestamp
  name: String
  owner_address: String
  property_version: numeric
  table_handle: String
  table_type: String
  token_data_id_hash: String
  transaction_timestamp: timestamp
  transaction_version: bigint
}

"""
aggregated selection of "legacy_migration_v1.token_ownerships"
"""
type token_ownerships_aggregate {
  aggregate: token_ownerships_aggregate_fields
  nodes: [token_ownerships!]!
}

"""
aggregate fields of "legacy_migration_v1.token_ownerships"
"""
type token_ownerships_aggregate_fields {
  avg: token_ownerships_avg_fields
  count(columns: [token_ownerships_select_column!], distinct: Boolean): Int!
  max: token_ownerships_max_fields
  min: token_ownerships_min_fields
  stddev: token_ownerships_stddev_fields
  stddev_pop: token_ownerships_stddev_pop_fields
  stddev_samp: token_ownerships_stddev_samp_fields
  sum: token_ownerships_sum_fields
  var_pop: token_ownerships_var_pop_fields
  var_samp: token_ownerships_var_samp_fields
  variance: token_ownerships_variance_fields
}

"""aggregate avg on columns"""
type token_ownerships_avg_fields {
  amount: Float
  property_version: Float
  transaction_version: Float
}

"""
Boolean expression to filter rows from the table "legacy_migration_v1.token_ownerships". All fields are combined with a logical 'AND'.
"""
input token_ownerships_bool_exp {
  _and: [token_ownerships_bool_exp!]
  _not: token_ownerships_bool_exp
  _or: [token_ownerships_bool_exp!]
  amount: numeric_comparison_exp
  collection_data_id_hash: String_comparison_exp
  collection_name: String_comparison_exp
  creator_address: String_comparison_exp
  inserted_at: timestamp_comparison_exp
  name: String_comparison_exp
  owner_address: String_comparison_exp
  property_version: numeric_comparison_exp
  table_handle: String_comparison_exp
  table_type: String_comparison_exp
  token_data_id_hash: String_comparison_exp
  transaction_timestamp: timestamp_comparison_exp
  transaction_version: bigint_comparison_exp
}

"""aggregate max on columns"""
type token_ownerships_max_fields {
  amount: numeric
  collection_data_id_hash: String
  collection_name: String
  creator_address: String
  inserted_at: timestamp
  name: String
  owner_address: String
  property_version: numeric
  table_handle: String
  table_type: String
  token_data_id_hash: String
  transaction_timestamp: timestamp
  transaction_version: bigint
}

"""aggregate min on columns"""
type token_ownerships_min_fields {
  amount: numeric
  collection_data_id_hash: String
  collection_name: String
  creator_address: String
  inserted_at: timestamp
  name: String
  owner_address: String
  property_version: numeric
  table_handle: String
  table_type: String
  token_data_id_hash: String
  transaction_timestamp: timestamp
  transaction_version: bigint
}

"""
Ordering options when selecting data from "legacy_migration_v1.token_ownerships".
"""
input token_ownerships_order_by {
  amount: order_by
  collection_data_id_hash: order_by
  collection_name: order_by
  creator_address: order_by
  inserted_at: order_by
  name: order_by
  owner_address: order_by
  property_version: order_by
  table_handle: order_by
  table_type: order_by
  token_data_id_hash: order_by
  transaction_timestamp: order_by
  transaction_version: order_by
}

"""
select columns of table "legacy_migration_v1.token_ownerships"
"""
enum token_ownerships_select_column {
  """column name"""
  amount

  """column name"""
  collection_data_id_hash

  """column name"""
  collection_name

  """column name"""
  creator_address

  """column name"""
  inserted_at

  """column name"""
  name

  """column name"""
  owner_address

  """column name"""
  property_version

  """column name"""
  table_handle

  """column name"""
  table_type

  """column name"""
  token_data_id_hash

  """column name"""
  transaction_timestamp

  """column name"""
  transaction_version
}

"""aggregate stddev on columns"""
type token_ownerships_stddev_fields {
  amount: Float
  property_version: Float
  transaction_version: Float
}

"""aggregate stddev_pop on columns"""
type token_ownerships_stddev_pop_fields {
  amount: Float
  property_version: Float
  transaction_version: Float
}

"""aggregate stddev_samp on columns"""
type token_ownerships_stddev_samp_fields {
  amount: Float
  property_version: Float
  transaction_version: Float
}

"""
Streaming cursor of the table "token_ownerships"
"""
input token_ownerships_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: token_ownerships_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input token_ownerships_stream_cursor_value_input {
  amount: numeric
  collection_data_id_hash: String
  collection_name: String
  creator_address: String
  inserted_at: timestamp
  name: String
  owner_address: String
  property_version: numeric
  table_handle: String
  table_type: String
  token_data_id_hash: String
  transaction_timestamp: timestamp
  transaction_version: bigint
}

"""aggregate sum on columns"""
type token_ownerships_sum_fields {
  amount: numeric
  property_version: numeric
  transaction_version: bigint
}

"""aggregate var_pop on columns"""
type token_ownerships_var_pop_fields {
  amount: Float
  property_version: Float
  transaction_version: Float
}

"""aggregate var_samp on columns"""
type token_ownerships_var_samp_fields {
  amount: Float
  property_version: Float
  transaction_version: Float
}

"""aggregate variance on columns"""
type token_ownerships_variance_fields {
  amount: Float
  property_version: Float
  transaction_version: Float
}

"""
columns and relationships of "legacy_migration_v1.tokens"
"""
type tokens {
  collection_data_id_hash: String
  collection_name: String
  creator_address: String
  inserted_at: timestamp
  name: String
  property_version: numeric
  token_data_id_hash: String
  token_properties(
    """JSON select path"""
    path: String
  ): jsonb
  transaction_timestamp: timestamp
  transaction_version: bigint
}

"""
aggregated selection of "legacy_migration_v1.tokens"
"""
type tokens_aggregate {
  aggregate: tokens_aggregate_fields
  nodes: [tokens!]!
}

"""
aggregate fields of "legacy_migration_v1.tokens"
"""
type tokens_aggregate_fields {
  avg: tokens_avg_fields
  count(columns: [tokens_select_column!], distinct: Boolean): Int!
  max: tokens_max_fields
  min: tokens_min_fields
  stddev: tokens_stddev_fields
  stddev_pop: tokens_stddev_pop_fields
  stddev_samp: tokens_stddev_samp_fields
  sum: tokens_sum_fields
  var_pop: tokens_var_pop_fields
  var_samp: tokens_var_samp_fields
  variance: tokens_variance_fields
}

"""aggregate avg on columns"""
type tokens_avg_fields {
  property_version: Float
  transaction_version: Float
}

"""
Boolean expression to filter rows from the table "legacy_migration_v1.tokens". All fields are combined with a logical 'AND'.
"""
input tokens_bool_exp {
  _and: [tokens_bool_exp!]
  _not: tokens_bool_exp
  _or: [tokens_bool_exp!]
  collection_data_id_hash: String_comparison_exp
  collection_name: String_comparison_exp
  creator_address: String_comparison_exp
  inserted_at: timestamp_comparison_exp
  name: String_comparison_exp
  property_version: numeric_comparison_exp
  token_data_id_hash: String_comparison_exp
  token_properties: jsonb_comparison_exp
  transaction_timestamp: timestamp_comparison_exp
  transaction_version: bigint_comparison_exp
}

"""
input type for inserting data into table "legacy_migration_v1.tokens"
"""
input tokens_insert_input {
  collection_data_id_hash: String
  collection_name: String
  creator_address: String
  inserted_at: timestamp
  name: String
  property_version: numeric
  token_data_id_hash: String
  token_properties: jsonb
  transaction_timestamp: timestamp
  transaction_version: bigint
}

"""aggregate max on columns"""
type tokens_max_fields {
  collection_data_id_hash: String
  collection_name: String
  creator_address: String
  inserted_at: timestamp
  name: String
  property_version: numeric
  token_data_id_hash: String
  transaction_timestamp: timestamp
  transaction_version: bigint
}

"""aggregate min on columns"""
type tokens_min_fields {
  collection_data_id_hash: String
  collection_name: String
  creator_address: String
  inserted_at: timestamp
  name: String
  property_version: numeric
  token_data_id_hash: String
  transaction_timestamp: timestamp
  transaction_version: bigint
}

"""
input type for inserting object relation for remote table "legacy_migration_v1.tokens"
"""
input tokens_obj_rel_insert_input {
  data: tokens_insert_input!
}

"""
Ordering options when selecting data from "legacy_migration_v1.tokens".
"""
input tokens_order_by {
  collection_data_id_hash: order_by
  collection_name: order_by
  creator_address: order_by
  inserted_at: order_by
  name: order_by
  property_version: order_by
  token_data_id_hash: order_by
  token_properties: order_by
  transaction_timestamp: order_by
  transaction_version: order_by
}

"""
select columns of table "legacy_migration_v1.tokens"
"""
enum tokens_select_column {
  """column name"""
  collection_data_id_hash

  """column name"""
  collection_name

  """column name"""
  creator_address

  """column name"""
  inserted_at

  """column name"""
  name

  """column name"""
  property_version

  """column name"""
  token_data_id_hash

  """column name"""
  token_properties

  """column name"""
  transaction_timestamp

  """column name"""
  transaction_version
}

"""aggregate stddev on columns"""
type tokens_stddev_fields {
  property_version: Float
  transaction_version: Float
}

"""aggregate stddev_pop on columns"""
type tokens_stddev_pop_fields {
  property_version: Float
  transaction_version: Float
}

"""aggregate stddev_samp on columns"""
type tokens_stddev_samp_fields {
  property_version: Float
  transaction_version: Float
}

"""
Streaming cursor of the table "tokens"
"""
input tokens_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: tokens_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input tokens_stream_cursor_value_input {
  collection_data_id_hash: String
  collection_name: String
  creator_address: String
  inserted_at: timestamp
  name: String
  property_version: numeric
  token_data_id_hash: String
  token_properties: jsonb
  transaction_timestamp: timestamp
  transaction_version: bigint
}

"""aggregate sum on columns"""
type tokens_sum_fields {
  property_version: numeric
  transaction_version: bigint
}

"""aggregate var_pop on columns"""
type tokens_var_pop_fields {
  property_version: Float
  transaction_version: Float
}

"""aggregate var_samp on columns"""
type tokens_var_samp_fields {
  property_version: Float
  transaction_version: Float
}

"""aggregate variance on columns"""
type tokens_variance_fields {
  property_version: Float
  transaction_version: Float
}

"""
columns and relationships of "user_transactions"
"""
type user_transactions {
  block_height: bigint!
  entry_function_id_str: String!
  epoch: bigint!
  expiration_timestamp_secs: timestamp!
  gas_unit_price: numeric!
  inserted_at: timestamp!
  max_gas_amount: numeric!
  parent_signature_type: String!
  sender: String!
  sequence_number: bigint!
  timestamp: timestamp!
  version: bigint!
}

"""
aggregated selection of "user_transactions"
"""
type user_transactions_aggregate {
  aggregate: user_transactions_aggregate_fields
  nodes: [user_transactions!]!
}

"""
aggregate fields of "user_transactions"
"""
type user_transactions_aggregate_fields {
  avg: user_transactions_avg_fields
  count(columns: [user_transactions_select_column!], distinct: Boolean): Int!
  max: user_transactions_max_fields
  min: user_transactions_min_fields
  stddev: user_transactions_stddev_fields
  stddev_pop: user_transactions_stddev_pop_fields
  stddev_samp: user_transactions_stddev_samp_fields
  sum: user_transactions_sum_fields
  var_pop: user_transactions_var_pop_fields
  var_samp: user_transactions_var_samp_fields
  variance: user_transactions_variance_fields
}

"""aggregate avg on columns"""
type user_transactions_avg_fields {
  block_height: Float
  epoch: Float
  gas_unit_price: Float
  max_gas_amount: Float
  sequence_number: Float
  version: Float
}

"""
Boolean expression to filter rows from the table "user_transactions". All fields are combined with a logical 'AND'.
"""
input user_transactions_bool_exp {
  _and: [user_transactions_bool_exp!]
  _not: user_transactions_bool_exp
  _or: [user_transactions_bool_exp!]
  block_height: bigint_comparison_exp
  entry_function_id_str: String_comparison_exp
  epoch: bigint_comparison_exp
  expiration_timestamp_secs: timestamp_comparison_exp
  gas_unit_price: numeric_comparison_exp
  inserted_at: timestamp_comparison_exp
  max_gas_amount: numeric_comparison_exp
  parent_signature_type: String_comparison_exp
  sender: String_comparison_exp
  sequence_number: bigint_comparison_exp
  timestamp: timestamp_comparison_exp
  version: bigint_comparison_exp
}

"""
unique or primary key constraints on table "user_transactions"
"""
enum user_transactions_constraint {
  """
  unique or primary key constraint on columns "version"
  """
  user_transactions_pkey

  """
  unique or primary key constraint on columns "sequence_number", "sender"
  """
  user_transactions_sender_sequence_number_key
}

"""
input type for incrementing numeric columns in table "user_transactions"
"""
input user_transactions_inc_input {
  block_height: bigint
  epoch: bigint
  gas_unit_price: numeric
  max_gas_amount: numeric
  sequence_number: bigint
  version: bigint
}

"""
input type for inserting data into table "user_transactions"
"""
input user_transactions_insert_input {
  block_height: bigint
  entry_function_id_str: String
  epoch: bigint
  expiration_timestamp_secs: timestamp
  gas_unit_price: numeric
  inserted_at: timestamp
  max_gas_amount: numeric
  parent_signature_type: String
  sender: String
  sequence_number: bigint
  timestamp: timestamp
  version: bigint
}

"""aggregate max on columns"""
type user_transactions_max_fields {
  block_height: bigint
  entry_function_id_str: String
  epoch: bigint
  expiration_timestamp_secs: timestamp
  gas_unit_price: numeric
  inserted_at: timestamp
  max_gas_amount: numeric
  parent_signature_type: String
  sender: String
  sequence_number: bigint
  timestamp: timestamp
  version: bigint
}

"""aggregate min on columns"""
type user_transactions_min_fields {
  block_height: bigint
  entry_function_id_str: String
  epoch: bigint
  expiration_timestamp_secs: timestamp
  gas_unit_price: numeric
  inserted_at: timestamp
  max_gas_amount: numeric
  parent_signature_type: String
  sender: String
  sequence_number: bigint
  timestamp: timestamp
  version: bigint
}

"""
response of any mutation on the table "user_transactions"
"""
type user_transactions_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [user_transactions!]!
}

"""
input type for inserting object relation for remote table "user_transactions"
"""
input user_transactions_obj_rel_insert_input {
  data: user_transactions_insert_input!

  """upsert condition"""
  on_conflict: user_transactions_on_conflict
}

"""
on_conflict condition type for table "user_transactions"
"""
input user_transactions_on_conflict {
  constraint: user_transactions_constraint!
  update_columns: [user_transactions_update_column!]! = []
  where: user_transactions_bool_exp
}

"""Ordering options when selecting data from "user_transactions"."""
input user_transactions_order_by {
  block_height: order_by
  entry_function_id_str: order_by
  epoch: order_by
  expiration_timestamp_secs: order_by
  gas_unit_price: order_by
  inserted_at: order_by
  max_gas_amount: order_by
  parent_signature_type: order_by
  sender: order_by
  sequence_number: order_by
  timestamp: order_by
  version: order_by
}

"""primary key columns input for table: user_transactions"""
input user_transactions_pk_columns_input {
  version: bigint!
}

"""
select columns of table "user_transactions"
"""
enum user_transactions_select_column {
  """column name"""
  block_height

  """column name"""
  entry_function_id_str

  """column name"""
  epoch

  """column name"""
  expiration_timestamp_secs

  """column name"""
  gas_unit_price

  """column name"""
  inserted_at

  """column name"""
  max_gas_amount

  """column name"""
  parent_signature_type

  """column name"""
  sender

  """column name"""
  sequence_number

  """column name"""
  timestamp

  """column name"""
  version
}

"""
input type for updating data in table "user_transactions"
"""
input user_transactions_set_input {
  block_height: bigint
  entry_function_id_str: String
  epoch: bigint
  expiration_timestamp_secs: timestamp
  gas_unit_price: numeric
  inserted_at: timestamp
  max_gas_amount: numeric
  parent_signature_type: String
  sender: String
  sequence_number: bigint
  timestamp: timestamp
  version: bigint
}

"""aggregate stddev on columns"""
type user_transactions_stddev_fields {
  block_height: Float
  epoch: Float
  gas_unit_price: Float
  max_gas_amount: Float
  sequence_number: Float
  version: Float
}

"""aggregate stddev_pop on columns"""
type user_transactions_stddev_pop_fields {
  block_height: Float
  epoch: Float
  gas_unit_price: Float
  max_gas_amount: Float
  sequence_number: Float
  version: Float
}

"""aggregate stddev_samp on columns"""
type user_transactions_stddev_samp_fields {
  block_height: Float
  epoch: Float
  gas_unit_price: Float
  max_gas_amount: Float
  sequence_number: Float
  version: Float
}

"""
Streaming cursor of the table "user_transactions"
"""
input user_transactions_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: user_transactions_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input user_transactions_stream_cursor_value_input {
  block_height: bigint
  entry_function_id_str: String
  epoch: bigint
  expiration_timestamp_secs: timestamp
  gas_unit_price: numeric
  inserted_at: timestamp
  max_gas_amount: numeric
  parent_signature_type: String
  sender: String
  sequence_number: bigint
  timestamp: timestamp
  version: bigint
}

"""aggregate sum on columns"""
type user_transactions_sum_fields {
  block_height: bigint
  epoch: bigint
  gas_unit_price: numeric
  max_gas_amount: numeric
  sequence_number: bigint
  version: bigint
}

"""
update columns of table "user_transactions"
"""
enum user_transactions_update_column {
  """column name"""
  block_height

  """column name"""
  entry_function_id_str

  """column name"""
  epoch

  """column name"""
  expiration_timestamp_secs

  """column name"""
  gas_unit_price

  """column name"""
  inserted_at

  """column name"""
  max_gas_amount

  """column name"""
  parent_signature_type

  """column name"""
  sender

  """column name"""
  sequence_number

  """column name"""
  timestamp

  """column name"""
  version
}

input user_transactions_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: user_transactions_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: user_transactions_set_input

  """filter the rows which have to be updated"""
  where: user_transactions_bool_exp!
}

"""aggregate var_pop on columns"""
type user_transactions_var_pop_fields {
  block_height: Float
  epoch: Float
  gas_unit_price: Float
  max_gas_amount: Float
  sequence_number: Float
  version: Float
}

"""aggregate var_samp on columns"""
type user_transactions_var_samp_fields {
  block_height: Float
  epoch: Float
  gas_unit_price: Float
  max_gas_amount: Float
  sequence_number: Float
  version: Float
}

"""aggregate variance on columns"""
type user_transactions_variance_fields {
  block_height: Float
  epoch: Float
  gas_unit_price: Float
  max_gas_amount: Float
  sequence_number: Float
  version: Float
}

